---
title: 'Notebook: Identifying the role of foraging state on hunt effficiency'
output:
  html_document:
    df_print: paged
    params: 
    output_dir: "/media/kostasl/D445GB_ext4/kostasl/Dropbox/Calculations/zebrafishtrackerData/foragingAnalysis"

  html_notebook: default
  pdf_document: default
  
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook, analysing zebrafish tracking data 
for foraging state as indicated by Marquez et al 2019. I aim to extend my previous work on the experience driven ontogeny of hunting skill [now published in eLife](https://elifesciences.org/articles/55119/figures) 
Zebrafish appear to spontaneously switch between an exploratory and exploitation phase that grossly defines their behavioural mode. 
The state can be read out be measuring trajectory dispersal over a fixed period of time (5 sec), 
According to Marquez et al  2020 Measures of dispersal should appear bimodal, with short dispersals indicating exploitation phase.

Given our behavioural recordings are not continuous, and exclude periods when the larva are swimming around the boundary, it is not certain whether we would be able to detect exploratory phases. These tend to be circling around the border of the petri-dish, as the fish attempts to swim forward. Nevertheless as we are interested in the mode-state under which hunt-events are executed, then we expect that some of these events should be executed during exploratory behaviour and this should be detectable - (dispersal, movement rates etc).
In essense the internal state and the its neural correlates as reported by Marquez et al 2019 can combined with my results on the learned aspects of efficient hunting to study if this foraging state swithcing is also influenced by experience and  whether differences in hunting kinematics correlate with internal state.

  Hypothesis being tested :
  - Does experience modify the dispersal  and so the exploit/explore state of each group?
  - Are foraging intervals modified based on priors built by experience and can these be modelled based on active inference ?(co-op with Rosalyn & Berk)
  - Could expansion of foraging interval explain the higher evoked hunt-rate of the LF group?
  - Does the execution of the kinematic adaptations of capture efficiency, found in the experience larvae,  depend on foraging state ?
  
Establishing a correlation of hunting state with the kinematics of efficient hunting can point us to the underlying circuits, because the circuits that correlate with foraging state, but also with capture-success,  have already been examined by Marquez et al 2019. So it would be posssible to use those to guide our search for the circuits that bring about the kinematics adaptations of success. 


### Identify state using dispersal
5s window measure radius encompassing trajectory

```{r message=FALSE, cache=FALSE, results='hide', setup, echo=FALSE}
## Init  Code 
setwd("/home/kostasl/workspace/zebrafishtrack/Rplots")
#setwd(here())
source("config_lib.R")
source("TrajectoryAnalysis.r")


setEnvFileLocations("HOME") #HOME,OFFICE,#LAPTOP
## To compile to different destination run:
# rmarkdown::render("ForagingStateAnalysis.Rmd",output_dir = paste0(strDataExportDir,'../foragingAnalysis') )

## Load datAllFrames
loaddatAllFrames <- function()
{
  if (!exist("datAllFrames"))
  {
    load(paste(strDatDir,"datAllFramesFix1_Ds-5-19.RData",sep="/"))
    load(paste(strDatDir,"groupsrcdatListPerDataSet_Ds-5-19.RData",sep="/"))
  }
}

tsec_timeWindow <- 5
thres_dispersion_class <- 0.2
##Clustering
Nclust <- 2
nsubsampleInterval <- G_APPROXFPS/2


#Original Dispersion Record per frame
#datDispersion = readRDS(file=paste0(strDataExportDir,"/foragingState_Dispersion",tsec_timeWindow,"sec.rds") )
## Extended Dispersion Merged With maxDispersion Data
#rm("datDispersion")
loadDispersionData <- function()
{
  try(
    datDispersion <<- readRDS(file=paste0(strDataExportDir,"/foragingState_Dispersion_merged_rangeperLarva_",tsec_timeWindow,"sec.rds") ) 
  )
  
  if (!exists("datDispersion"))
  {
    message("Calculate Trajectory Dispersions")
    loaddatAllFrames()
    datDispersion <- calcTrajectoryDispersions(datAllFrames)
  }
  AllRange <<- range(datDispersion$Dispersion,na.rm=TRUE)
}


```

```{r,merge max larval-dispersion onto dispersion data events, echo=FALSE,cache=FALSE,results=FALSE}
## Attaches the max Dispersion found between both evoked and spontaneous trajectories of each larva
## This is used so we can combine S/E larval recordings to detect both exploration/ exploitation state - and normalize appropriatelly to the joined trajectrories between tests as if they were ## one 20min recording  
mergeRangeOfLarvalDispersionPerLarvaOntoDispersion <- function(datDispersion,datExpPairs)
{
    ## Merge Max Dispersion per larva Onto Dispersion data (so we can normalize on a per larva basis instead of experiment basis)
  ## Calc Normalization to Max Dispersion by combining both Spont And Exoked cond per larva
  ## Find Max Dispersion Per Experiement
  datDispersionMax <- data.frame(tapply(datDispersion$Dispersion,datDispersion$expID,max,na.rm = TRUE))
  datDispersionMin <- data.frame(tapply(datDispersion$Dispersion,datDispersion$expID,min,na.rm = TRUE))
  
  ## pair each experiemnt with its max dispersion between Spontaneous and Evoked conditions of a larva
  ## We use this struct to merge with Dispersion data of each frame / So as to normalize approprietelly
  datDispesionRange_Pairs <-  rbind.data.frame(
                                           cbind.data.frame(
                                             expID = as.character(datExpPairs$expID.S) ,
                                             groupID = as.character(datExpPairs$groupID.S),
                                              max_exp_Disp = datDispersionMax[as.character(datExpPairs$expID.S),],
                                              max_exp_Disp.C = datDispersionMax[as.character(datExpPairs$expID.E),],
                                              min_exp_Disp = datDispersionMin[as.character(datExpPairs$expID.S),],
                                              min_exp_Disp.C = datDispersionMin[as.character(datExpPairs$expID.E),]),
                                           cbind.data.frame(
                                                expID = as.character(datExpPairs$expID.E) ,
                                                groupID = as.character(datExpPairs$groupID.E),
                                                max_exp_Disp = datDispersionMax[as.character(datExpPairs$expID.E),],
                                                max_exp_Disp.C = datDispersionMax[as.character(datExpPairs$expID.S),],
                                                min_exp_Disp = datDispersionMin[as.character(datExpPairs$expID.E),],
                                                min_exp_Disp.C = datDispersionMin[as.character(datExpPairs$expID.S),])
                                            )
                                      
                                          
  ## Add col for Max/min Dispersion across Spont and Evoked conditions
  datDispesionRange_Pairs$max <- as.numeric(apply(datDispesionRange_Pairs[,3:4], 1, max,na.rm=TRUE)) 
  datDispesionRange_Pairs$min <- as.numeric(apply(datDispesionRange_Pairs[,5:6], 1, min,na.rm=TRUE)) 
  
  ##Make Simple frame for merging with dispersion data
  datMaxDispersionPerLarva <- cbind.data.frame(expID=as.character(datDispesionRange_Pairs$expID),
                                               groupID=as.character(datDispesionRange_Pairs$groupID),
                                               max_larval_Dispersion=(datDispesionRange_Pairs$max),
                                               min_larval_Dispersion=(datDispesionRange_Pairs$min),
                                               max_exp_Dispersion=(datDispesionRange_Pairs$max_exp_Disp), # Add The max Disp Recorded for this larva
                                               min_exp_Dispersion=(datDispesionRange_Pairs$min_exp_Disp) # Add The max Disp Recorded for this larva
                                               )
  datDispersionM <- merge(datDispersion,datMaxDispersionPerLarva,all.x = TRUE,by=c("expID","groupID"),no.dups=FALSE)

  #Calculate Range Normalized dispersion per larva - to match Marquez et al 2019
  ## Save  dispersion data normalized across Spont and evoked condition for each larva (saves time in future plotting)
  datDispersionM <- cbind.data.frame(datDispersionM,
                                     Dispersion_larval_norm=(datDispersionM$Dispersion-datDispersionM$min_larval_Dispersion) / (datDispersionM$max_larval_Dispersion-datDispersionM$min_larval_Dispersion) )

  ## Now Merge onto Dispersion Data 
  saveRDS(datDispersionM,file=paste0(strDataExportDir,"/foragingState_Dispersion_merged_rangeperLarva_",tsec_timeWindow,"sec.rds") )
  saveRDS(datMaxDispersionPerLarva,file=paste0(strDataExportDir,"/foragingState_max_Dispersion_perLarva_",tsec_timeWindow,"sec.rds") )
  message("Saved to:",paste0(strDataExportDir,"/foragingState_Dispersion_merged_rangeperLarva_",tsec_timeWindow,"sec.rds") )
  message("Saved to:",paste0(strDataExportDir,"/foragingState_max_Dispersion_perLarva_",tsec_timeWindow,"sec.rds") )

  return(datDispersionM)
}
```


```{r,combine-dispersion-with-hunt events, echo=FALSE,cache=TRUE,results=FALSE}

### Combines information across Detected HuntEvents and their outcome, the dispersion of the larval trajectory during which these were
## initiated  ,and the position at which the hunt-event was initiated
mergeDispersionOntoHuntEvents <- function(datDispersion, datAllFrames, datHuntLabelledEventsSBMerged_fixed)
{
  message(paste(" Loading Hunt Event List to Analyse... "))

  start.time <- Sys.time()
  ## Attach Frame Number to Dispersion Data
  datDispersion <- cbind(datDispersion,frameN=datAllFrames[datDispersion[,"frameRow"],'frameN'],
                         posX=datAllFrames[datDispersion[,"frameRow"],'posX'],
                         posY=datAllFrames[datDispersion[,"frameRow"],'posY'])
  
  ## Extract HUnt Event Foraging State
  ### 1. Get Dispersion Measure of each hunt event
  ## MERGE Dispersion With HuntEvent Records
    # Need to convert to char  GroupID factor( datHuntLabelledEventsSBMerged_fixed$groupID) 
    datDispersion$groupID <- levels( datDispersion$groupID)[datDispersion$groupID]
    datHEventDispersion <- merge(datDispersion,datHuntLabelledEventsSBMerged_fixed,
                                 all.y=TRUE,
                                 by.x=c("frameN","expID","eventID","groupID"),
                                 by.y=c("startFrame","expID","eventID","groupID") )
    ## Add Position In Arena
    saveRDS(datHEventDispersion,file=paste0(strDataExportDir,"/huntEvent_mergedwith_Dispersion",tsec_timeWindow,"sec.rds") )
    message("Saved to:",paste0(strDataExportDir,"/huntEvent_mergedwith_Dispersion",tsec_timeWindow,"sec.rds") )
    
  end.time <- Sys.time()
  time.taken <- end.time - start.time
  print(time.taken)
  
  return(data.frame(datHEventDispersion ) )
}



```



```{r,  merge hunt events and max_dispersion with dispersion data, fig.show="hold", out.width="50%", echo=FALSE, cache=FALSE,results=FALSE,message=FALSE }
source("DataLabelling/labelHuntEvents_lib.r")
source("HuntingEventAnalysis_lib.r")
  

#load(file=paste(strDatDir,"/LabelledSet/",strProcDataFileName,".RData",sep="" )) ##Save With Dataset Idx Identifier
datHuntLabelledEventsSBMerged_fixed <- getLabelledHuntEventsSet() # readRDS(file=paste(strDatDir,"/LabelledSet/",strProcDataFileName,".rds",sep="" ))

##Clear Warningss : assign("last.warning", NULL, envir = baseenv()
## Link Evoked and Spontaneous Trajectories
datHuntStat <- makeHuntStat(datHuntLabelledEventsSBMerged_fixed)
datExpPairs <- getSpontaneousEvokedExperimentPairs(datHuntStat)

message("Loading from :",paste0(strDataExportDir,"/huntEvent_mergedwith_Dispersion",tsec_timeWindow,"sec.rds") )
try(
datHEventDispersion <<- readRDS(file=paste0(strDataExportDir,"/huntEvent_mergedwith_Dispersion",tsec_timeWindow,"sec.rds") )
)

loadDispersionData()
## If we have not merged these records before, make them now
if (!exists("datHEventDispersion"))
{ 
  datHEventDispersion <- mergeDispersionOntoHuntEvents(datDispersion,datAllFrames,datHuntLabelledEventsSBMerged_fixed)
}

## Merge Max Dispersion on there - If it is not already there then Calculate and save 
if (!any(grepl("max_larval_Dispersion",names(datDispersion)) ) | 
    !any(grepl("min_larval_Dispersion",names(datDispersion)) ) |
    !any(grepl("Dispersion_larval_norm", names(datDispersion)) )  )
  datDispersion <<- mergeRangeOfLarvalDispersionPerLarvaOntoDispersion(datDispersion,datExpPairs)
## Check for max Calc Error
#datDispersion[datDispersion$Dispersion > datDispersion$max_Dispersion,]
```


```{r Function to plot trajectories for each larva, coloured based on dispersion, figures-function, fig.show="hold", out.width="50%", echo=FALSE ,results=FALSE}

pairedTrajPalette <- col2hex(col2rgb(brewer.pal(12,"Paired"),alpha = 1))

#
# Function Plot Individual Trajectories for a group, split between exploration and exploitation
# given a *global* normalized dispersion measures threshold 
#
plotGlobalNormDispersionTrajectories <- function(groupID, datAllFrames, datDispersion, datHEventDispersion,datExpPairs,TH_DISP = 0.2)
{
  
  datGroupExploreTraj <- datAllFrames[datDispersion[datDispersion$groupID %in% groupID & datDispersion$Dispersion/AllRange[2] >= TH_DISP,"frameRow"],]
  datGroupExploitTraj <- datAllFrames[datDispersion[datDispersion$groupID %in% groupID & datDispersion$Dispersion/AllRange[2] < TH_DISP ,"frameRow"],]
  
  ## ind Exploration Hunt Events 
  datExplorationHuntEvents <- datHEventDispersion[datHEventDispersion$Dispersion/AllRange[2] >= TH_DISP, ]
  ## ind Exploration Hunt Events 
  datExploitationHuntEvents <- datHEventDispersion[datHEventDispersion$Dispersion/AllRange[2] < TH_DISP, ]
  
  
  plotExploreExploitTrajectories(groupID,datGroupExploreTraj,datGroupExploitTraj, datExplorationHuntEvents, 
                                 datExploitationHuntEvents,datDispersion,
                                 datExpPairs[datExpPairs$groupID.E %in%  groupID | datExpPairs$groupID.S %in%  groupID, ]) ##Subset to Targeted groups
  
} ## end of plot Function
 
##
# Function Plot Individual Trajectories for a group, split between exploration and exploitation
# given a *local* normalized dispersion measures threshold / the classification is relative to the mobility measure of each larvae in each condition 
##
plotExpNormDispersionTrajectories <- function(groupID, datAllFrames, datDispersion,datHEventDispersion, datExpPairs,TH_DISP = 0.2)
{

  datGroupExploreTraj <- datAllFrames[datDispersion[datDispersion$groupID %in% groupID & datDispersion$Dispersion_norm >= TH_DISP,"frameRow"],]
  datGroupExploitTraj <- datAllFrames[datDispersion[datDispersion$groupID %in% groupID & datDispersion$Dispersion_norm <  TH_DISP,"frameRow"],]
   
  ## \TODO: Norm per larva in both spont and Evoked
  ## ind Exploration Hunt Events 
  datExplorationHuntEvents <- datHEventDispersion[datHEventDispersion$Dispersion_norm >= TH_DISP, ]
  
  ## ind Exploration Hunt Events 
  datExploitationHuntEvents <- datHEventDispersion[datHEventDispersion$Dispersion_norm < TH_DISP, ]
  
  ## Call Plot Function - Both Spont And Evoked plo tted on same figure
  plotExploreExploitTrajectories(groupID,datGroupExploreTraj,datGroupExploitTraj, datExplorationHuntEvents, 
                                 datExploitationHuntEvents,datDispersion,
                                 datExpPairs[datExpPairs$groupID.E %in%  groupID | datExpPairs$groupID.S %in%  groupID, ]) ##Subset to Targeted groups
  
} ## end of plot Functon

##
# Function Plot Individual Trajectories for a group, split between exploration and exploitation
# given based on threshold placed on the normalized dispersion of the trajectories from combined spont and evoked conditions of each larva .
##
plotLarvaNormDispersionTrajectories <- function(groupID, datAllFrames, datDispersion, datHEventDispersion,datExpPairs,TH_DISP = 0.2)
{ 
  datGroupExploreTraj <- datAllFrames[datDispersion[datDispersion$groupID %in% groupID & datDispersion$Dispersion_larval_norm >= TH_DISP,"frameRow"],]
  datGroupExploitTraj <- datAllFrames[datDispersion[datDispersion$groupID %in% groupID & datDispersion$Dispersion_larval_norm < TH_DISP,"frameRow"],]
  
  ## ind Exploration Hunt Events 
  datExplorationHuntEvents <- datHEventDispersion[datHEventDispersion$Dispersion_larval_norm >= TH_DISP, ]
  ## ind Exploration Hunt Events 
  datExploitationHuntEvents <- datHEventDispersion[datHEventDispersion$Dispersion_larval_norm < TH_DISP, ]
  
  
  plotExploreExploitTrajectories(groupID,datGroupExploreTraj,datGroupExploitTraj, datExplorationHuntEvents, 
                                 datExploitationHuntEvents,datDispersion,
                                 datExpPairs[datExpPairs$groupID.E %in%  groupID | datExpPairs$groupID.S %in%  groupID, ]) ##Subset to Targeted groups
  
} ##


## Plot function for scatter plot of colour coded larval trajectories, separated into explore and exploit vectors
## with Both Spont And Evoked plotted on same figure
###  datExpPairs - expID for Spont and Evoked for each larva
plotExploreExploitTrajectories <- function(groupID,datGroupExploreTraj,datGroupExploitTraj, datExplorationHuntEvents, datExploitationHuntEvents, datDispersion, datExpPairs, thin=3,TH_DISP = 0.2)
{
  
  #vexpID <-  unique(datGroupExploitTraj$exp) 
  #par(mfrow=c(2,NROW(vexpID))) ##MultiPlot Page
  #par(mar=c(1,1,1,1))
  #layout(matrix(seq(1,NROW(vexpID)), 2,NROW(vexpID) , byrow = TRUE))
  i <- 0
  for (j in 1:nrow(datExpPairs) )
  {
      e <- datExpPairs[j,]
      if (is.na(e$expID.E))
        next()
      x1  <- seq(0, 640 )
      y1  <- seq(0, 550 )

      #print(e)
      plot(0,0,ylim=range(y1),xlim=range(x1), type="l", col="red", main=paste(groupID[1],e$expID.E,"/",groupID[2],e$expID.S) )
      ## Evoked Exploration
      datTraj <- datGroupExploreTraj[datGroupExploreTraj$expID == as.character(e$expID.E) & !is.na(datGroupExploreTraj$posX),]
      if (NROW(datTraj))
      {
        idxplot <- seq(1,NROW(datTraj),thin)
        points(datTraj[idxplot,]$posX,datTraj[idxplot,]$posY,type="p", col=pairedTrajPalette[1], cex=0.1);
      }
      ## Add Hunt Events on Map
      # Evoked Exploration
      datSpotHunts.E.Explore <- datExplorationHuntEvents[datExplorationHuntEvents$expID == as.character(e$expID.E)  & !is.na(datExplorationHuntEvents$expID), ] 
      points(datSpotHunts.E.Explore$posX, datSpotHunts.E.Explore$posY, col=pairedTrajPalette[2], cex=1.2, pch=17) ## Triangle Explore
  
      ## Spontaneous Explore
      datTraj <- datGroupExploreTraj[datGroupExploreTraj$expID == as.character(e$expID.S) & !is.na(datGroupExploreTraj$posX),]
      if (NROW(datTraj))
      {
        idxplot <- seq(1,NROW(datTraj),thin)
        points(datTraj[idxplot,]$posX,datTraj[idxplot,]$posY,type="p", col=pairedTrajPalette[3], cex=0.1);
      }
      ## Spont Exploration
      datSpotHunts.S.Explore <- datExplorationHuntEvents[datExplorationHuntEvents$expID == as.character(e$expID.S)  & !is.na(datExplorationHuntEvents$expID), ] 
      points(datSpotHunts.S.Explore$posX, datSpotHunts.S.Explore$posY, col=pairedTrajPalette[4], cex=1.2, pch=17) ##  Triangle Explore
  
      
      ## Evoked Exploit
      datTraj <- datGroupExploitTraj[datGroupExploitTraj$expID == as.character(e$expID.E) & !is.na(datGroupExploitTraj$posX),]
      if (NROW(datTraj))
      {      
        idxplot <- seq(1,NROW(datTraj),thin)
        points(datTraj[idxplot,]$posX,datTraj[idxplot,]$posY,type="p",col=pairedTrajPalette[5], cex=0.1)
      }
      ## Evoked Exploitation
      datSpotHunts.E.Exploit <- datExploitationHuntEvents[datExploitationHuntEvents$expID == as.character(e$expID.E)  & !is.na(datExploitationHuntEvents$expID), ] 
      points(datSpotHunts.E.Exploit$posX, datSpotHunts.E.Exploit$posY,col=pairedTrajPalette[6], cex=1.2,pch=15) ## Square Evoked


      ## Spontaneous Exploit
      datTraj <- datGroupExploitTraj[datGroupExploitTraj$expID == as.character(e$expID.S) & !is.na(datGroupExploitTraj$posX),]
      if (NROW(datTraj))
      { 
        idxplot <- seq(1,NROW(datTraj),thin)
        points(datTraj[idxplot,]$posX,datTraj[idxplot,]$posY,type="p",col=pairedTrajPalette[7], cex=0.1)
      }
      ## Hunt Episodes Spont Exploitation
      datSpotHunts.S.Exploit <- datExploitationHuntEvents[datExploitationHuntEvents$expID == as.character(e$expID.S)  & !is.na(datExploitationHuntEvents$expID), ] 
      points(datSpotHunts.S.Exploit$posX, datSpotHunts.S.Exploit$posY,col=pairedTrajPalette[8], cex=1.2,pch=15) ## Square Evoked
  
      
      badd <- TRUE
      ## Add dispersion Time Line + Hunt Events + Norm threshold Threshold
      datDisp.S <- datDispersion[datDispersion$expID == as.character(e$expID.S) ,]
      datDisp.E <- datDispersion[datDispersion$expID == as.character(e$expID.E) ,]
      ## Sort by frameRo
      datDisp.S <- datDisp.S[order( as.numeric(datDisp.S$frameRow) ), ]
      datDisp.E <- datDisp.E[order( as.numeric(datDisp.E$frameRow) ), ]
            
      idxplot.S <- seq(min(1,NROW(datDisp.S)),max(1,NROW(datDisp.S)),thin)
      idxplot.E <- seq(min(1,NROW(datDisp.S)),max(1,NROW(datDisp.E)) ,thin)
      datDisp.S.frame <- as.numeric(datDisp.S[idxplot.S,]$frameRow)- min((as.numeric(datDisp.S[idxplot.S,]$frameRow) ),na.rm = TRUE ) #datAllFrames[datDisp.S[idxplot.S,]$frameRow,"frameN" ]
      datDisp.E.frame <- max(datDisp.S.frame,na.rm=TRUE) +  as.numeric(datDisp.E[idxplot.E,]$frameRow)-min(c(as.numeric(datDisp.E[idxplot.E,]$frameRow) ),na.rm = TRUE ) 
      
      ##frameN restarts to 0 for each event so best use frameRow
      plot(datDisp.S.frame/G_APPROXFPS ,datDisp.S[idxplot.S,]$Dispersion,type="l" ,ylim=c(0,10),xlim=c(0,max(c(0,datDisp.E.frame),na.rm =TRUE)/G_APPROXFPS ),xlab="(sec)",
           ylab="Dispersal (mm)", col=colourDataScheme[[ as.character(e$groupID.S)  ]] )
      lines(datDisp.E.frame/G_APPROXFPS, datDisp.E[idxplot.E,]$Dispersion,type="l", col=colourDataScheme[[ as.character(e$groupID.E)  ]] )
      
      ##All Hunt larva hunt events together
      datSpotHunts.S <- rbind(datSpotHunts.S.Exploit,datSpotHunts.S.Explore)
      datSpotHunts.E <- rbind(datSpotHunts.E.Exploit,datSpotHunts.E.Explore)  
      
      ##Add Hunt Event ##datDisp.S[datDisp.S$frameRow == datSpotHunts.S$frameRow,]$Dispersion <- fails cause Disp data may be missing at hunt event frame
      ## Use FrameRow As timepoint sequence - reset to 0 using min(frameRow) for event, and attach Evoked to the back of spontaneous
      points( (as.numeric(datSpotHunts.S$frameRow)-min(as.numeric(datDisp.S[idxplot.S,]$frameRow),na.rm=TRUE ) )/G_APPROXFPS, rep(-0.1,times=NROW(datSpotHunts.S$frameN)), cex=1, pch=17)
      points( (max(idxplot.S) +  as.numeric(datSpotHunts.E$frameRow)-min(as.numeric(datSpotHunts.E$frameRow)))/G_APPROXFPS, rep(-0.1,times=NROW(datSpotHunts.E$frameN)) ,cex=1,pch=17)
      ##Show Larval Norm Threshold - Draw line
      thres_Dispersion_mm <- min((datDisp.E[datDisp.E$Dispersion_larval_norm >= TH_DISP, ] $Dispersion),na.rm=TRUE )
      segments(0,thres_Dispersion_mm, max(datDisp.E.frame,na.rm=TRUE)/G_APPROXFPS,
               thres_Dispersion_mm,lty=3)
      
      
      #stopifnot(i < 5)
      i <- i+1
  } ## For Each Event
    
}## End of Function 


```



```{r Calc Dispersion of Each Trajectory}
calcTrajectoryDispersions <- function(datAllFrames)
{

  datDispersion <- data.frame()
  vexpID <- unique(datAllFrames$expID)
  e <- vexpID[1]
  ##'Add new column
  datAllFrames$Dispersion <- NA
  
  start.time <- Sys.time()
   
  i = 0;

  ## For Each Recording Event of each experiment
    for (e in vexpID)
    {
      i = i + 1
      message(i,". ExpID:",e)
      
      
      stopifnot(is.numeric(e) & e > 0)
      #stopifnot(i < 3) ##Test Run
      
      vEventID = unique((datAllFrames[datAllFrames$expID == e,]$eventID))
    
      
      ##For Each Event
      for (ev in vEventID)
      {
        datEventFrames <- datAllFrames[datAllFrames$expID == e & datAllFrames$eventID == ev & datAllFrames$posX != 0 ,]  
      
        meanfps <-  head(datEventFrames$fps,1)
        groupID <- as.character(unique(datEventFrames$groupID) )
        message(paste("ExpID:",e,"EventID:",ev,"fps:",meanfps," nFrames:",NROW(datEventFrames)) )
        #  We may Need to Identify TrackLet Units, Avoid speed calc errors due to fish going in and out of view
        #  PROCESS TrackLets #
        #vTracklets <- unique(datEventFrames$trackletID)
        
        if (NROW(datEventFrames) < 10)
          next() ##No Frames In event - Move to next one
        
        vEventDispersion <- calcTrajectoryDispersion(datEventFrames,tsec_timeWindow) 
        datEventDispersion <- data.frame(expID=e,
                                         eventID=ev,
                                         Dispersion=(vEventDispersion),
                                         Dispersion_norm=(vEventDispersion),
                                         frameRow=as.integer(row.names( datEventFrames))  )
  
        ##Append to main Dispersion Data Frame
        datDispersion <- rbind(datEventDispersion,datDispersion)
        
      }##For Each Event
  
    ## \TODO Normalize Dispersion Per Larva Here - Dividing by the maximum dispersion
    datExpDisp <- datDispersion[datDispersion$expID == e,]
    range_Disp <- range(datExpDisp$Dispersion,na.rm=TRUE)
     if (!is.na(range_Disp))
        datDispersion[datDispersion$expID == e,]$Dispersion_norm <- datExpDisp$Dispersion/range_Disp[2]
    
    end.time <- Sys.time()
    time.taken <- end.time - start.time
    print(time.taken)
    
    }#For Each Exp ID
  
    end.time <- Sys.time()
    time.taken <- end.time - start.time
    print(time.taken)
    
  datDispersion <- cbind(datDispersion,groupID=datAllFrames[datDispersion$frameRow,]$groupID)
    
  saveRDS(datDispersion,file=paste0(strDataExportDir,"/foragingState_Dispersion",tsec_timeWindow,"sec.rds") )
  
  return (datDispersion)
} ## Calc Fuction

#hist(datDispersion$Dispersion_norm )
```

## Detect Exploration -Exploitation via dispersion
 
 In Marquez et al. 2019 Ext Fig 3a, the dispersion of each larva is normalized against its own range before the overall (bimodal) distribution is shown.
 The normalized dispersion distributions  of each larva are used to detect the threshold that separates the exploitation and exploration state.  
 They report (Extended Data Fig. 3a), substantially higher dispersal in the exploration state (9.6 ± 2.5 mm, mean ± s.d., n = 36 animals) than in the exploitation state (2.3 ± 1.3 mm, n = 36 animals).

 Using my tracking data I calculated the dispersion at each tracked video frame and plot the distribution to examine if they are bimodal (here using the `r tsec_timeWindow` seconds window).
However, my tracking of each larva is limited to 10 min, and includes only the centre of the arena, but in Marquez et al. 2019 each larva is recorded *for 50-80 min*, while the mean duration of each state is reported to be on average, the *exploitation state persists for 7.1 ± 3.9 min*, and *exploration state persists for 5.5 ± 6.2 min*
(mean ± s.d., n = 36 animals). The duration of each state follows an exponential distribution (λ = 0.17 min−1
for exploitation, λ = 0.22 min−1 for exploration, pooled distribution of n = 36 animals) see (raw data shown on Ext. Fig 7a).

Unfortunatelly with my 10 min recordings for each larvae, it is most likely that I will not observe their behaviour in both states, but likely only observe them in on of these states. This is added ontop the fact that I do not record around the edges of the arena, as they do to see them run around.
Therefore, normalizing and setting a threshold on a per larva basis may not be a good idea.
Perhaps it is best I combine the trajectories of spontaneous and evoked activity for each larva so as to obtain 20min of observation time. 

 Without normalizing the distribution is shown on the left, and a version normalized per max dispersion measured in each experiment is on the right :
 
```{r dispersion histograms across groups, fig.show="hold", out.width="33%", echo=FALSE, results='hide'  }
loadDispersionData()

hist(datDispersion$Dispersion,breaks=50,main="(All groups): Dispersion lengths per experiment ",xlab="Dispersion (mm)")
hist(datDispersion$Dispersion_norm,breaks=50,main="(All groups): Dispersion normalized",xlab="Dispersion (exp. norm)")
hist(datDispersion$Dispersion_larval_norm ,breaks=50,main="(All groups): Dispersion normalized per larva",xlab="Dispersion (larva norm)")

```
We look at each rearing group separatelly, while combining their evoked and spontaneous conditions

```{r dispersion histograms per group across conditions, fig.show="hold", out.width="33%", echo=FALSE, results='hide'  }
hist(datDispersion[datDispersion$groupID %in% c('LE','LL'), ]$Dispersion,breaks=50,main="LF Evoked+Spont.",xlab="Dispersion (mm)",col=colourDataScheme$LF$Evoked)
hist(datDispersion[datDispersion$groupID %in% c('NE','NL'), ]$Dispersion,breaks=50,main="NF Evoked+Spont.",xlab="Dispersion (mm)",col=colourDataScheme$NF$Evoked)
hist(datDispersion[datDispersion$groupID %in% c('DE','DL'), ]$Dispersion,breaks=50,main="DF Evoked+Spont.",xlab="Dispersion (mm)",col=colourDataScheme$DF$Evoked)

```


We then plot each experimental group individually, also examining the dispersion in evoked (in the presence of prey) and spontaneous (no prey) conditions separatellly.
Next we plot these for each experimental condition individually (non-Normalized):
```{r dispersion histograms per group per condition, fig.show="hold", out.width="33%", echo=FALSE, results='hide'  }
# 
# ## Normed over all Recorded Dispersions
 hist(datDispersion[datDispersion$groupID == 'LE', ]$Dispersion,breaks=100,main="LF Spontaneous",xlab="Dispersion (mm)",col=colourDataScheme$LF$Spont)
 hist(datDispersion[datDispersion$groupID == 'NE', ]$Dispersion,breaks=100,main="NF Spontaneous",xlab="Dispersion (mm)",col=colourDataScheme$NF$Spont)
 hist(datDispersion[datDispersion$groupID == 'DE', ]$Dispersion,breaks=100,main="DF Spontaneous",xlab="Dispersion (mm)",col=colourDataScheme$DF$Spont)

 hist(datDispersion[datDispersion$groupID == 'LL', ]$Dispersion,breaks=100,main="LF Evoked",xlab="Dispersion (mm)",col=colourDataScheme$LF$Evoked)
 hist(datDispersion[datDispersion$groupID == 'NL', ]$Dispersion,breaks=100,main="NF Evoked",xlab="Dispersion (mm)",col=colourDataScheme$NF$Evoked)
 hist(datDispersion[datDispersion$groupID == 'DL', ]$Dispersion,breaks=100,main="DF Evoked",xlab="Dispersion (mm)",col=colourDataScheme$DF$Evoked)
```
 
Smooth estimates using a gaussian kernel show a shift towards exploitation for the pooled *LF* trajectories 
```{r,dispersion densities per larva-Split E-S, fig.show="hold", out.width="33%", echo=FALSE, results='hide' }
loadDispersionData()
 ## plot est, Densities Compare Spont to Evoked
 BW=0.2
 plot(density(datDispersion[datDispersion$groupID == 'NE', ]$Dispersion, kernel="gaussian",na.rm=TRUE, bw=BW), lwd=4, ylim=c(0,0.7), col=colourDataScheme$NF$Spont,main="NF  ",xlab="Dispersion (mm)",lty=1  )
 lines(density(datDispersion[datDispersion$groupID == 'NL', ]$Dispersion,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$NF$Evoked,main=NA,lty=2)
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$NF$Spont,colourDataScheme$NF$Evoked),lwd=3 ) 
 
  plot(density(datDispersion[datDispersion$groupID == 'LE', ]$Dispersion, kernel="gaussian",na.rm=TRUE,bw=BW), lwd=4, ylim=c(0,0.7),col=colourDataScheme$LF$Spont,main="LF  ",xlab="Dispersion (mm)",lty=1 )
 lines(density(datDispersion[datDispersion$groupID == 'LL', ]$Dispersion,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$LF$Evoked,main=NA,lty=2 )
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$LF$Spont,colourDataScheme$LF$Evoked),lwd=3 ) 

 plot(density(datDispersion[datDispersion$groupID == 'DE', ]$Dispersion, kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4, ylim=c(0,0.7),col=colourDataScheme$DF$Spont,main="DF  ",xlab="Dispersion (mm)",lty=1 )
 lines(density(datDispersion[datDispersion$groupID == 'DL', ]$Dispersion,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$DF$Evoked,main=NA,lty=2 )
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$DF$Spont,colourDataScheme$DF$Evoked),lwd=3 ) 

```


<!-- For completness, the following dispersions have been normalized to maximum trajectory dispersion found across all experiments (*global normalization*): -->
```{r plot globally normalized dispersion distributions, fig.show="hold", out.width="33%", echo=FALSE, results='hide',include=FALSE,eval=FALSE  }

# ## Normed over all Recorded Dispersions
 hist(datDispersion[datDispersion$groupID == 'LE', ]$Dispersion/AllRange[2],breaks=100,main="LF Spontaneous",xlab="Dispersion (global norm. )")
 hist(datDispersion[datDispersion$groupID == 'NE', ]$Dispersion/AllRange[2],breaks=100,main="NF Spontaneous",xlab="Dispersion (global norm. )")
 hist(datDispersion[datDispersion$groupID == 'DE', ]$Dispersion/AllRange[2],breaks=100,main="DF Spontaneous",xlab="Dispersion (global norm. )")

 hist(datDispersion[datDispersion$groupID == 'LL', ]$Dispersion/AllRange[2],breaks=100,main="LF Evoked",xlab="Dispersion (global norm. .)")
 hist(datDispersion[datDispersion$groupID == 'NL', ]$Dispersion/AllRange[2],breaks=100,main="NF Evoked",xlab="Dispersion (global norm. )")
 hist(datDispersion[datDispersion$groupID == 'DL', ]$Dispersion/AllRange[2],breaks=100,main="DF Evoked",xlab="Dispersion (global norm. )")
 
```

### Normalized dispersion per experiment

Next, we examine the same dispesions normalized against the maximum dispersion calculated in the trajectory length of the respective experiment.
Each measured dispersion is divided by the max dispersion trajectory experiment,
(ie for each larva  this can be different in evoked or spontaneous conditions).

```{r,plot normalized dispersion distributions, fig.show="hold", out.width="33%", echo=FALSE, results='hide' }
### Normed Per Larva

hist(datDispersion[datDispersion$groupID == 'LE', ]$Dispersion_norm,breaks=100,main="LF Spontaneous",xlab="Dispersion  (norm per exp.)", col=colourDataScheme$LF$Spont)
hist(datDispersion[datDispersion$groupID == 'NE', ]$Dispersion_norm,breaks=100,main="NF Spontaneous",xlab="Dispersion  (norm per exp.)", col=colourDataScheme$NF$Spont)
hist(datDispersion[datDispersion$groupID == 'DE', ]$Dispersion_norm,breaks=100,main="DF Spontaneous",xlab="Dispersion  (norm per exp.)", col=colourDataScheme$DF$Spont)

hist(datDispersion[datDispersion$groupID == 'LL', ]$Dispersion_norm,breaks=100,main="LF Evoked",xlab="Dispersion  (norm per exp.)",col=colourDataScheme$LF$Evoked)
hist(datDispersion[datDispersion$groupID == 'NL', ]$Dispersion_norm,breaks=100,main="NF Evoked",xlab="Dispersion  (norm per exp.)",col=colourDataScheme$NF$Evoked)
hist(datDispersion[datDispersion$groupID == 'DL', ]$Dispersion_norm,breaks=100,main="DF Evoked",xlab="Dispersion  (norm per exp.)",col=colourDataScheme$DF$Evoked)

```

### Normalized dispersion per larva combined test conditions

Because each larva is recorded in two conditions, and as Marquez et al 2019 report that the foraging state switching can be seen intact both in the presence and in the absence of prey , we may then combine our spontaneous and evoked condition recordings and treat them as a single unit,  thus allowing us to  normalize each larvas trajectories to the max dispersion found across both its test conditions.  In this manner each larva's dispersion is examined across a 20min recording session.

```{r,dispersion histogram normalized per larva, fig.show="hold", out.width="33%", echo=FALSE, results='hide' }
### Dispesions distributions Normalized on Per Larva basis - 

hist(datDispersion[datDispersion$groupID %in% c('LE','LL'), ]$Dispersion_larval_norm, breaks=100,main="LF S+E ",xlab="Dispersion  (norm per larva)")
hist(datDispersion[datDispersion$groupID %in% c('NE','NL'), ]$Dispersion_larval_norm, breaks=100,main="NF S+E",xlab="Dispersion  (norm per larva)")
hist(datDispersion[datDispersion$groupID %in% c('DE','DL'), ]$Dispersion_larval_norm, breaks=100,main="DF S+E",xlab="Dispersion  (norm per larva)")

```

#### Histograms of normalized dispersion per larva, split S-E conditions 


Separating Spontaneous from Evoked Conditions we see a potential shift toward lower dispersion in the presence of prey:

```{r,dispersion histogram normalized per larva-Split E-S, fig.show="hold", out.width="50%", echo=FALSE, results='hide' }
### Dispesions distributions Normalized on Per Larva basis - 

hist(datDispersion[datDispersion$groupID %in% c('LE'), ]$Dispersion_larval_norm, breaks=100,main="LF Spont ", xlab="Dispersion  (norm per larva)",col=colourDataScheme$LF$Spont)
hist(datDispersion[datDispersion$groupID %in% c('LL'), ]$Dispersion_larval_norm, breaks=100,main="LF Evoked ",xlab="Dispersion  (norm per larva)",col=colourDataScheme$LF$Evoked)

hist(datDispersion[datDispersion$groupID %in% c('NE'), ]$Dispersion_larval_norm, breaks=100,main="NF Spont ", xlab="Dispersion  (norm per larva)",col=colourDataScheme$NF$Spont)
hist(datDispersion[datDispersion$groupID %in% c('NL'), ]$Dispersion_larval_norm, breaks=100,main="NF Evoked ",xlab="Dispersion  (norm per larva)", col=colourDataScheme$NF$Evoked)

hist(datDispersion[datDispersion$groupID %in% c('DE'), ]$Dispersion_larval_norm, breaks=100,main="DF Spont ", xlab="Dispersion  (norm per larva)",col=colourDataScheme$DF$Spont)
hist(datDispersion[datDispersion$groupID %in% c('DL'), ]$Dispersion_larval_norm, breaks=100,main="DF Evoked ",xlab="Dispersion  (norm per larva)",col=colourDataScheme$DF$Evoked)
```



#### Density estimation normalized dispersion per larva - compare Evoked to Spontaneous

Next I estimated densities using a gaussian kernel, allowing direct comparison between test conditions shows LF dispersions are modified by the presence of prey.

```{r,dispersion densities normalized per larva-Split E-S, fig.show="hold", out.width="33%", echo=FALSE, results='hide' }
 ## plot est, Densities Compare Spont to Evoked
 BW=0.01
 ylimUp <- 5
 plot(density(datDispersion[datDispersion$groupID == 'NE', ]$Dispersion_larval_norm, kernel="gaussian",na.rm=TRUE, bw=BW), lwd=4, ylim=c(0,ylimUp), col=colourDataScheme$NF$Spont,main="NF  ",xlab="Dispersion (norm. per larva)",lty=1  )
 lines(density(datDispersion[datDispersion$groupID == 'NL', ]$Dispersion_larval_norm,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$NF$Evoked,main=NA,lty=2)
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$NF$Spont,colourDataScheme$NF$Evoked),lwd=3 ) 
 
 plot(density(datDispersion[datDispersion$groupID == 'LE', ]$Dispersion_larval_norm, kernel="gaussian",na.rm=TRUE,bw=BW), lwd=4, ylim=c(0,ylimUp),col=colourDataScheme$LF$Spont,main="LF  ",xlab="Dispersion (norm. per larva)",lty=1 )
 lines(density(datDispersion[datDispersion$groupID == 'LL', ]$Dispersion_larval_norm,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$LF$Evoked,main=NA,lty=2 )
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$LF$Spont,colourDataScheme$LF$Evoked),lwd=3 ) 

 plot(density(datDispersion[datDispersion$groupID == 'DE', ]$Dispersion_larval_norm, kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4, ylim=c(0,ylimUp),col=colourDataScheme$DF$Spont,main="DF  ",xlab="Dispersion (norm. per larva)",lty=1 )
 lines(density(datDispersion[datDispersion$groupID == 'DL', ]$Dispersion_larval_norm,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$DF$Evoked,main=NA,lty=2 )
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$DF$Spont,colourDataScheme$DF$Evoked),lwd=3 ) 
```

#### Maximum dispersion per larva
Then examining the maximum larval dispersions, against which we normalize we find :

#### Histograms of max dispersion per larva
```{r,Max-dispersion histogram per larva-Split E-S, fig.show="hold", out.width="33%", echo=FALSE, results='hide' }
##### Maximum Dispersions Per Larva- 
datMaxDispersionPerLarva <- readRDS(file=paste0(strDataExportDir,"/foragingState_max_Dispersion_perLarva_",tsec_timeWindow,"sec.rds") )
nBreaks=20
ylimUp <- 20
# extract Evoked to Spont max disp data
datMaxDispersionPerExp.NF.Spont <- datMaxDispersionPerLarva[datMaxDispersionPerLarva$expID %in% datExpPairs[datExpPairs$groupID.S == 'NE' ,]$expID.S, ]$max_exp_Dispersion
datMaxDispersionPerExp.NF.Evoked <- datMaxDispersionPerLarva[datMaxDispersionPerLarva$expID %in% datExpPairs[datExpPairs$groupID.E == 'NL' ,]$expID.E, ]$max_exp_Dispersion

datMaxDispersionPerExp.LF.Spont <- datMaxDispersionPerLarva[datMaxDispersionPerLarva$expID %in% datExpPairs[datExpPairs$groupID.S == 'LE' ,]$expID.S, ]$max_exp_Dispersion 
datMaxDispersionPerExp.LF.Evoked <- datMaxDispersionPerLarva[datMaxDispersionPerLarva$expID %in% datExpPairs[datExpPairs$groupID.E == 'LL' ,]$expID.E, ]$max_exp_Dispersion

datMaxDispersionPerExp.DF.Spont <- datMaxDispersionPerLarva[datMaxDispersionPerLarva$expID %in% datExpPairs[datExpPairs$groupID.S == 'DE' ,]$expID.S, ]$max_exp_Dispersion
datMaxDispersionPerExp.DF.Evoked <- datMaxDispersionPerLarva[datMaxDispersionPerLarva$expID %in% datExpPairs[datExpPairs$groupID.E == 'DL' ,]$expID.E, ]$max_exp_Dispersion

## Max reported is across NE/NL - so checking either condition would suffice to get the max for each larva
datMaxDispersionPerLarva.LF <- datMaxDispersionPerLarva[datMaxDispersionPerLarva$expID %in% datExpPairs[datExpPairs$groupID.S == 'LE' ,]$expID.S, ]$max_larval_Dispersion
datMaxDispersionPerLarva.NF <- datMaxDispersionPerLarva[datMaxDispersionPerLarva$expID %in% datExpPairs[datExpPairs$groupID.S == 'NE' ,]$expID.S, ]$max_larval_Dispersion
datMaxDispersionPerLarva.DF <- datMaxDispersionPerLarva[datMaxDispersionPerLarva$expID %in% datExpPairs[datExpPairs$groupID.S == 'DE' ,]$expID.S, ]$max_larval_Dispersion 


# plot histograms
hist((datMaxDispersionPerLarva.NF)
     , breaks=nBreaks,main="NF Larvae ", xlab="Max. dispersion  per larva (mm)",xlim=c(0,10),col=colourDataScheme$NF$Evoked,ylim=c(0,ylimUp))

hist((datMaxDispersionPerLarva.LF)
     , breaks=nBreaks,main="LF Larvae ", xlab="Max. dispersion  per larva (mm)",xlim=c(0,10),col=colourDataScheme$LF$Evoked,ylim=c(0,ylimUp))

hist((datMaxDispersionPerLarva.DF),
     breaks=nBreaks,main="DF Larvae ", xlab="Max. dispersion per larva (mm)",xlim=c(0,10),col=colourDataScheme$DF$Evoked,ylim=c(0,ylimUp))

```

#### Compare distribution of max dispersion per larva

```{r,  max-dispersion densities compare groups, fig.show="hold", out.width="50%", echo=FALSE, cache=TRUE }
 ## plot est, Densities Compare Spont to Evoked
 pBW <- 1
 ylimUp <- 0.5
 plot(density(datMaxDispersionPerLarva.NF, kernel="gaussian",na.rm=TRUE, bw=pBW), lwd=4, ylim=c(0,ylimUp), col=colourDataScheme$NF$Evoked,main="Maximum Dispersion Per Larva  ",xlab="Dispersion (mm)",lty=lineTypeL.NF  )
lines(density((datMaxDispersionPerLarva.LF), kernel="gaussian",na.rm=TRUE,bw=pBW), lwd=4, ylim=c(0,ylimUp),col=colourDataScheme$LF$Evoked,main=NA,xlab=NA,lty=lineTypeL.LF )
lines(density((datMaxDispersionPerLarva.DF), kernel="gaussian",na.rm=TRUE,bw=pBW),lwd=4, ylim=c(0,ylimUp),col=colourDataScheme$DF$Evoked,main=NA,xlab=NA,lty=lineTypeL.DF )

legend("topright",c("NF","LF","DF"), lty=c(lineTypeL.NF,lineTypeL.LF,lineTypeL.DF),col=c(colourDataScheme$NF$Evoked,colourDataScheme$LF$Evoked,colourDataScheme$DF$Evoked),lwd=3 ) 
print(pBW)
```

##### Compare max dispersion distributions between conditions 

It appears that the max dispersions do not differ much between spontaneous and evoked conditions for the DF group, 
while there seems to be some evidence that  LF Larvae explore more in the absence of prey and perhaps,suprisingly, NF larvae explore less in the absence of prey.
Maybe these could make sense under an expected reward paradigm, given experience.


```{r,  max-dispersion per larva densities split conditions, fig.show="hold", out.width="33%", echo=FALSE, cache=FALSE }
 ## plot est, Densities Compare Spont to Evoked

 ylimUp <- 0.5
 plot(density(datMaxDispersionPerExp.NF.Spont, kernel="gaussian",na.rm=TRUE, bw=pBW), lwd=4, ylim=c(0,ylimUp), col=colourDataScheme$NF$Spont,main="NF Trajectories  ",xlab="Max Dispersion (mm)",lty=1  )
 lines(density(datMaxDispersionPerExp.NF.Evoked,kernel="gaussian",na.rm=TRUE,bw=pBW),lwd=4,col=colourDataScheme$NF$Evoked,main=NA,lty=2)
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$NF$Spont,colourDataScheme$NF$Evoked),lwd=3 ) 
 
 
 plot(density(datMaxDispersionPerExp.LF.Spont, kernel="gaussian",na.rm=TRUE,bw=pBW), lwd=4, ylim=c(0,ylimUp),col=colourDataScheme$LF$Spont,main="LF  Trajectories",xlab="Max Dispersion (mm)",lty=1 )
 lines(density(datMaxDispersionPerExp.LF.Evoked,kernel="gaussian",na.rm=TRUE,bw=pBW),lwd=4,col=colourDataScheme$LF$Evoked,main=NA,lty=2 )
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$LF$Spont,colourDataScheme$LF$Evoked),lwd=3 ) 

 plot(density(datMaxDispersionPerExp.DF.Spont, kernel="gaussian",na.rm=TRUE,bw=pBW),lwd=4, ylim=c(0,ylimUp),col=colourDataScheme$DF$Spont,main="DF  Trajectories",xlab="max Dispersion (mm)",lty=1 )
 lines(density(datMaxDispersionPerExp.DF.Evoked,kernel="gaussian",na.rm=TRUE,bw=pBW),lwd=4,col=colourDataScheme$DF$Evoked,main=NA,lty=2 )
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$DF$Spont,colourDataScheme$DF$Evoked),lwd=3 ) 
```
# Measure Hunt rate per foraging state

Here I will identify the number of hunt events evoked/initiated in each foraging state.
However, it is natural to expect that since hunt events involve slow prey approach behaviour, which gives low dispersion, a higher hunt-rate is expected in the exploitation state. Yet the time window of foraging state classification is 5 sec, while a hunt episodes last for less than 2 sec (~1sec If i remember correctly, check eLife paper fig).
Thus the foraging state is associated with slow/ prey approach motion, as a high rate of hunt initiation would cause low dispersion.  

A list of all tabulated hunt-outcomes 
```{r, table-all-huntscores}
## Get Number of Hunt Events In Exploit / Expore
table(convertToScoreLabel(datHuntLabelledEventsSBMerged_fixed$huntScore) )
```
can be compared to the subset of hunt-outcomes that are associated with a low normalized dispersion  (<=`r thres_dispersion_class` ) in being in *exploitation* state

```{r, table-Exploration-huntscores}
table(convertToScoreLabel(datHEventDispersion[!is.na(datHEventDispersion$Dispersion_norm) & datHEventDispersion$Dispersion_norm <= thres_dispersion_class,]$huntScore) )
```

and those with larger dispersion indicative of being in the *exploration* foraging state (>`r thres_dispersion_class`)

```{r, table-Exploit-huntscores}
table(convertToScoreLabel(datHEventDispersion[!is.na(datHEventDispersion$Dispersion_norm) & datHEventDispersion$Dispersion_norm > thres_dispersion_class,]$huntScore) )
```

while some hunt-outcomes were not associated with any dispersion measure - missing as trajectory was not long enoughat time of the hunt event

```{r, table-unaccounted-huntscores}
## Check number of Events missing dispersion Info
table(convertToScoreLabel(datHEventDispersion[!is.na(datHEventDispersion$Dispersion_norm),]$huntScore) )
```

Looking at a histrgram of normalized dispersion of all hunt events it is clear that most of these exist over high dispersion, ie not in exploitation but rather in an exploratory phase!

```{r,  hunt-event-all-dispersion histogram Norm, fig.show="hold", out.width="50%", echo=FALSE, cache=TRUE }

hist(datHEventDispersion$Dispersion_norm,main="All group hunt events ",xlab="Dispersion normalized per exp",breaks=100)
hist(datHEventDispersion$Dispersion_larval_norm,main="All group hunt events ",xlab="Dispersion normalized per larva",breaks=100)

```

### Histograms of hunt-ever dispersions split conditions
 
These next histograms show how *normalized larval dispersion* is distributed in each rearing group and looking at whether hunting initiation changes between spontaneous and evoked conditions.

  * It appears as if only the NF hunts during an exploitation type of movement.
  * LF spontaneous hunt-events occur over exploration (higher dispersion) 

```{r,  hunt-event-group-dispersion histogram Norm, fig.show="hold", out.width="50%", echo=FALSE, cache=TRUE }
## Normalized Dispersion In Hunt Events
nBreaks = 30
## Check LF
hist(datHEventDispersion[datHEventDispersion$groupID=='LL', ]$Dispersion_larval_norm,breaks=nBreaks,main="LF Evoked",xlab="Dispersion Norm.",col=colourDataScheme$LF$Evoked)
hist(datHEventDispersion[datHEventDispersion$groupID=='LE', ]$Dispersion_larval_norm,breaks=nBreaks,main="LF Spont",xlab="Dispersion Norm.",col=colourDataScheme$LF$Spont)

## Check NF
hist(datHEventDispersion[datHEventDispersion$groupID=='NL', ]$Dispersion_larval_norm,breaks=nBreaks,main="NF Evoked",xlab="Dispersion Norm.",col=colourDataScheme$NF$Evoked)
hist(datHEventDispersion[datHEventDispersion$groupID=='NE', ]$Dispersion_larval_norm,breaks=nBreaks,main="NF Spont",xlab="Dispersion Norm.",col=colourDataScheme$NF$Spont)

## Check DF
hist(datHEventDispersion[datHEventDispersion$groupID=='DL', ]$Dispersion_larval_norm,breaks=nBreaks,main="DF Evoked",xlab="Dispersion Norm.",col=colourDataScheme$DF$Evoked)
hist(datHEventDispersion[datHEventDispersion$groupID=='DE', ]$Dispersion_larval_norm,breaks=nBreaks,main="DF Spont",xlab="Dispersion Norm.",col=colourDataScheme$NF$Spont)

BW=0.1
```

### Density estimation - compare conditions

Next, I estimated smoothed densities using a gaussian kernel so I can visualy compare  dispersion between spontaneous and evoked conditions (BW=`r  BW`)
These suggest that dispersions shift between spont in and evoked conditions differently between groups:

  * prey *does not change* dispersion  in the naive group NF
  * prey *reduces* dispersion in the experienced group LF
  * prey **increases** dispersion in the experienced group LF

Such distinct pattern between group (specifically difference NF-DF) is consistent with previous findings in Lagogiannis et al 2020.

```{r,  hunt-event-group-dispersion Norm split conditions, fig.show="hold", out.width="33%", echo=FALSE, cache=TRUE }
 ## plot est, Densities Compare Spont to Evoked

 ylimUp <- 5
 plot(density(datHEventDispersion[datHEventDispersion$groupID=='NE', ]$Dispersion_larval_norm, kernel="gaussian",na.rm=TRUE, bw=BW), lwd=4, ylim=c(0,ylimUp), col=colourDataScheme$NF$Spont,main="NF Hunt events  ",xlab="Dispersion (norm per larva)",lty=1  )
 lines(density(datHEventDispersion[datHEventDispersion$groupID=='NL', ]$Dispersion_larval_norm,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$NF$Evoked,main=NA,lty=2)
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$NF$Spont,colourDataScheme$NF$Evoked),lwd=3 ) 
 
 
 plot(density(datHEventDispersion[datHEventDispersion$groupID=='LE', ]$Dispersion_larval_norm, kernel="gaussian",na.rm=TRUE,bw=BW), lwd=4, ylim=c(0,ylimUp),col=colourDataScheme$LF$Spont,main="LF  Hunt events",xlab="Dispersion (norm per larva)",lty=1 )
 lines(density(datHEventDispersion[datHEventDispersion$groupID=='LL', ]$Dispersion_larval_norm,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$LF$Evoked,main=NA,lty=2 )
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$LF$Spont,colourDataScheme$LF$Evoked),lwd=3 ) 

 plot(density(datHEventDispersion[datHEventDispersion$groupID=='DE', ]$Dispersion_larval_norm, kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4, ylim=c(0,ylimUp),col=colourDataScheme$DF$Spont,main="DF  Hunt events",xlab="Dispersion (norm per larva)",lty=1 )
 lines(density(datHEventDispersion[datHEventDispersion$groupID=='DL', ]$Dispersion_larval_norm,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$DF$Evoked,main=NA,lty=2 )
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$DF$Spont,colourDataScheme$DF$Evoked),lwd=3 ) 
```

The distributions look similar even if we remove the normalization stage, and look at raw dispersion measures, the low dispersion associated with exploitation phase is rare among hunt-events

```{r,  hunt-event-dispersion distribution raw split E-S, fig.show="hold", out.width="33%", echo=FALSE, cache=TRUE }
BW = 1
 ylimUp <- 1
 plot(density(datHEventDispersion[datHEventDispersion$groupID=='NE', ]$Dispersion, kernel="gaussian",na.rm=TRUE, bw=BW), lwd=4, ylim=c(0,ylimUp), col=colourDataScheme$NF$Spont,main="NF Hunt events  ",xlab="Dispersion (mm)",lty=1  )
 lines(density(datHEventDispersion[datHEventDispersion$groupID=='NL', ]$Dispersion,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$NF$Evoked,main=NA,lty=2)
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$NF$Spont,colourDataScheme$NF$Evoked),lwd=3 ) 
 
 
 plot(density(datHEventDispersion[datHEventDispersion$groupID=='LE', ]$Dispersion, kernel="gaussian",na.rm=TRUE,bw=BW), lwd=4, ylim=c(0,ylimUp),col=colourDataScheme$LF$Spont,main="LF  Hunt events",xlab="Dispersion (mm)",lty=1 )
 lines(density(datHEventDispersion[datHEventDispersion$groupID=='LL', ]$Dispersion,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$LF$Evoked,main=NA,lty=2 )
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$LF$Spont,colourDataScheme$LF$Evoked),lwd=3 ) 

 plot(density(datHEventDispersion[datHEventDispersion$groupID=='DE', ]$Dispersion, kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4, ylim=c(0,ylimUp),col=colourDataScheme$DF$Spont,main="DF  Hunt events",xlab="Dispersion (mm)",lty=1 )
 lines(density(datHEventDispersion[datHEventDispersion$groupID=='DL', ]$Dispersion,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$DF$Evoked,main=NA,lty=2 )
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$DF$Spont,colourDataScheme$DF$Evoked),lwd=3 ) 

```


## Examine relationship of hunt-outcome to foraging state

### Histograms
Do distributions of dispersion change depending on hunt-outcome ? 
The historgrams below examine how *normalized larval dispersion* distributions shift for each group depending on capture outcome being success/fail

```{r,  hunt-outcome-dispersion histogram norm, fig.show="hold", out.width="50%", echo=FALSE, cache=TRUE }
nBreaks = 30
ylimUp <- 50
## RAW Dispersion In Hunt Events

## Check NF
hist(datHEventDispersion[datHEventDispersion$groupID=='NL' & grepl("Success", as.character(  convertToScoreLabel(datHEventDispersion$huntScore) ) ) , ]$Dispersion_larval_norm,breaks=nBreaks,main="NF Capture Success",xlab="Dispersion ",xlim=c(0,1),col=colourDataScheme$NF$Evoked,ylim=c(0,ylimUp))

hist(datHEventDispersion[datHEventDispersion$groupID=='NL' & grepl("Fail", as.character(  convertToScoreLabel(datHEventDispersion$huntScore) ) ) , ]$Dispersion_larval_norm,breaks=nBreaks,main="NF Capture Failure",xlab="Dispersion ",xlim=c(0,1),col=colourDataScheme$NF$Spont,ylim=c(0,ylimUp))

## Check LF Successs/Fail Only
hist(datHEventDispersion[datHEventDispersion$groupID=='LL' & grepl("Success", as.character(  convertToScoreLabel(datHEventDispersion$huntScore) ) ) , ]$Dispersion_larval_norm,breaks=nBreaks,main="LF Capture Success",xlab="Dispersion ",xlim=c(0,1),col=colourDataScheme$LF$Evoked,ylim=c(0,ylimUp))

hist(datHEventDispersion[datHEventDispersion$groupID=='LL' & grepl("Fail", as.character(  convertToScoreLabel(datHEventDispersion$huntScore) ) ) , ]$Dispersion_larval_norm,breaks=nBreaks,main="LF Capture Failure",xlab="Dispersion ",xlim=c(0,1),col=colourDataScheme$LF$Spont,ylim=c(0,ylimUp))


## Check DF
hist(datHEventDispersion[datHEventDispersion$groupID=='DL' & grepl("Success", as.character(  convertToScoreLabel(datHEventDispersion$huntScore) ) ) , ]$Dispersion_larval_norm,breaks=nBreaks,main="DF Capture Success",xlab="Dispersion ",xlim=c(0,1),col=colourDataScheme$DF$Evoked,ylim=c(0,ylimUp))

hist(datHEventDispersion[datHEventDispersion$groupID=='DL' & grepl("Fail", as.character(  convertToScoreLabel(datHEventDispersion$huntScore) ) ) , ]$Dispersion_larval_norm,breaks=nBreaks,main="DF Capture Failure",xlab="Dispersion ",xlim=c(0,1),col=colourDataScheme$DF$Spont,ylim=c(0,ylimUp))

```

### Dispersion densities per outcome 

To visually compare dispersions between huntcomes I estimated smoothed distributions from the dispersion data split between Success and Failed hunt-outcomes.
Interstingly, I find evidence for pattern of distinct behaviours among groups :
  * NF 
  * LF Likely no difference between success/Failed episodes - contradicts Marquez et 2019 findings
  * DF Lower dispersion (exploitation state) linked to success
  
```{r,  hunt-event-dispersion per outcome distributions, fig.show="hold", out.width="33%", echo=FALSE, cache=TRUE }
BW = 0.08
ylimUp <- 5
 plot(density(datHEventDispersion[datHEventDispersion$groupID=='NL' & grepl("Success", as.character(  convertToScoreLabel(datHEventDispersion$huntScore) ) ) , ]$Dispersion_larval_norm,
              kernel="gaussian",na.rm=TRUE, bw=BW), lwd=4, ylim=c(0,ylimUp), col=colourDataScheme$NF$Spont,main="NF Hunt Events  ",xlab="Dispersion (mm)",lty=1  )
 
 lines(density(datHEventDispersion[datHEventDispersion$groupID=='NL' & grepl("Fail", as.character(  convertToScoreLabel(datHEventDispersion$huntScore) ) ) , ]$Dispersion_larval_norm,
               kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$NF$Evoked,main=NA,lty=2)
legend("topright",c("Success","Fail"), lty=c(1,2),col=c(colourDataScheme$NF$Spont,colourDataScheme$NF$Evoked),lwd=3 ) 
 
 
 plot(density(datHEventDispersion[datHEventDispersion$groupID=='LL' & grepl("Success", as.character(  convertToScoreLabel(datHEventDispersion$huntScore) ) ) , ]$Dispersion_larval_norm, kernel="gaussian",na.rm=TRUE,bw=BW), lwd=4, ylim=c(0,ylimUp),col=colourDataScheme$LF$Spont,main="LF  Hunt Events",xlab="Dispersion (mm)",lty=1 )
 lines(density(datHEventDispersion[datHEventDispersion$groupID=='LL' & grepl("Fail", as.character(  convertToScoreLabel(datHEventDispersion$huntScore) ) ) , ]$Dispersion_larval_norm,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$LF$Evoked,main=NA,lty=2 )
legend("topright",c("Success","Fail"), lty=c(1,2),col=c(colourDataScheme$LF$Spont,colourDataScheme$LF$Evoked),lwd=3 ) 

 plot(density(datHEventDispersion[datHEventDispersion$groupID=='DL' & grepl("Success", as.character(  convertToScoreLabel(datHEventDispersion$huntScore) ) ) , ]$Dispersion_larval_norm, kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4, ylim=c(0,ylimUp),col=colourDataScheme$DF$Spont,main="DF  Hunt Events",xlab="Dispersion (mm)",lty=1 )
 lines(density(datHEventDispersion[datHEventDispersion$groupID=='DL' & grepl("Fail", as.character(  convertToScoreLabel(datHEventDispersion$huntScore) ) ) , ]$Dispersion_larval_norm,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$DF$Evoked,main=NA,lty=2 )
legend("topright",c("Success","Fail"), lty=c(1,2),col=c(colourDataScheme$DF$Spont,colourDataScheme$DF$Evoked),lwd=3 ) 

```

 (BW=`r  BW`)

# Full figure List of trajectories per experiment

The following figures show the tracked trajectories per experiment of each group.
Trajectory segments are colour coded according to whether these can be classified as exploration or exploitation based on ta theshold on the normalized dispersion. This threshold is set here to `r thres_dispersion_class ` .
Red signiifies segments of exploitation, blue is for exploration. 
The column on the right shows the dispersion measurement along recording time. Note the x-axis is not real time, it is the total time of  concatenated recording events. The horizontal line represents where the exploit/explore dispersal threshold sits for each larva, given its normalized disperal measurements.
The triangles at the bottom denote hunt-event initiations in relation to dispersal.

  - Observing dispersals and trajectories it becomes clear that during a 10 min recording a larva could be in exploitation phase all the way, and thus the range of dispersals that this larva can produce is most likely not observed. see : 
   - NL 309/NE 302
    


## Classify based on dispersions normalized on per larval basis 

Note that dispersion is normalized based on the trajectories from Spontaneous and Evoked conditions *combined* for each larva.
Here it should be noted that in Marquez et al 2019 "To facilitate comparison across animals, the dispersal distance was normalized to the range of each animal."
That means this is not a division by the maximum dispersal of each animal, but it also makes use of the minimum.

#### LF - Evoked /Spontaneous Trajectories
```{r,  larva_norm-trajectories-LL, fig.show="hold", out.width="50%", echo=FALSE, results='hide' , cache=TRUE, autodep=TRUE,eval=FALSE,warning=FALSE}

loaddatAllFrames()
loadDispersionData()
plotLarvaNormDispersionTrajectories(c('LL','LE'),datAllFrames, datDispersion ,datHEventDispersion,datExpPairs,  thres_dispersion_class )

```

#### NF - Evoked/Spontaneous Trajectories 
```{r, larva_norm-trajectories-NL, fig.show="hold", out.width="50%", echo=FALSE, results='hide',cache=TRUE, autodep=TRUE,eval=FALSE,warning=FALSE}
plotLarvaNormDispersionTrajectories(c('NL','NE'),datAllFrames, datDispersion ,datHEventDispersion,datExpPairs, thres_dispersion_class )

```
  
#### DF - Evoked/Spontaneous Trajectories 
```{r, larva_norm-trajectories-DL, fig.show="hold", out.width="50%", echo=FALSE, results='hide', cache=TRUE, autodep=TRUE,eval=FALSE,warning=FALSE}

plotLarvaNormDispersionTrajectories(c('DL','DE'),datAllFrames, datDispersion , datHEventDispersion, datExpPairs, thres_dispersion_class)


```


## Classifying exploitation/exploration phases based on **global threshold**
The dispersion of each experiment is normalized globally and thus classification threhsold for exploitation identifies trajectory segments of spatially restricted motion relative to all larvae across groups

### Evoked conditions
Trajectories of 10min recordings in the presence of prey. Note, in contrast to Marquez et al. 2019, our recodings exclude motion at the boundary of petridish.

#### LF - Evoked+Sponτaneous larval trajectories
Eploitation state is shown in *red* and *orange* in evoked and spontaneous test conditions respectivelly, with hunt events shown as squares.
Exploration state is *blue* and *green* in evoked and spontaneous test conditions respectivelly, , with hunt events shown as triangles.

```{r,  global_norm-trajectories-LL, fig.show="hold", out.width="50%", echo=FALSE, results='hide', cache=TRUE, autodep=TRUE,eval=FALSE }
loaddatAllFrames()
loadDispersionData()
plotGlobalNormDispersionTrajectories(c('LL','LE'), datAllFrames, datDispersion, datHEventDispersion, datExpPairs,   thres_dispersion_class )

```

#### NF - Evoked+Spont Trajectories 
```{r, global_norm-trajectories-NL, fig.show="hold", out.width="50%", echo=FALSE, results='hide', cache=TRUE, autodep=TRUE,eval=FALSE}

plotGlobalNormDispersionTrajectories(c('NL','NE'),datAllFrames,datDispersion,datHEventDispersion,datExpPairs, thres_dispersion_class )

```

#### DF - Evoked Trajectories 
```{r, global_norm-trajectories-DL, fig.show="hold", out.width="50%", echo=FALSE, results='hide', cache=TRUE, autodep=TRUE,eval=FALSE}

plotGlobalNormDispersionTrajectories(c('DL','DE'),datAllFrames,datDispersion,datHEventDispersion,datExpPairs, thres_dispersion_class)

```


## Classify based on normalizated experiment trajectory dispersion

Note that Spontaneous and Evoked conditions of each larva are considered individually

#### LF - Evoked /Spontaneous Trajectories
```{r,  exp_norm-trajectories-LL, fig.show="hold", out.width="50%", echo=FALSE, results='hide' , cache=TRUE, autodep=TRUE,eval=FALSE}
loaddatAllFrames()
loadDispersionData()
plotExpNormDispersionTrajectories(c('LL','LE'),datAllFrames,datDispersion ,datHEventDispersion,datExpPairs,  thres_dispersion_class )

```

#### NF - Evoked/Spontaneous Trajectories 
```{r, exp_norm-trajectories-NL, fig.show="hold", out.width="50%", echo=FALSE, results='hide',cache=TRUE, autodep=TRUE,eval=FALSE}

plotExpNormDispersionTrajectories(c('NL','NE'),datAllFrames,datDispersion ,datHEventDispersion,datExpPairs, thres_dispersion_class )


```

#### DF - Evoked/Spontaneous Trajectories 
```{r, exp_norm-trajectories-DL, fig.show="hold", out.width="50%", echo=FALSE, results='hide', cache=TRUE, autodep=TRUE,eval=FALSE}


plotExpNormDispersionTrajectories(c('DL','DE'),datAllFrames,datDispersion ,datHEventDispersion,datExpPairs, thres_dispersion_class)

```

# Clustering dispersal data

## Clustering dispersal using mixture of 2 Gaussians
I made a simple mixture of C=`r Nclust` Gaussians model to cluster the disperal data pooled across larvae. I infer the Gaussian parameters for each group/condition using Bayesian inference and MCMC.  
Parameter inference is done on the Dispersion data of each group/condition separately,  using dispersion data that has been subsampled to  `r G_APPROXFPS/nsubsampleInterval`sec intervals.

#### todo: Fix Math model 
\[
D^G \sim \mathcal{N}(\mu^G,\sigma^G)\\
k_c \sim \mathbb{categorical}(\lambda)\\
d_l \sim \mathcal{N}(\mu_{k[c]},\sigma_{k[c]})
\]
where the $\sum^{K}_{k=1}\lambda_k = 1$.

The model is implemented in RJags and its code is as as follows:
```{r, dispersal-RJags-pooledData model,include=TRUE}
strDispersionClusterModel <- "
model {
    # Likelihood: 
    for( i in 1 : N ) {
      y[i] ~ dnorm( muOfClust[ clust[i] ], tauOfClust[ clust[i] ] )
      #mu[i] <-  ]
      clust[i] ~ dcat( pClust[1:Nclust] )
    }
    
    # Prior:
    for ( clustIdx in 1: Nclust ) {
      muOfClust[clustIdx]  ~ dnorm( 0 , 1.0E-10 )
      tauOfClust[clustIdx] ~ dgamma( 0.01 , 0.01 )
    }
    pClust[1:Nclust] ~ ddirch( onesRepNclust )
}

"
```


```{r, dispersion-clusteringmodel, eval=FALSE, include=FALSE}

library(rjags)
library(runjags)
library('coda')

initfunct <- function(nchains,N)
{
  initlist <- replicate(nchains,list(#mID=c(rbinom(N,1,0.5)), 
#                                     sigma = matrix(c (  c(runif(1,min=0,max=0.1),runif(1,min=0,max=2)),
#s                                                         c(runif(1,min=0,max=0.1),runif(1,min=0,max=15))  ),nrow=2,byrow=T  ),
#                                     mu  = matrix(c (  c( rnorm(1,mean=1,sd=sqrt(1/10) ), rnorm(1,mean=8,sd=sqrt(1/2) ) ),
#                                                        c( rnorm(1,mean=1, sd=sqrt(1/10) ) , rnorm(1,mean=30, sd=sqrt(1/0.1) )    ) )
#                                                     ,nrow=2,byrow = T  ),
                                     ".RNG.name"="base::Super-Duper",
                                     ".RNG.seed"=round(runif(1,0,60000)) ),
                                     simplify=FALSE)
  return(initlist)
}

#nsubsample <- 10000 
##Subsample The Dispersion Data into 0.5 sec bins
loadDispersionData()
datSubDispersion  <- datDispersion[ !is.na(datDispersion$Dispersion), ]
datSubDispersion <- datSubDispersion[seq(1,NROW(datSubDispersion),by=nsubsampleInterval ),]

vDispersion.NF.E <- datSubDispersion[datSubDispersion$groupID == 'NL',"Dispersion",]
vDispersion.LF.E <- datSubDispersion[datSubDispersion$groupID == 'LL',"Dispersion",] 
#vDispersion.NF.E <- sample(datSubDispersion[datSubDispersion$groupID == 'NL',"Dispersion",] ,min(nsubsample,NROW(datSubDispersion[datSubDispersion$groupID == 'NL',]) )  )
vDispersion.DF.E <- datSubDispersion[datSubDispersion$groupID == 'DL',"Dispersion",]

vDispersion.NF.S <- datSubDispersion[datSubDispersion$groupID == 'NE',"Dispersion",]  
vDispersion.LF.S <- datSubDispersion[datSubDispersion$groupID == 'LE',"Dispersion",]
vDispersion.DF.S <- datSubDispersion[datSubDispersion$groupID == 'DE',"Dispersion",]


runClusterModel <- function(vDispersion)
{
  ##Cluster Membership
  N = NROW(vDispersion)
  Nclust <- 2
  clust = rep(NA,N) 
  clust[which.min(vDispersion)]=1 # smallest value assigned to cluster 1
  clust[which.max(vDispersion)]=2 # highest value assigned to cluster 2 
  
  dataList = list(
      y = vDispersion ,
      N = N,
      Nclust = 2 ,
      clust = clust ,
      onesRepNclust = rep(1,Nclust)
  )
  
  
  ##
  ##
  steps <-500
  nchains <- 3
  nthin <- 10
  #str_vars <- c("mu","rho","sigma","x_rand") #Basic model 
  str_vars <- c("clust","pClust","muOfClust","tauOfClust") #Mixture Model
  
  # Run the 2 chains in parallel (allowing the run.jags function
  # to control the number of parallel chains). We also use a
  # mutate function to convert the precision to standard deviation:
  results <- run.jags(model=strDispersionClusterModel, n.chains=nchains,
                         inits=initfunct(nchains,dataList$N),
                         thin=nthin,
                         sample=steps,
                         data= dataList,
                         monitor=str_vars,
                         method="parallel", mutate=list("prec2sd", vars="tauOfClust"))
 return(results) 
}


results.NF.E <- runClusterModel(vDispersion.NF.E)
write.jagsfile(results.NF.E, file=paste0(strDataExportDir,'jagsModel_clustDispersion_NL.txt') )
save(list=c("results.NF.E","vDispersion.NF.E"),file=paste0(strDataExportDir,'jagsModelResults_clustDispersion_NL.RData') )

results.LF.E <- runClusterModel(vDispersion.LF.E)
write.jagsfile(results.LF.E, file=paste0(strDataExportDir,'jagsModel_clustDispersion_LL.txt') )
save(list=c("results.LF.E","vDispersion.LF.E"),file=paste0(strDataExportDir,'jagsModelResults_clustDispersion_LL.RData') )

results.DF.E <- runClusterModel(vDispersion.DF.E)
write.jagsfile(results.DF.E, file=paste0(strDataExportDir,'jagsModel_clustDispersion_DL.txt') )
save(list=c("results.DF.E","vDispersion.DF.E"),file=paste0(strDataExportDir,'jagsModelResults_clustDispersion_DL.RData') )

## Spont
results.NF.S <- runClusterModel(vDispersion.NF.S)
write.jagsfile(results.NF.S, file=paste0(strDataExportDir,'jagsModel_clustDispersion_NE.txt') )
save(list=c("results.NF.S","vDispersion.NF.S"),file=paste0(strDataExportDir,'jagsModelResults_clustDispersion_NE.RData') )

results.LF.S <- runClusterModel(vDispersion.LF.S)
write.jagsfile(results.LF.S, file=paste0(strDataExportDir,'jagsModel_clustDispersion_LE.txt') )
save(list=c("results.LF.S","vDispersion.LF.S"),file=paste0(strDataExportDir,'jagsModelResults_clustDispersion_LE.RData') )

results.DF.S <- runClusterModel(vDispersion.DF.S)
write.jagsfile(results.DF.S, file=paste0(strDataExportDir,'jagsModel_clustDispersion_DE.txt') )
save(list=c("results.DF.S","vDispersion.DF.S"),file=paste0(strDataExportDir,'jagsModelResults_clustDispersion_DE.RData') )


# # And re-run the simulation from this point:
# results.NF.E <- run.jags(paste0(strDataExportDir,'jagsModel_clustDispersion_NL.txt'),sample=10)
# save(list=c("results.NF.E","vDispersion.NF.E"),file=paste0(strDataExportDir,'jagsModelResults_clustDispersion_NL.RData') )
# results.NF.S <- run.jags(paste0(strDataExportDir,'jagsModel_clustDispersion_NE.txt'),sample=100)
# save(list=c("results.NF.S","vDispersion.NF.S"),file=paste0(strDataExportDir,'jagsModelResults_clustDispersion_NE.RData') )
# results.LF.E <- run.jags(paste0(strDataExportDir,'jagsModel_clustDispersion_LL.txt'),sample=100)
# save(list=c("results.LF.E","vDispersion.LF.E"),file=paste0(strDataExportDir,'jagsModelResults_clustDispersion_LL.RData') )
# results.LF.S <- run.jags(paste0(strDataExportDir,'jagsModel_clustDispersion_LE.txt'),sample=100)
# save(list=c("results.LF.S","vDispersion.LF.S"),file=paste0(strDataExportDir,'jagsModelResults_clustDispersion_LE.RData') )
# 
# results.DF.S <- run.jags(paste0(strDataExportDir,'jagsModel_clustDispersion_DE.txt'),sample=100)
# save(list=c("results.DF.S","vDispersion.DF.S"),file=paste0(strDataExportDir,'jagsModelResults_clustDispersion_DE.RData') )
# results.DF.E <- run.jags(paste0(strDataExportDir,'jagsModel_clustDispersion_DL.txt'),sample=100)
# save(list=c("results.DF.E","vDispersion.DF.E"),file=paste0(strDataExportDir,'jagsModelResults_clustDispersion_DL.RData') )

##Convergence Check
muclustNF <- as.mcmc.list(results.NF.S, vars="muOfClust")
plot(muclustNF)

# View the results using the standard print method:
#summary(results.LF.E)
# Write the current model representation to file:
#saveRDS(datSubDispersion,file=paste0(strDataExportDir,'jagsModelDispersionData.rds') )
# And re-run the simulation from this point:
#newresults <- run.jags('mymod.txt')
# Look at some plots of the intercept and slope on a 3x3 grid:
#plot(results.LF.E, c('trace','histogram','ecdf','crosscorr','key'),
#vars=c("muOfClust","tau","pClust"),layout=c(3,3))
### Alternativelly use std rjags Running
# jags_model_LF <- jags.model(textConnection(strDispersionClusterModel), data = dataList_LF, 
#                             n.adapt = 100, n.chains = nchains, quiet = F) #inits=initfunct(nchains,ldata_LF$N)
# update(jags_model_LF, 300)
# draw_LF=jags.samples(jags_model_LF,steps,thin=nthin,variable.names=str_vars)


```

and the clustering results  of each group/condition are summarized in the following figures:

```{r, dispersion-clustering-results,fig.show='hide', out.width="33%", eval=TRUE, include=FALSE,cache=FALSE,dev='png'}

library(rjags)
library(runjags)
library('coda')
loadDispersionData()

## Extracts the monitor values and returns them packaged in a list
getMCMCEstimatedParams <- function(results,groupID,ichain = 2)
{
  clustcoeff = as.mcmc.list(results, vars="clust")
  
  lret <- list(
  chain =  ichain,
  groupID = groupID,
  muOfClustcoeff = as.mcmc.list(results, vars="muOfClust"),
  tauOfClustcoeff = as.mcmc.list(results, vars="tauOfClust"),
  pClustcoeff = as.mcmc.list(results, vars="pClust"),
  clustID = round(colMeans(clustcoeff[[ichain]]) ) 
  )
  
  return (lret)
}
plotClusterProb <- function(lmcmcRes,clustCol)
{
   ##plot prob of occupying each cluster
  breaksProb <- seq(0,1,by=0.01)
  list_histo <- hist(lmcmcRes$pClustcoeff[[lmcmcRes$chain]],breaks=breaksProb,main=groupID,freq = TRUE,xlab = "Prob. of cluster membership (pClust)")
  hist( lmcmcRes$pClustcoeff[[lmcmcRes$chain]][,1],xlim=c(0,1),ylim=c(0,max(list_histo$counts)),
        breaks=breaksProb,col=clustCol[1]
        ,xlab = NA, add=TRUE)
  hist( lmcmcRes$pClustcoeff[[lmcmcRes$chain]][,2],xlim=c(0,1), breaks=breaksProb,col=clustCol[2],main=groupID,add=TRUE )
}
# Colour Coded Histogram of Dispersion Data Showing plit between Exploit[1] / Explore[2]
plotClusteredDispersionHist <- function(lmcmcRes,vDispersion,clustCol)
{
    ## Plot Clustered  Histogram 
  breaksSlots <-  seq(0,10,by=0.5)
  h0 <- hist(vDispersion, breaks=breaksSlots, freq=TRUE,plot=FALSE)
  h1 <- hist(vDispersion[lmcmcRes$clustID == 1],xlim=c(0,10),ylim=c(0,max(h0$counts)), breaks=breaksSlots,col=clustCol[1],plot=FALSE)
  h2 <- hist(vDispersion[lmcmcRes$clustID == 2],xlim=c(0,10), breaks=breaksSlots,col=clustCol[2],main=groupID,xlab = NA,plot=FALSE)  
  
  barplot(rbind(h0$counts,h1$counts,h2$counts),beside = TRUE, col = c("white",clustCol),names.arg = (h1$breaks[-length(h1$breaks)]),main=paste("Clustered densities", lmcmcRes$groupID ),xlab = "Dispersion (mm)")
  
}
## Plot Estimated Mean of each Gaussian
plotClusterMeans <- function(lmcmcRes,clustCol)
{
  
  #hist( mucoeff[[3]],xlim=c(0,10), breaks=20,col=colourDataScheme[[groupID]],main=groupID,xlab = "Sample Means (mm)" )  
  tauClustAllChain <- as.data.frame(lmcmcRes$tauOfClustcoeff[[lmcmcRes$chain]])#rbind( as.data.frame(tauOfClustcoeff[[3]]),as.data.frame(tauOfClustcoeff[[2]]),as.data.frame(tauOfClustcoeff[[1]]))
  muClustAllChain <- as.data.frame(lmcmcRes$muOfClustcoeff[[lmcmcRes$chain]])#rbind( as.data.frame(muOfClustcoeff[[3]]),as.data.frame(muOfClustcoeff[[2]]),as.data.frame(muOfClustcoeff[[1]]) )
  
  ## Plot Estimated Mean of each Gaussian
  plot(density(muClustAllChain$`muOfClust[1]`),xlim=c(0,10),col=clustCol[1],lwd=3,lty=1,main=paste("Cluster means", lmcmcRes$groupID ),xlab = "Estimated means of each cluster (mu)")
  lines(density(muClustAllChain$`muOfClust[2]`),xlim=c(0,10),col=clustCol[2],lwd=3,lty=2)

}

# Plot Clustering Dispersion Results #
# Colour coded Histogram, Prob of cluster membership, mean dispersion per Gaussian cluster 
plotClusterModel <- function(results,vDispersion, groupID)
{
  
  lmcmcRes <- getMCMCEstimatedParams(results,groupID,2)
  muClustAllChain <- as.data.frame(lmcmcRes$muOfClustcoeff[[lmcmcRes$chain]])#rbind(
  clustCol <-c(colourClusters[1],colourClusters[2])
  if ( mean(muClustAllChain$`muOfClust[1]`) > mean(muClustAllChain$`muOfClust[2]`) )
    clustCol <- rev(clustCol)

  plotClusteredDispersionHist(lmcmcRes,vDispersion,clustCol)
  ## Plot Estimated Mean of each Gaussian
  plotClusterMeans(lmcmcRes,clustCol)
  #plot(density(muClustAllChain$`muOfClust[1]`),xlim=c(0,10),col=clustCol[1],lwd=3,lty=1,main=paste("Cluster means", groupID ),xlab = "Estimated means of each cluster (mu)")
  #lines(density(muClustAllChain$`muOfClust[2]`),xlim=c(0,10),col=clustCol[2],lwd=3,lty=2)
  plotClusterMeans(lmcmcRes,clustCol)
  ##plot prob of occupying each cluster
  breaksProb <- seq(0,1,by=0.01)
  list_histo <- hist(lmcmcRes$pClustcoeff[[lmcmcRes$chain]],breaks=breaksProb,main=groupID,freq = TRUE)
  hist( lmcmcRes$pClustcoeff[[lmcmcRes$chain]][,1],xlim=c(0,1),ylim=c(0,max(list_histo$counts)), breaks=breaksProb,col=clustCol[1],xlab = "Prob. of cluster membership (pClust)" ,add=TRUE)
  hist( lmcmcRes$pClustcoeff[[lmcmcRes$chain]][,2],xlim=c(0,1), breaks=breaksProb,col=clustCol[2],main=groupID,add=TRUE )
}
## Load Clustering Results
if (!exists("results.NF.E"))
   load(file=paste0(strDataExportDir,'jagsModelResults_clustDispersion_NL.RData') )
if (!exists("results.NF.S"))
   load(file=paste0(strDataExportDir,'jagsModelResults_clustDispersion_NE.RData') )
if (!exists("results.LF.E"))
   load(file=paste0(strDataExportDir,'jagsModelResults_clustDispersion_LL.RData') )
if (!exists("results.LF.S"))
   load(file=paste0(strDataExportDir,'jagsModelResults_clustDispersion_LE.RData') )
if (!exists("results.DF.E"))
   load(file=paste0(strDataExportDir,'jagsModelResults_clustDispersion_DL.RData') )
if (!exists("results.DF.S"))
   load(file=paste0(strDataExportDir,'jagsModelResults_clustDispersion_DE.RData') )

##plot Cluster Dists

## Evoked


#results <- results.NF.E
#vDispersion <- vDispersion.NF.S
#groupID <- "NL"

```
#### Cluster Dispersal Not-Fed group
```{r ,plot-clustering-results-NF,fig.show='hold', out.width="33%",dev='png'}
plotClusterModel(results.NF.E,vDispersion.NF.E,"NL")
plotClusterModel(results.NF.S,vDispersion.NF.S,"NE")
```
#### Cluster Dispersal Life-Fed group
```{r,plot-clustering-results-LF,fig.show='hold', out.width="33%",dev='png'}
plotClusterModel(results.LF.E,vDispersion.LF.E,"LL")
plotClusterModel(results.LF.S,vDispersion.LF.S,"LE")
```

#### Cluster Dispersal Dry-Fed group
```{r ,plot-clustering-results-DF,fig.show='hold', out.width="33%",dev='png'}
plotClusterModel(results.DF.E,vDispersion.DF.E,"DL")
plotClusterModel(results.DF.S,vDispersion.DF.S,"DE")
```


<!--![Clustered Dispersion DF Evoked ](`r ## knitr::fig_chunk('plot-clustering-results-DF', 'png')`)-->
<!--![Clustered Dispersion DF Spontaneous ](`r ## knitr::fig_chunk('plot-clustering-results-DF', 'png')`)-->

<!--- ![LF Evoked](`r #knitr::fig_chunk('dispersion-clustering-results', 'png',4:6)`)-->
## Clustering Using an Negative-Binomial Mixture
```{r, dispersal-RJags-pooledData model,include=TRUE}
strDispersionNBClusterModel <- "
model {
    # Likelihood: 
    for( i in 1 : N ) {
      y[i] ~ dnegbin(q[clust[i] ],r[ clust[i] ]) # Model Number Of Dispersal expansion steps within a recent trajectory timewindow (5 sec)
      
      clust[i] ~ dcat( pClust[1:Nclust] )
    }
    
    # Prior:
    for ( clustIdx in 1: Nclust ) {
      q[clustIdx]  ~ dunif(0.0,1)
      r[clustIdx] ~ dgamma(1,1)
    }
    pClust[1:Nclust] ~ ddirch( onesRepNclust )
}

"
```
n[j] ~  dnegbin(q,r) ##Model Number Of Hunt Events Per Larvae

## Clustering using a hierarchical group model of larval dispersion data

We construct a hierarchical statistical model to describe the mean group dispersal behaviours in spontaneous and evoked conditions, based on the estimated behaviour of $i=60$ larva from each group $G$.

```{r, dispersal-RJags-Group-model,include=TRUE}
strDispersionGroupClusterModel <- "
model {
    # Likelihood: 
    for( i in 1 : N ) {
      y[i] ~ dnorm( muOfClust[ clust[i] ], tauOfClust[ clust[i] ] )
      #mu[i] <-  ]
      clust[i] ~ dcat( pClust[1:Nclust] )
    }
    
    # Group Prior:
    for ( clustIdx in 1: Nclust ) {
      muOfClustG[clustIdx]  ~ dnorm( 0 , 1.0E-10 )
      tauOfClustG[clustIdx] ~ dgamma( 0.01 , 0.01 )
    }
    pClustG[1:Nclust] ~ ddirch( onesRepNclust )
    
    # Larval Priors
    for ( l in 1: NLarv ) {
      for ( clustIdx in 1: Nclust ) {
        muOfClustG[clustIdx]  ~ dnorm( 0 , 1.0E-10 )
        tauOfClustG[clustIdx] ~ dgamma( 0.01 , 0.01 )
      }
    }
    pClustG[1:Nclust] ~ ddirch( onesRepNclust )
    
    
}

## TODO: Expand to Group Prior ##
"
```


## Dispersion as random process

Here I investigate on a different formulation of a stochastic dispersal data generating process. 
To study the statistical properties of dispersal and compare them between groups we model disperal data as a markov chain.
A simple description of such a process is 
\[
D_n = D_{n-1} + p z_n
\]
where $z_n ~ \mathcal{N}(\mu,\sigma)$.
The parameters of which can be inferred from the data of each larval dispersal measurements.
We assume that motion bouts are generated at regular intervals $t\in\{1...n\}$ and each bout motion may either increase the dispersal, measured as the circle encompassing a 5 sec ($k-step$) trajectory, or leave it the same. As as such  disperal lengths are dependent on the sum of a sequence of $k$ bernoulli trials, with $p$ being the probability that dispersion increases by a step size drawn from another distribution (assume Normal), and $q=1-p$ being the probability that the dispersal remains the same - either because a bout did not occur or because bout moved inwards.
In such a model we will need **to ignore any correlations between step outcomes**, as sequence of step that move inwards the dispersion circle, are less likely to lead to an increase in the next step, as the larva may have moved away from the current dispresion boundary. 
These  width of these correlations is increased with dispersion length (ie with the history of prior expansion successes.) 
Thus if we consider the dispersal length to be a sum of Gaussian random variables, then the resulting distribution should be Gaussian (or mixture of, if there is more than one $p$).

Alternativelly, assuming $k$-steps makes each dispersal count, we observe that a certain dispersal length is made up of a sequence of expansion events $e$, where the larva hits the dispersal measuring circle boundary, leaving the rest to of the $n=k-e$ steps to be expansion failures. 
If we assume that each expansion event increases dispersion by some fixed size $d$, then the *Negative binomial (NB)*  could be applicable here to model the distribution of dispersal lengths. The NB is a discrete probability distribution that models the number of failures in a sequence of independent and identically distributed Bernoulli trials before a specified (non-random) number of successes (denoted $r$) occurs.
This model  *generally is appropriate where events have positively correlated* occurrences causing a larger variance than if the occurrences were independent, due to a positive covariance term. Here we may model we may model $r$ as being the number of times dispersion did not change, while failures is bout that increases dispersal occurs.

In any case, looking at the distributions above it appears that, at least for LF, there appears to be at least two step-generating distributions $z_n$, which are required to describe the group's dispersal data. Further, it is also evident that the parameters of these distributions change between spontaneous and evoked conditions, at least in the LF group.
By modelling the data and inferring parameters using Bayesian inference we statistically compare changes in dispersal behaviour between groups and conditions.

Assume that each larva generates a different number of observations, given the difference in the time they are in view. We aim to model the statistics of dispersion of each larva separatelly and then aggregate into a model of the whole group. Difference in the number of observations should be reflected in the uncertainty of parameter estimates.  

However,given the nature of my data this can be problematic. Dispersion records are not continuous monitoring of behaviour, as there may be gaps between events. 
The 1st 5sec at the beginning of each larval record is filled with NA values, and thus we may exclude it.
Alternativelly we may directly model the distribution of $D_n$, rather model the step-generating process $z_n$.
We begin with this more direct approach to model the distribution of Dispersal data for each larva, assuming these can be clustered using a mixture of $c=2$ Normal distributions for each test condition, such that evoked and spontaneous conditions are modelled separatelly. The separate distributions can be seen as a model of the hidden foraging state of the animal, which emit different motion patterns, and thus modify dispersal differently.

This approach could be complemented by active inference / SPM model

### Model implementantion in Stan

To implement the normal mixture model outlined in the previous section in Stan, the discrete parameters can be summed out of the model.
If Y is a mixture of K normal distributions with locations μk and scales σk with mixing proportions λ in the unit K-simplex, then 
\[p_Y\left(y \mid \lambda, \mu, \sigma \right) = \sum_{k=1}^K \lambda_k \, \textsf{normal}\left(y \mid \mu_k, \sigma_k\right).\]
I will defer using Stan for this and go for my familiar Jags model implementation.




```{r spare-code-notes,eval=FALSE, include=FALSE}
## Retrieve Dispersion of each Hunt Event
start.time <- Sys.time()
i <- 0
for (i in 1:NROW(datHuntLabelledEventsSBMerged_fixed) )
{

   datHEvent_disp <- datDispersion[datDispersion$expID == datHuntLabelledEventsSBMerged_fixed[i,]$expID &
                              datDispersion$eventID == datHuntLabelledEventsSBMerged_fixed[i,]$eventID &
                              datDispersion$frameN == datHuntLabelledEventsSBMerged_fixed[i,]$startFrame ,] #
   #message(datHEvent_disp$expID)

   if (NROW(datHEvent_disp) == 0 )
   {
     warning("Tracking dispersion data not found for huntevent ",i, "at startframe ",datHuntLabelledEventsSBMerged_fixed[i,]$startFrame )
     ##Try Again without the start frame - Slower
     datHEvent_disp <- datDispersion[datDispersion$expID == datHuntLabelledEventsSBMerged_fixed[i,]$expID &
                              datDispersion$eventID == datHuntLabelledEventsSBMerged_fixed[i,]$eventID  ,] #
   }

   if (NROW(datHEvent_disp) == 0 )
     warning("Attaching dispersion data for huntevent ",i, " Failed")

   # Check if Rec Exists
   if (NROW(datHEvent_disp) == 1 )
   {

     vHuntEventDispersion[i] <- datHEvent_disp$Dispersion
     vHuntEventDispersion_norm[i] <-  datHEvent_disp$Dispersion_norm
     message(i," Disp:",vHuntEventDispersion[i])

   }else {

     ## Multiple rows returned
     ## FInd Tracking (Dispersion dat) frame that is closest to hunt-event initiation (start frame)
     idx <- NA
     with(datHuntLabelledEventsSBMerged_fixed[i,],
          {
                idx <- which(abs(datHEvent_disp$frameN - startFrame) == min(abs(datHEvent_disp$frameN - startFrame) ) )

                vHuntEventDispersion_norm[i] <- datHEvent_disp[idx,"Dispersion_norm"]
                vHuntEventDispersion[i] <- datHEvent_disp[idx,"Dispersion"]
               ##This Maybe NA since there are no Dispersion Data In some Occassions
               ##stopifnot(!is.na(vHuntEventDispersion[i]))
               message("Found idx ",idx, " Disp ",vHuntEventDispersion[i])
          })

   }

    #Find Dispersion At start Frame of Hunt Event
    #
    print(i)


    #stopifnot(i <11)
}

   end.time <- Sys.time()
   time.taken <- end.time - start.time
   print(time.taken)

 
```



