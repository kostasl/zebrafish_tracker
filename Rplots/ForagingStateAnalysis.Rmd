---
title: 'Notebook: Identifying the role of experience on foraging and exploration movement patterns'
output:
  html_document:
    df_print: paged
    params: 
    output_dir: "/media/kostasl/D445GB_ext4/kostasl/Dropbox/Calculations/zebrafishtrackerData/foragingAnalysis"

  html_notebook: default
  pdf_document: default
  bibliography: ForagingStateAnalysis.bib
---


This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook, analysing zebrafish tracking data 
for foraging state as indicated by Marquez et al 2019. I aim to extend my previous work on the experience driven ontogeny of hunting skill [now published in eLife](https://elifesciences.org/articles/55119/figures) 
Zebrafish appear to spontaneously switch between an exploratory and exploitation phase that grossly defines their behavioural mode. 
The state can be read out be measuring trajectory dispersal over a fixed period of time (5 sec), 
According to Marquez et al  2020 Measures of dispersal should appear bimodal, with short dispersals indicating exploitation phase.

Given our behavioural recordings are not continuous, and exclude periods when the larva are swimming around the boundary, it is not certain whether we would be able to detect exploratory phases. These tend to be circling around the border of the petri-dish, as the fish attempts to swim forward. Nevertheless as we are interested in the mode-state under which hunt-events are executed, then we expect that some of these events should be executed during exploratory behaviour and this should be detectable - (dispersal, movement rates etc).
In essense the internal state and the its neural correlates as reported by Marquez et al 2019 can combined with my results on the learned aspects of efficient hunting to study if this foraging state swithcing is also influenced by experience and  whether differences in hunting kinematics correlate with internal state.

  Hypothesis being tested :
  - Does experience modify the dispersal  and so the exploit/explore state of each group?
  - Are foraging intervals modified based on priors built by experience and can these be modelled based on active inference ?(co-op with Rosalyn & Berk)
  - Could expansion of foraging interval explain the higher evoked hunt-rate of the LF group?
  - Does the execution of the kinematic adaptations of capture efficiency, found in the experience larvae,  depend on foraging state ?
  
Establishing a correlation of hunting state with the kinematics of efficient hunting can point us to the underlying circuits, because the circuits that correlate with foraging state, but also with capture-success,  have already been examined by Marquez et al 2019. So it would be posssible to use those to guide our search for the circuits that bring about the kinematics adaptations of success. 

In a new twist of this work *I discover structure in the larval trajectories that indicates a random search process*. 
Indeed although at the microscale larval do not move randomly, but have a rythm, it may well be the case (E.Raposo et al. 2009 ):
>Therefore, the foraging dynamics that defines the final outcomes of biological encounters becomes in essence a stochastic process (e.g. searches in landscapes
with low density of food sites).

### Identify state using dispersal
5s window measure radius encompassing trajectory

```{r setup, message=FALSE, cache=FALSE, results='hide', echo=FALSE,warning=FALSE}
## Init  Code 
library(rjags)
library(runjags)
library('coda')
message("Jags version: ",jags.version())
message(" For info in runjags check out:doi: 10.18637/jss.v071.i09")

setwd("/home/kostasl/workspace/zebrafishtrack/Rplots")
#setwd(here())
source("config_lib.R")
source("TrajectoryAnalysis.r")

setEnvFileLocations("HOME") #HOME,OFFICE,#LAPTOP
## To compile to different destination run:
# rmarkdown::render("ForagingStateAnalysis.Rmd",output_dir = paste0(strDataExportDir,'../foragingAnalysis') )


tsec_timeWindow <- 5 
thres_dispersion_class <- 0.2
##Clustering
Nclust <- 2
nsubsampleInterval <- G_APPROXFPS/2

## Load datAllFrames
loaddatAllFrames <- function(forceReload = FALSE)
{
  if (!exists("datAllFrames") | forceReload)
  {
    attach(paste(strDatDir,"datAllFramesFix1_Ds-5-19.RData",sep="/"))
    attach(paste(strDatDir,"groupsrcdatListPerDataSet_Ds-5-19.RData",sep="/"))
  }
}


#Original Dispersion Record per frame
#datDispersion = readRDS(file=paste0(strDataExportDir,"/foragingState_Dispersion",tsec_timeWindow,"sec.rds") )
## Extended Dispersion Merged With maxDispersion Data
#rm("datDispersion")
loadDispersionData <- function(forceReload = FALSE)
{
  try(
    ##Check If Already Loaded
    if (!exists("datDispersion") | forceReload)
      datDispersion <<- readRDS(file=paste0(strDataExportDir,"/foragingState_Dispersion",tsec_timeWindow,"sec.rds") ) 
  )
  
  if (!exists("datDispersion"))
  {
    message("Calculate Trajectory Dispersions")
    loaddatAllFrames()
    datDispersion <- calcTrajectoryDispersions(datAllFrames)
  }
  AllRange <<- range(datDispersion$Dispersion,na.rm=TRUE)
}


```

```{r merge max larval-dispersion onto dispersion data events, echo=FALSE,cache=FALSE,results=FALSE}
## Attaches the max Dispersion found between both evoked and spontaneous trajectories of each larva
## This is used so we can combine S/E larval recordings to detect both exploration/ exploitation state - and normalize appropriatelly to the joined trajectrories between tests as if they were ## one 20min recording  
mergeRangeOfLarvalDispersionPerLarvaOntoDispersion <- function(datDispersion,datExpPairs)
{
    ## Merge Max Dispersion per larva Onto Dispersion data (so we can normalize on a per larva basis instead of experiment basis)
  ## Calc Normalization to Max Dispersion by combining both Spont And Exoked cond per larva
  ## Find Max Dispersion Per Experiement
  datDispersionMax <- data.frame(tapply(datDispersion$Dispersion,datDispersion$expID,max,na.rm = TRUE))
  datDispersionMin <- data.frame(tapply(datDispersion$Dispersion,datDispersion$expID,min,na.rm = TRUE))
  
  ## pair each experiemnt with its max dispersion between Spontaneous and Evoked conditions of a larva
  ## We use this struct to merge with Dispersion data of each frame / So as to normalize approprietelly
  datDispesionRange_Pairs <-  rbind.data.frame(
                                           cbind.data.frame(
                                             expID = as.character(datExpPairs$expID.S) ,
                                             groupID = as.character(datExpPairs$groupID.S),
                                              max_exp_Disp = datDispersionMax[as.character(datExpPairs$expID.S),],
                                              max_exp_Disp.C = datDispersionMax[as.character(datExpPairs$expID.E),],
                                              min_exp_Disp = datDispersionMin[as.character(datExpPairs$expID.S),],
                                              min_exp_Disp.C = datDispersionMin[as.character(datExpPairs$expID.E),]),
                                           cbind.data.frame(
                                                expID = as.character(datExpPairs$expID.E) ,
                                                groupID = as.character(datExpPairs$groupID.E),
                                                max_exp_Disp = datDispersionMax[as.character(datExpPairs$expID.E),],
                                                max_exp_Disp.C = datDispersionMax[as.character(datExpPairs$expID.S),],
                                                min_exp_Disp = datDispersionMin[as.character(datExpPairs$expID.E),],
                                                min_exp_Disp.C = datDispersionMin[as.character(datExpPairs$expID.S),])
                                            )
                                      
                                          
  ## Add col for Max/min Dispersion across Spont and Evoked conditions
  datDispesionRange_Pairs$max <- as.numeric(apply(datDispesionRange_Pairs[,3:4], 1, max,na.rm=TRUE)) 
  datDispesionRange_Pairs$min <- as.numeric(apply(datDispesionRange_Pairs[,5:6], 1, min,na.rm=TRUE)) 
  
  ##Make Simple frame for merging with dispersion data
  datMaxDispersionPerLarva <- cbind.data.frame(expID=as.character(datDispesionRange_Pairs$expID),
                                               groupID=as.character(datDispesionRange_Pairs$groupID),
                                               max_larval_Dispersion=(datDispesionRange_Pairs$max),
                                               min_larval_Dispersion=(datDispesionRange_Pairs$min),
                                               max_exp_Dispersion=(datDispesionRange_Pairs$max_exp_Disp), # Add The max Disp Recorded for this larva
                                               min_exp_Dispersion=(datDispesionRange_Pairs$min_exp_Disp) # Add The max Disp Recorded for this larva
                                               )
  datDispersionM <- merge(datDispersion,datMaxDispersionPerLarva,all.x = TRUE,by=c("expID","groupID"),no.dups=FALSE)

  #Calculate Range Normalized dispersion per larva - to match Marquez et al 2019
  ## Save  dispersion data normalized across Spont and evoked condition for each larva (saves time in future plotting)
  datDispersionM <- cbind.data.frame(datDispersionM,
                                     Dispersion_larval_norm=(datDispersionM$Dispersion-datDispersionM$min_larval_Dispersion) / (datDispersionM$max_larval_Dispersion-datDispersionM$min_larval_Dispersion) )

  ## Now Merge onto Dispersion Data 
  saveRDS(datDispersionM,file=paste0(strDataExportDir,"/foragingState_Dispersion_merged_rangeperLarva_",tsec_timeWindow,"sec.rds") )
  saveRDS(datMaxDispersionPerLarva,file=paste0(strDataExportDir,"/foragingState_max_Dispersion_perLarva_",tsec_timeWindow,"sec.rds") )
  message("Saved to:",paste0(strDataExportDir,"/foragingState_Dispersion_merged_rangeperLarva_",tsec_timeWindow,"sec.rds") )
  message("Saved to:",paste0(strDataExportDir,"/foragingState_max_Dispersion_perLarva_",tsec_timeWindow,"sec.rds") )

  return(datDispersionM)
}
```

```{r combine-dispersion-with-hunt events, echo=FALSE,cache=TRUE,results=FALSE}

### Combines information across Detected HuntEvents and their outcome, the dispersion of the larval trajectory during which these were
## initiated  ,and the position at which the hunt-event was initiated
mergeDispersionOntoHuntEvents <- function(datDispersion, datAllFrames, datHuntLabelledEventsSBMerged_fixed)
{
  message(paste(" Loading Hunt Event List to Analyse... "))

  start.time <- Sys.time()
  ## Attach Frame Number to Dispersion Data
  datDispersion <- cbind(datDispersion,frameN=datAllFrames[datDispersion[,"frameRow"],'frameN'],
                         posX=datAllFrames[datDispersion[,"frameRow"],'posX'],
                         posY=datAllFrames[datDispersion[,"frameRow"],'posY'])
  
  ## Extract HUnt Event Foraging State
  ### 1. Get Dispersion Measure of each hunt event
  ## MERGE Dispersion With HuntEvent Records
    # Need to convert to char  GroupID factor( datHuntLabelledEventsSBMerged_fixed$groupID) 
    datDispersion$groupID <- levels( datDispersion$groupID)[datDispersion$groupID]
    datHEventDispersion <- merge(datDispersion,datHuntLabelledEventsSBMerged_fixed,
                                 all.y=TRUE,
                                 by.x=c("frameN","expID","eventID","groupID"),
                                 by.y=c("startFrame","expID","eventID","groupID") )
    ## Add Position In Arena
    saveRDS(datHEventDispersion,file=paste0(strDataExportDir,"/huntEvent_mergedwith_Dispersion",tsec_timeWindow,"sec.rds") )
    message("Saved to:",paste0(strDataExportDir,"/huntEvent_mergedwith_Dispersion",tsec_timeWindow,"sec.rds") )
    
    nmergemissingEvents <-  NROW(datHEventDispersion[!(datHEventDispersion$frameRow %in% datDispersion$frameRow),] )
    if (nmergemissingEvents > 0)
      warning("** ",nmergemissingEvents, " Hunt Events failed to merge ")
  end.time <- Sys.time()
  time.taken <- end.time - start.time
  print(time.taken)
  
  return(data.frame(datHEventDispersion ) )
}



```



```{r  merge hunt-events with dispersion data, fig.show="hold", out.width="50%", echo=FALSE, cache=FALSE,results=FALSE,message=FALSE }
source("DataLabelling/labelHuntEvents_lib.r")
source("HuntingEventAnalysis_lib.r")
  

#load(file=paste(strDatDir,"/LabelledSet/",strProcDataFileName,".RData",sep="" )) ##Save With Dataset Idx Identifier
datHuntLabelledEventsSBMerged_fixed <- getLabelledHuntEventsSet() # readRDS(file=paste(strDatDir,"/LabelledSet/",strProcDataFileName,".rds",sep="" ))

##Clear Warningss : assign("last.warning", NULL, envir = baseenv()
## Link Evoked and Spontaneous Trajectories
datHuntStat <- makeHuntStat(datHuntLabelledEventsSBMerged_fixed)
datExpPairs <- getSpontaneousEvokedExperimentPairs(datHuntStat)

message("Loading from :",paste0(strDataExportDir,"/huntEvent_mergedwith_Dispersion",tsec_timeWindow,"sec.rds") )
try(
datHEventDispersion <<- readRDS(file=paste0(strDataExportDir,"/huntEvent_mergedwith_Dispersion",tsec_timeWindow,"sec.rds") )
)

loadDispersionData()
## If we have not merged these records before, make them now
if (!exists("datHEventDispersion"))
{ 
  loaddatAllFrames()
  datHEventDispersion <- mergeDispersionOntoHuntEvents(datDispersion,datAllFrames,datHuntLabelledEventsSBMerged_fixed)
}

## Merge Max Dispersion on there - If it is not already there then Calculate and save 
if (!any(grepl("max_larval_Dispersion",names(datDispersion)) ) | 
    !any(grepl("min_larval_Dispersion",names(datDispersion)) ) |
    !any(grepl("Dispersion_larval_norm", names(datDispersion)) )  )
  datDispersion <<- mergeRangeOfLarvalDispersionPerLarvaOntoDispersion(datDispersion,datExpPairs)
## Check for max Calc Error
#datDispersion[datDispersion$Dispersion > datDispersion$max_Dispersion,]
```


```{r plot-trajectories-figures-function, fig.show="hold", out.width="50%", echo=FALSE ,results=FALSE,ref.label='setup'}
#Function to plot trajectories for each larva coloured based on dispersion
pairedTrajPalette <- col2hex(col2rgb(brewer.pal(12,"Paired"),alpha = 1))

#
# Function Plot Individual Trajectories for a group, split between exploration and exploitation
# given a *global* normalized dispersion measures threshold 
#
plotGlobalNormDispersionTrajectories <- function(groupID, datAllFrames, datDispersion, datHEventDispersion,datExpPairs,TH_DISP = 0.2)
{
  
  datGroupExploreTraj <- datAllFrames[datDispersion[datDispersion$groupID %in% groupID & datDispersion$Dispersion/AllRange[2] >= TH_DISP,"frameRow"],]
  datGroupExploitTraj <- datAllFrames[datDispersion[datDispersion$groupID %in% groupID & datDispersion$Dispersion/AllRange[2] < TH_DISP ,"frameRow"],]
  
  ## ind Exploration Hunt Events 
  datExplorationHuntEvents <- datHEventDispersion[datHEventDispersion$Dispersion/AllRange[2] >= TH_DISP, ]
  ## ind Exploration Hunt Events 
  datExploitationHuntEvents <- datHEventDispersion[datHEventDispersion$Dispersion/AllRange[2] < TH_DISP, ]
  
  
  plotExploreExploitTrajectories(groupID,datGroupExploreTraj,datGroupExploitTraj, datExplorationHuntEvents, 
                                 datExploitationHuntEvents,datDispersion,
                                 datExpPairs[datExpPairs$groupID.E %in%  groupID | datExpPairs$groupID.S %in%  groupID, ]) ##Subset to Targeted groups
  
} ## end of plot Function
 
##
# Function Plot Individual Trajectories for a group, split between exploration and exploitation
# given a *local* normalized dispersion measures threshold / the classification is relative to the mobility measure of each larvae in each condition 
##
plotExpNormDispersionTrajectories <- function(groupID, datAllFrames, datDispersion,datHEventDispersion, datExpPairs,TH_DISP = 0.2)
{

  datGroupExploreTraj <- datAllFrames[datDispersion[datDispersion$groupID %in% groupID & datDispersion$Dispersion_norm >= TH_DISP,"frameRow"],]
  datGroupExploitTraj <- datAllFrames[datDispersion[datDispersion$groupID %in% groupID & datDispersion$Dispersion_norm <  TH_DISP,"frameRow"],]
   
  ## \TODO: Norm per larva in both spont and Evoked
  ## ind Exploration Hunt Events 
  datExplorationHuntEvents <- datHEventDispersion[datHEventDispersion$Dispersion_norm >= TH_DISP, ]
  
  ## ind Exploration Hunt Events 
  datExploitationHuntEvents <- datHEventDispersion[datHEventDispersion$Dispersion_norm < TH_DISP, ]
  
  ## Call Plot Function - Both Spont And Evoked plo tted on same figure
  plotExploreExploitTrajectories(groupID,datGroupExploreTraj,datGroupExploitTraj, datExplorationHuntEvents, 
                                 datExploitationHuntEvents,datDispersion,
                                 datExpPairs[datExpPairs$groupID.E %in%  groupID | datExpPairs$groupID.S %in%  groupID, ]) ##Subset to Targeted groups
  
} ## end of plot Functon


## TODO: plot NB Mix clustered traj
# Function Plot Individual Trajectories for a group, split between exploration and exploitation
# given based on threshold placed on the normalized dispersion of the trajectories from combined spont and evoked conditions of each larva .
##
plotNBMixGClusteredDispersionTrajectories <- function(groupID, datAllFrames, datDispersion, datHEventDispersion,datExpPairs,TH_DISP = 0.2)
{ 
  #load(file=paste0(strDataExportDir,'jagsModelTestResults_NBMixGroupclustDispersion_All.RData') )
  datHEventDispersion <<- readRDS(file=paste0(strDataExportDir,"/huntEvent_mergedwith_Dispersion",tsec_timeWindow,"sec.rds") )
  
  ## Merge sparse Clustered Dispersions Results onto full Dispersion Data
  lparamsAll <- getMCMCNBGroupEstimatedParams(results.All,"All",2)
  if (!("clustID" %in% names(datSubDispersion)))
    datSubDispersion$clustID <- as.vector(lparamsAll$clustID)
  
  ##Add Clust ID on all Dispersion Data - interpolating the sparse   datSubDispersion
  datDispersion$clustID <- NA
  datDispersion[datSubDispersion$frameRow,"clustID"] <- datSubDispersion$clustID
  ##Fill in the gaps with the last value
  lastClustID <- NA
  idxA <- 1:NROW(datDispersion)
  for (i in 1:nsubsampleInterval )
  {
      datDispersion[idxA+i,"clustID"] <- datDispersion[idxA,"clustID"]
  }
    
  ##Merge Cluster ID onto Hunt Events
  datHEventDispersion <- merge(datHEventDispersion, cbind.data.frame (frameRow=datSubDispersion$frameRow,
                                                          #expID=datSubDispersion$expID,
                                                          #groupID=datSubDispersion$expID,
                                                          clustID=as.numeric(datSubDispersion$clustID) ),
                               by=c("frameRow"),all.x =TRUE,no.dups = FALSE)

  
  
  datGroupExploreTraj <- datAllFrames[datDispersion[datSubDispersion$groupID %in% groupID & datDispersion$clustID == 1,"frameRow"],]
  datGroupExploitTraj <- datAllFrames[datDispersion[datSubDispersion$groupID %in% groupID & datDispersion$clustID == 2,"frameRow"],]
  
  ## ind Exploration Hunt Events 
  datExplorationHuntEvents <- datHEventDispersion[datHEventDispersion$clustID == 1, ]
  ## ind Exploration Hunt Events 
  datExploitationHuntEvents <- datHEventDispersion[datHEventDispersion$clustID ==2, ]
  
  
  plotExploreExploitTrajectories(groupID,datGroupExploreTraj,datGroupExploitTraj, datExplorationHuntEvents, 
                                 datExploitationHuntEvents,datDispersion,
                                 datExpPairs[datExpPairs$groupID.E %in%  groupID | datExpPairs$groupID.S %in%  groupID, ],thin=5) ##Subset to Targeted groups
  
} ##

##
# Function Plot Individual Trajectories for a group, split between exploration and exploitation
# given based on threshold placed on the normalized dispersion of the trajectories from combined spont and evoked conditions of each larva .
##
plotLarvaNormDispersionTrajectories <- function(groupID, datAllFrames, datDispersion, datHEventDispersion,datExpPairs,TH_DISP = 0.2)
{ 
  datGroupExploreTraj <- datAllFrames[datDispersion[datDispersion$groupID %in% groupID & datDispersion$Dispersion_larval_norm >= TH_DISP,"frameRow"],]
  datGroupExploitTraj <- datAllFrames[datDispersion[datDispersion$groupID %in% groupID & datDispersion$Dispersion_larval_norm < TH_DISP,"frameRow"],]
  
  ## ind Exploration Hunt Events 
  datExplorationHuntEvents <- datHEventDispersion[datHEventDispersion$Dispersion_larval_norm >= TH_DISP, ]
  ## ind Exploration Hunt Events 
  datExploitationHuntEvents <- datHEventDispersion[datHEventDispersion$Dispersion_larval_norm < TH_DISP, ]
  
  
  plotExploreExploitTrajectories(groupID,datGroupExploreTraj,datGroupExploitTraj, datExplorationHuntEvents, 
                                 datExploitationHuntEvents,datDispersion,
                                 datExpPairs[datExpPairs$groupID.E %in%  groupID | datExpPairs$groupID.S %in%  groupID, ]) ##Subset to Targeted groups
  
} ##


## Plot function for scatter plot of colour coded larval trajectories, separated into explore and exploit vectors
## with Both Spont And Evoked plotted on same figure
###  datExpPairs - expID for Spont and Evoked for each larva
plotExploreExploitTrajectories <- function(groupID,datGroupExploreTraj,datGroupExploitTraj, datExplorationHuntEvents, datExploitationHuntEvents, datDispersion, datExpPairs, thin=3,TH_DISP = 0.2)
{
  
  #vexpID <-  unique(datGroupExploitTraj$exp) 
  #par(mfrow=c(2,NROW(vexpID))) ##MultiPlot Page
  #par(mar=c(1,1,1,1))
  #layout(matrix(seq(1,NROW(vexpID)), 2,NROW(vexpID) , byrow = TRUE))
  i <- 0
  for (j in 1:nrow(datExpPairs) )
  {
      e <- datExpPairs[j,]
      if (is.na(e$expID.E))
        next()
      x1  <- seq(0, 640 )
      y1  <- seq(0, 550 )

      #print(e)
      plot(0,0,ylim=range(y1),xlim=range(x1), type="l", col="red", main=paste(groupID[1],e$expID.E,"/",groupID[2],e$expID.S) )
      ## Evoked Exploration
      datTraj <- datGroupExploreTraj[datGroupExploreTraj$expID == as.character(e$expID.E) & !is.na(datGroupExploreTraj$posX),]
      if (NROW(datTraj))
      {
        idxplot <- seq(1,NROW(datTraj),thin)
        points(datTraj[idxplot,]$posX,datTraj[idxplot,]$posY,type="p", col=pairedTrajPalette[1], cex=0.1);
      }
      ## Add Hunt Events on Map
      # Evoked Exploration
      datSpotHunts.E.Explore <- datExplorationHuntEvents[datExplorationHuntEvents$expID == as.character(e$expID.E)  & !is.na(datExplorationHuntEvents$expID), ] 
      points(datSpotHunts.E.Explore$posX, datSpotHunts.E.Explore$posY, col=pairedTrajPalette[2], cex=1.2, pch=17) ## Triangle Explore
  
      ## Spontaneous Explore
      datTraj <- datGroupExploreTraj[datGroupExploreTraj$expID == as.character(e$expID.S) & !is.na(datGroupExploreTraj$posX),]
      if (NROW(datTraj))
      {
        idxplot <- seq(1,NROW(datTraj),thin)
        points(datTraj[idxplot,]$posX,datTraj[idxplot,]$posY,type="p", col=pairedTrajPalette[3], cex=0.1);
      }
      ## Spont Exploration
      datSpotHunts.S.Explore <- datExplorationHuntEvents[datExplorationHuntEvents$expID == as.character(e$expID.S)  & !is.na(datExplorationHuntEvents$expID), ] 
      points(datSpotHunts.S.Explore$posX, datSpotHunts.S.Explore$posY, col=pairedTrajPalette[4], cex=1.2, pch=17) ##  Triangle Explore
  
      
      ## Evoked Exploit
      datTraj <- datGroupExploitTraj[datGroupExploitTraj$expID == as.character(e$expID.E) & !is.na(datGroupExploitTraj$posX),]
      if (NROW(datTraj))
      {      
        idxplot <- seq(1,NROW(datTraj),thin)
        points(datTraj[idxplot,]$posX,datTraj[idxplot,]$posY,type="p",col=pairedTrajPalette[5], cex=0.1)
      }
      ## Evoked Exploitation
      datSpotHunts.E.Exploit <- datExploitationHuntEvents[datExploitationHuntEvents$expID == as.character(e$expID.E)  & !is.na(datExploitationHuntEvents$expID), ] 
      points(datSpotHunts.E.Exploit$posX, datSpotHunts.E.Exploit$posY,col=pairedTrajPalette[6], cex=1.2,pch=15) ## Square Evoked


      ## Spontaneous Exploit
      datTraj <- datGroupExploitTraj[datGroupExploitTraj$expID == as.character(e$expID.S) & !is.na(datGroupExploitTraj$posX),]
      if (NROW(datTraj))
      { 
        idxplot <- seq(1,NROW(datTraj),thin)
        points(datTraj[idxplot,]$posX,datTraj[idxplot,]$posY,type="p",col=pairedTrajPalette[7], cex=0.1)
      }
      ## Hunt Episodes Spont Exploitation
      datSpotHunts.S.Exploit <- datExploitationHuntEvents[datExploitationHuntEvents$expID == as.character(e$expID.S)  & !is.na(datExploitationHuntEvents$expID), ] 
      points(datSpotHunts.S.Exploit$posX, datSpotHunts.S.Exploit$posY,col=pairedTrajPalette[8], cex=1.2,pch=15) ## Square Evoked
  
      
      badd <- TRUE
      ## Add dispersion Time Line + Hunt Events + Norm threshold Threshold
      datDisp.S <- datDispersion[datDispersion$expID == as.character(e$expID.S) ,]
      datDisp.E <- datDispersion[datDispersion$expID == as.character(e$expID.E) ,]
      ## Sort by frameRo
      datDisp.S <- datDisp.S[order( as.numeric(datDisp.S$frameRow) ), ]
      datDisp.E <- datDisp.E[order( as.numeric(datDisp.E$frameRow) ), ]
            
      idxplot.S <- seq(min(1,NROW(datDisp.S)),max(1,NROW(datDisp.S)),thin)
      idxplot.E <- seq(min(1,NROW(datDisp.S)),max(1,NROW(datDisp.E)) ,thin)
      datDisp.S.frame <- as.numeric(datDisp.S[idxplot.S,]$frameRow)- min((as.numeric(datDisp.S[idxplot.S,]$frameRow) ),na.rm = TRUE ) #datAllFrames[datDisp.S[idxplot.S,]$frameRow,"frameN" ]
      datDisp.E.frame <- max(datDisp.S.frame,na.rm=TRUE) +  as.numeric(datDisp.E[idxplot.E,]$frameRow)-min(c(as.numeric(datDisp.E[idxplot.E,]$frameRow) ),na.rm = TRUE ) 
      
      ##frameN restarts to 0 for each event so best use frameRow
      plot(datDisp.S.frame/G_APPROXFPS ,datDisp.S[idxplot.S,]$Dispersion,type="l" ,ylim=c(0,10),xlim=c(0,max(c(0,datDisp.E.frame),na.rm =TRUE)/G_APPROXFPS ),xlab="(sec)",
           ylab="Dispersal (mm)", col=colourDataScheme[[ as.character(e$groupID.S)  ]] )
      lines(datDisp.E.frame/G_APPROXFPS, datDisp.E[idxplot.E,]$Dispersion,type="l", col=colourDataScheme[[ as.character(e$groupID.E)  ]] )
      
      ##All Hunt larva hunt events together
      datSpotHunts.S <- rbind(datSpotHunts.S.Exploit,datSpotHunts.S.Explore)
      datSpotHunts.E <- rbind(datSpotHunts.E.Exploit,datSpotHunts.E.Explore)  
      
      ##Add Hunt Event ##datDisp.S[datDisp.S$frameRow == datSpotHunts.S$frameRow,]$Dispersion <- fails cause Disp data may be missing at hunt event frame
      ## Use FrameRow As timepoint sequence - reset to 0 using min(frameRow) for event, and attach Evoked to the back of spontaneous
      points( (as.numeric(datSpotHunts.S$frameRow)-min(as.numeric(datDisp.S[idxplot.S,]$frameRow),na.rm=TRUE ) )/G_APPROXFPS, rep(-0.1,times=NROW(datSpotHunts.S$frameN)), cex=1, pch=17)
      points( (max(idxplot.S) +  as.numeric(datSpotHunts.E$frameRow)-min(as.numeric(datSpotHunts.E$frameRow)))/G_APPROXFPS, rep(-0.1,times=NROW(datSpotHunts.E$frameN)) ,cex=1,pch=17)
      ##Show Larval Norm Threshold - Draw line
      thres_Dispersion_mm <- min((datDisp.E[datDisp.E$Dispersion_larval_norm >= TH_DISP, ] $Dispersion),na.rm=TRUE )
      segments(0,thres_Dispersion_mm, max(datDisp.E.frame,na.rm=TRUE)/G_APPROXFPS,
               thres_Dispersion_mm,lty=3)
      
      
      #stopifnot(i < 5)
      i <- i+1
  } ## For Each Event
    
}## End of Function 


```



```{r Calc Dispersion of Each Trajectory,include=FALSE}
calcTrajectoryDispersions <- function(datAllFrames)
{

  datDispersion <- data.frame()
  vexpID <- unique(datAllFrames$expID)
  e <- vexpID[1]
  ##'Add new column
  datAllFrames$Dispersion <- NA
  
  start.time <- Sys.time()
   
  i = 0;

  ## For Each Recording Event of each experiment
    for (e in vexpID)
    {
      i = i + 1
      message(i,". ExpID:",e)
      
      
      stopifnot(is.numeric(e) & e > 0)
      #stopifnot(i < 3) ##Test Run
      
      vEventID = unique((datAllFrames[datAllFrames$expID == e,]$eventID))
    
      ##For Each Event
      for (ev in vEventID)
      {
        datEventFrames <- datAllFrames[datAllFrames$expID == e & datAllFrames$eventID == ev & datAllFrames$posX != 0 ,]  
      
        meanfps <-  head(datEventFrames$fps,1)
        groupID <- as.character(unique(datEventFrames$groupID) )
        message(paste("ExpID:",e,"EventID:",ev,"fps:",meanfps," nFrames:",NROW(datEventFrames)) )
        #  We may Need to Identify TrackLet Units, Avoid speed calc errors due to fish going in and out of view
        #  PROCESS TrackLets #
        #vTracklets <- unique(datEventFrames$trackletID)
        
        if (NROW(datEventFrames) < 10)
          next() ##No Frames In event - Move to next one
        
        lEventDispersionAndLength <- calcTrajectoryDispersionAndLength(datEventFrames,tsec_timeWindow) 
        
        datEventDispersion <- data.frame(expID=e,
                                         eventID=ev,
                                         Dispersion=(lEventDispersionAndLength$Dispersion), #Radius Encompassing tsec_timeWindow Trajectory
                                         Dispersion_norm=(lEventDispersionAndLength$Dispersion), #Not Normed Yet
                                         Length = lEventDispersionAndLength$Length, ##Total Distance Travelled
                                         MSD = lEventDispersionAndLength$MSD, ##Total Distance Travelled
                                         SD = lEventDispersionAndLength$SD, ##Total Distance Travelled
                                         frameRow=as.integer(row.names( datEventFrames))  )
  
        ##Append to main Dispersion Data Frame
        datDispersion <- rbind(datEventDispersion,datDispersion)
        
      }##For Each Event
  
    ## \TODO Normalize Dispersion Per Larva Here - Dividing by the maximum dispersion
    datExpDisp <- datDispersion[datDispersion$expID == e,]
    range_Disp <- range(datExpDisp$Dispersion,na.rm=TRUE)
     if (!is.na(range_Disp))
        datDispersion[datDispersion$expID == e,]$Dispersion_norm <- datExpDisp$Dispersion/range_Disp[2]
    
    end.time <- Sys.time()
    time.taken <- end.time - start.time
    print(time.taken)
    
    }#For Each Exp ID
  
    end.time <- Sys.time()
    time.taken <- end.time - start.time
    print(time.taken)
    
  datDispersion <- cbind(datDispersion,groupID=datAllFrames[datDispersion$frameRow,]$groupID)
    
  saveRDS(datDispersion,file=paste0(strDataExportDir,"/foragingState_Dispersion",tsec_timeWindow,"sec.rds") )
  
  return (datDispersion)
} ## Calc Fuction

#hist(datDispersion$Dispersion_norm )
```

## Detect Exploration -Exploitation via dispersion
 
 In Marquez et al. 2019 Ext Fig 3a, the dispersion of each larva is normalized against its own range before the overall (bimodal) distribution is shown.
 The normalized dispersion distributions  of each larva are used to detect the threshold that separates the exploitation and exploration state.  
 They report (Extended Data Fig. 3a), substantially higher dispersal in the exploration state (9.6 ± 2.5 mm, mean ± s.d., n = 36 animals) than in the exploitation state (2.3 ± 1.3 mm, n = 36 animals).

 Using my tracking data I calculated the dispersion at each tracked video frame and plot the distribution to examine if they are bimodal (here using the `r tsec_timeWindow` seconds window).
However, my tracking of each larva is limited to 10 min, and includes only the centre of the arena, but in Marquez et al. 2019 each larva is recorded *for 50-80 min*, while the mean duration of each state is reported to be on average, the *exploitation state persists for 7.1 ± 3.9 min*, and *exploration state persists for 5.5 ± 6.2 min*
(mean ± s.d., n = 36 animals). The duration of each state follows an exponential distribution (λ = 0.17 min−1
for exploitation, λ = 0.22 min−1 for exploration, pooled distribution of n = 36 animals) see (raw data shown on Ext. Fig 7a).

Unfortunatelly with my 10 min recordings for each larvae, it is most likely that I will not observe their behaviour in both states, but likely only observe them in on of these states. This is added ontop the fact that I do not record around the edges of the arena, as they do to see them run around.
Therefore, normalizing and setting a threshold on a per larva basis may not be a good idea.
Perhaps it is best I combine the trajectories of spontaneous and evoked activity for each larva so as to obtain 20min of observation time. 

 Without normalizing the distribution is shown on the left, and a version normalized per max dispersion measured in each experiment is on the right :
 
```{r dispersion histograms across groups, fig.show="hold", out.width="33%", echo=FALSE, results='hide'  }
loadDispersionData()

hist(datDispersion$Dispersion,breaks=50,main="(All groups): Dispersion lengths per experiment ",xlab="Dispersion (mm)")
hist(datDispersion$Dispersion_norm,breaks=50,main="(All groups): Dispersion normalized",xlab="Dispersion (exp. norm)")
hist(datDispersion$Dispersion_larval_norm ,breaks=50,main="(All groups): Dispersion normalized per larva",xlab="Dispersion (larva norm)")


```
We look at each rearing group separatelly, while combining their evoked and spontaneous conditions

```{r dispersion histograms per group across conditions, fig.show="hold", out.width="33%", echo=FALSE, results='hide'  }
hist(datDispersion[datDispersion$groupID %in% c('LE','LL'), ]$Dispersion,breaks=50,main="LF Evoked+Spont.",xlab="Dispersion (mm)",col=colourDataScheme$LF$Evoked)
hist(datDispersion[datDispersion$groupID %in% c('NE','NL'), ]$Dispersion,breaks=50,main="NF Evoked+Spont.",xlab="Dispersion (mm)",col=colourDataScheme$NF$Evoked)
hist(datDispersion[datDispersion$groupID %in% c('DE','DL'), ]$Dispersion,breaks=50,main="DF Evoked+Spont.",xlab="Dispersion (mm)",col=colourDataScheme$DF$Evoked)

```


We then plot each experimental group individually, also examining the dispersion in evoked (in the presence of prey) and spontaneous (no prey) conditions separatellly.
Next we plot these for each experimental condition individually (non-Normalized):
```{r dispersion histograms per group per condition, fig.show="hold", out.width="33%", echo=FALSE, results='hide'  }
# 
# ## Normed over all Recorded Dispersions
 hist(datDispersion[datDispersion$groupID == 'LE', ]$Dispersion,breaks=100,main="LF Spontaneous",xlab="Dispersion (mm)",col=colourDataScheme$LF$Spont)
 hist(datDispersion[datDispersion$groupID == 'NE', ]$Dispersion,breaks=100,main="NF Spontaneous",xlab="Dispersion (mm)",col=colourDataScheme$NF$Spont)
 hist(datDispersion[datDispersion$groupID == 'DE', ]$Dispersion,breaks=100,main="DF Spontaneous",xlab="Dispersion (mm)",col=colourDataScheme$DF$Spont)

 hist(datDispersion[datDispersion$groupID == 'LL', ]$Dispersion,breaks=100,main="LF Evoked",xlab="Dispersion (mm)",col=colourDataScheme$LF$Evoked)
 hist(datDispersion[datDispersion$groupID == 'NL', ]$Dispersion,breaks=100,main="NF Evoked",xlab="Dispersion (mm)",col=colourDataScheme$NF$Evoked)
 hist(datDispersion[datDispersion$groupID == 'DL', ]$Dispersion,breaks=100,main="DF Evoked",xlab="Dispersion (mm)",col=colourDataScheme$DF$Evoked)
```
 
Smooth estimates using a gaussian kernel show a shift towards exploitation for the pooled *LF* trajectories 
```{r dispersion densities per larva-Split E-S, fig.show="hold", out.width="33%", echo=FALSE, results='hide' }
loadDispersionData()
 ## plot est, Densities Compare Spont to Evoked
 BW=0.2
 plot(density(datDispersion[datDispersion$groupID == 'NE', ]$Dispersion, kernel="gaussian",na.rm=TRUE, bw=BW), lwd=4, ylim=c(0,0.7), col=colourDataScheme$NF$Spont,main="NF  ",xlab="Dispersion (mm)",lty=1  )
 lines(density(datDispersion[datDispersion$groupID == 'NL', ]$Dispersion,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$NF$Evoked,main=NA,lty=2)
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$NF$Spont,colourDataScheme$NF$Evoked),lwd=3 ) 
 
  plot(density(datDispersion[datDispersion$groupID == 'LE', ]$Dispersion, kernel="gaussian",na.rm=TRUE,bw=BW), lwd=4, ylim=c(0,0.7),col=colourDataScheme$LF$Spont,main="LF  ",xlab="Dispersion (mm)",lty=1 )
 lines(density(datDispersion[datDispersion$groupID == 'LL', ]$Dispersion,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$LF$Evoked,main=NA,lty=2 )
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$LF$Spont,colourDataScheme$LF$Evoked),lwd=3 ) 

 plot(density(datDispersion[datDispersion$groupID == 'DE', ]$Dispersion, kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4, ylim=c(0,0.7),col=colourDataScheme$DF$Spont,main="DF  ",xlab="Dispersion (mm)",lty=1 )
 lines(density(datDispersion[datDispersion$groupID == 'DL', ]$Dispersion,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$DF$Evoked,main=NA,lty=2 )
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$DF$Spont,colourDataScheme$DF$Evoked),lwd=3 ) 

```


<!-- For completness, the following dispersions have been normalized to maximum trajectory dispersion found across all experiments (*global normalization*): -->
```{r plot globally normalized dispersion distributions, fig.show="hold", out.width="33%", echo=FALSE, results='hide',include=FALSE,eval=FALSE  }

# ## Normed over all Recorded Dispersions
 hist(datDispersion[datDispersion$groupID == 'LE', ]$Dispersion/AllRange[2],breaks=100,main="LF Spontaneous",xlab="Dispersion (global norm. )")
 hist(datDispersion[datDispersion$groupID == 'NE', ]$Dispersion/AllRange[2],breaks=100,main="NF Spontaneous",xlab="Dispersion (global norm. )")
 hist(datDispersion[datDispersion$groupID == 'DE', ]$Dispersion/AllRange[2],breaks=100,main="DF Spontaneous",xlab="Dispersion (global norm. )")

 hist(datDispersion[datDispersion$groupID == 'LL', ]$Dispersion/AllRange[2],breaks=100,main="LF Evoked",xlab="Dispersion (global norm. .)")
 hist(datDispersion[datDispersion$groupID == 'NL', ]$Dispersion/AllRange[2],breaks=100,main="NF Evoked",xlab="Dispersion (global norm. )")
 hist(datDispersion[datDispersion$groupID == 'DL', ]$Dispersion/AllRange[2],breaks=100,main="DF Evoked",xlab="Dispersion (global norm. )")
 
```

### Normalized dispersion per experiment

Next, we examine the same dispesions normalized against the maximum dispersion calculated in the trajectory length of the respective experiment.
Each measured dispersion is divided by the max dispersion trajectory experiment,
(ie for each larva  this can be different in evoked or spontaneous conditions).

```{r plot normalized dispersion distributions, fig.show="hold", out.width="33%", echo=FALSE, results='hide' }
### Normed Per Larva

hist(datDispersion[datDispersion$groupID == 'LE', ]$Dispersion_norm,breaks=100,main="LF Spontaneous",xlab="Dispersion  (norm per exp.)", col=colourDataScheme$LF$Spont)
hist(datDispersion[datDispersion$groupID == 'NE', ]$Dispersion_norm,breaks=100,main="NF Spontaneous",xlab="Dispersion  (norm per exp.)", col=colourDataScheme$NF$Spont)
hist(datDispersion[datDispersion$groupID == 'DE', ]$Dispersion_norm,breaks=100,main="DF Spontaneous",xlab="Dispersion  (norm per exp.)", col=colourDataScheme$DF$Spont)

hist(datDispersion[datDispersion$groupID == 'LL', ]$Dispersion_norm,breaks=100,main="LF Evoked",xlab="Dispersion  (norm per exp.)",col=colourDataScheme$LF$Evoked)
hist(datDispersion[datDispersion$groupID == 'NL', ]$Dispersion_norm,breaks=100,main="NF Evoked",xlab="Dispersion  (norm per exp.)",col=colourDataScheme$NF$Evoked)
hist(datDispersion[datDispersion$groupID == 'DL', ]$Dispersion_norm,breaks=100,main="DF Evoked",xlab="Dispersion  (norm per exp.)",col=colourDataScheme$DF$Evoked)

```

### Normalized dispersion per larva combined test conditions

Because each larva is recorded in two conditions, and as Marquez et al 2019 report that the foraging state switching can be seen intact both in the presence and in the absence of prey , we may then combine our spontaneous and evoked condition recordings and treat them as a single unit,  thus allowing us to  normalize each larvas trajectories to the max dispersion found across both its test conditions.  In this manner each larva's dispersion is examined across a 20min recording session.

```{r dispersion histogram normalized per larva, fig.show="hold", out.width="33%", echo=FALSE, results='hide' }
### Dispesions distributions Normalized on Per Larva basis - 

hist(datDispersion[datDispersion$groupID %in% c('LE','LL'), ]$Dispersion_larval_norm, breaks=100,main="LF S+E ",xlab="Dispersion  (norm per larva)")
hist(datDispersion[datDispersion$groupID %in% c('NE','NL'), ]$Dispersion_larval_norm, breaks=100,main="NF S+E",xlab="Dispersion  (norm per larva)")
hist(datDispersion[datDispersion$groupID %in% c('DE','DL'), ]$Dispersion_larval_norm, breaks=100,main="DF S+E",xlab="Dispersion  (norm per larva)")

```

#### Histograms of normalized dispersion per larva, split S-E conditions 


Separating Spontaneous from Evoked Conditions we see a potential shift toward lower dispersion in the presence of prey:

```{r,dispersion histogram normalized per larva-Split E-S, fig.show="hold", out.width="50%", echo=FALSE, results='hide' }
### Dispesions distributions Normalized on Per Larva basis - 

hist(datDispersion[datDispersion$groupID %in% c('LE'), ]$Dispersion_larval_norm, breaks=100,main="LF Spont ", xlab="Dispersion  (norm per larva)",col=colourDataScheme$LF$Spont)
hist(datDispersion[datDispersion$groupID %in% c('LL'), ]$Dispersion_larval_norm, breaks=100,main="LF Evoked ",xlab="Dispersion  (norm per larva)",col=colourDataScheme$LF$Evoked)

hist(datDispersion[datDispersion$groupID %in% c('NE'), ]$Dispersion_larval_norm, breaks=100,main="NF Spont ", xlab="Dispersion  (norm per larva)",col=colourDataScheme$NF$Spont)
hist(datDispersion[datDispersion$groupID %in% c('NL'), ]$Dispersion_larval_norm, breaks=100,main="NF Evoked ",xlab="Dispersion  (norm per larva)", col=colourDataScheme$NF$Evoked)

hist(datDispersion[datDispersion$groupID %in% c('DE'), ]$Dispersion_larval_norm, breaks=100,main="DF Spont ", xlab="Dispersion  (norm per larva)",col=colourDataScheme$DF$Spont)
hist(datDispersion[datDispersion$groupID %in% c('DL'), ]$Dispersion_larval_norm, breaks=100,main="DF Evoked ",xlab="Dispersion  (norm per larva)",col=colourDataScheme$DF$Evoked)
```



#### Density estimation normalized dispersion per larva - compare Evoked to Spontaneous

Next I estimated densities using a gaussian kernel, allowing direct comparison between test conditions shows LF dispersions are modified by the presence of prey.

```{r dispersion densities normalized per larva-Split E-S, fig.show="hold", out.width="33%", echo=FALSE, results='hide' }
 ## plot est, Densities Compare Spont to Evoked
 BW=0.01
 ylimUp <- 5
 plot(density(datDispersion[datDispersion$groupID == 'NE', ]$Dispersion_larval_norm, kernel="gaussian",na.rm=TRUE, bw=BW), lwd=4, ylim=c(0,ylimUp), col=colourDataScheme$NF$Spont,main="NF  ",xlab="Dispersion (norm. per larva)",lty=1  )
 lines(density(datDispersion[datDispersion$groupID == 'NL', ]$Dispersion_larval_norm,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$NF$Evoked,main=NA,lty=2)
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$NF$Spont,colourDataScheme$NF$Evoked),lwd=3 ) 
 
 plot(density(datDispersion[datDispersion$groupID == 'LE', ]$Dispersion_larval_norm, kernel="gaussian",na.rm=TRUE,bw=BW), lwd=4, ylim=c(0,ylimUp),col=colourDataScheme$LF$Spont,main="LF  ",xlab="Dispersion (norm. per larva)",lty=1 )
 lines(density(datDispersion[datDispersion$groupID == 'LL', ]$Dispersion_larval_norm,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$LF$Evoked,main=NA,lty=2 )
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$LF$Spont,colourDataScheme$LF$Evoked),lwd=3 ) 

 plot(density(datDispersion[datDispersion$groupID == 'DE', ]$Dispersion_larval_norm, kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4, ylim=c(0,ylimUp),col=colourDataScheme$DF$Spont,main="DF  ",xlab="Dispersion (norm. per larva)",lty=1 )
 lines(density(datDispersion[datDispersion$groupID == 'DL', ]$Dispersion_larval_norm,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$DF$Evoked,main=NA,lty=2 )
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$DF$Spont,colourDataScheme$DF$Evoked),lwd=3 ) 
```

#### Maximum dispersion per larva
Then examining the maximum larval dispersions, against which we normalize we find :

#### Histograms of max dispersion per larva
```{r Max-dispersion histogram per larva-Split E-S, fig.show="hold", out.width="33%", echo=FALSE, results='hide' }
##### Maximum Dispersions Per Larva- 
datMaxDispersionPerLarva <- readRDS(file=paste0(strDataExportDir,"/foragingState_max_Dispersion_perLarva_",tsec_timeWindow,"sec.rds") )
nBreaks=20
ylimUp <- 20
# extract Evoked to Spont max disp data
datMaxDispersionPerExp.NF.Spont <- datMaxDispersionPerLarva[datMaxDispersionPerLarva$expID %in% datExpPairs[datExpPairs$groupID.S == 'NE' ,]$expID.S, ]$max_exp_Dispersion
datMaxDispersionPerExp.NF.Evoked <- datMaxDispersionPerLarva[datMaxDispersionPerLarva$expID %in% datExpPairs[datExpPairs$groupID.E == 'NL' ,]$expID.E, ]$max_exp_Dispersion

datMaxDispersionPerExp.LF.Spont <- datMaxDispersionPerLarva[datMaxDispersionPerLarva$expID %in% datExpPairs[datExpPairs$groupID.S == 'LE' ,]$expID.S, ]$max_exp_Dispersion 
datMaxDispersionPerExp.LF.Evoked <- datMaxDispersionPerLarva[datMaxDispersionPerLarva$expID %in% datExpPairs[datExpPairs$groupID.E == 'LL' ,]$expID.E, ]$max_exp_Dispersion

datMaxDispersionPerExp.DF.Spont <- datMaxDispersionPerLarva[datMaxDispersionPerLarva$expID %in% datExpPairs[datExpPairs$groupID.S == 'DE' ,]$expID.S, ]$max_exp_Dispersion
datMaxDispersionPerExp.DF.Evoked <- datMaxDispersionPerLarva[datMaxDispersionPerLarva$expID %in% datExpPairs[datExpPairs$groupID.E == 'DL' ,]$expID.E, ]$max_exp_Dispersion

## Max reported is across NE/NL - so checking either condition would suffice to get the max for each larva
datMaxDispersionPerLarva.LF <- datMaxDispersionPerLarva[datMaxDispersionPerLarva$expID %in% datExpPairs[datExpPairs$groupID.S == 'LE' ,]$expID.S, ]$max_larval_Dispersion
datMaxDispersionPerLarva.NF <- datMaxDispersionPerLarva[datMaxDispersionPerLarva$expID %in% datExpPairs[datExpPairs$groupID.S == 'NE' ,]$expID.S, ]$max_larval_Dispersion
datMaxDispersionPerLarva.DF <- datMaxDispersionPerLarva[datMaxDispersionPerLarva$expID %in% datExpPairs[datExpPairs$groupID.S == 'DE' ,]$expID.S, ]$max_larval_Dispersion 


# plot histograms
hist((datMaxDispersionPerLarva.NF)
     , breaks=nBreaks,main="NF Larvae ", xlab="Max. dispersion  per larva (mm)",xlim=c(0,10),col=colourDataScheme$NF$Evoked,ylim=c(0,ylimUp))

hist((datMaxDispersionPerLarva.LF)
     , breaks=nBreaks,main="LF Larvae ", xlab="Max. dispersion  per larva (mm)",xlim=c(0,10),col=colourDataScheme$LF$Evoked,ylim=c(0,ylimUp))

hist((datMaxDispersionPerLarva.DF),
     breaks=nBreaks,main="DF Larvae ", xlab="Max. dispersion per larva (mm)",xlim=c(0,10),col=colourDataScheme$DF$Evoked,ylim=c(0,ylimUp))

```

#### Compare distribution of max dispersion per larva

```{r  max-dispersion densities compare groups, fig.show="hold", out.width="50%", echo=FALSE, cache=TRUE }
 ## plot est, Densities Compare Spont to Evoked
 pBW <- 1
 ylimUp <- 0.5
 plot(density(datMaxDispersionPerLarva.NF, kernel="gaussian",na.rm=TRUE, bw=pBW), lwd=4, ylim=c(0,ylimUp), col=colourDataScheme$NF$Evoked,main="Maximum Dispersion Per Larva  ",xlab="Dispersion (mm)",lty=lineTypeL.NF  )
lines(density((datMaxDispersionPerLarva.LF), kernel="gaussian",na.rm=TRUE,bw=pBW), lwd=4, ylim=c(0,ylimUp),col=colourDataScheme$LF$Evoked,main=NA,xlab=NA,lty=lineTypeL.LF )
lines(density((datMaxDispersionPerLarva.DF), kernel="gaussian",na.rm=TRUE,bw=pBW),lwd=4, ylim=c(0,ylimUp),col=colourDataScheme$DF$Evoked,main=NA,xlab=NA,lty=lineTypeL.DF )

legend("topright",c("NF","LF","DF"), lty=c(lineTypeL.NF,lineTypeL.LF,lineTypeL.DF),col=c(colourDataScheme$NF$Evoked,colourDataScheme$LF$Evoked,colourDataScheme$DF$Evoked),lwd=3 ) 
print(pBW)
```

##### Compare max dispersion distributions between conditions 

It appears that the max dispersions do not differ much between spontaneous and evoked conditions for the DF group, 
while there seems to be some evidence that  LF Larvae explore more in the absence of prey and perhaps,suprisingly, NF larvae explore less in the absence of prey.
Maybe these could make sense under an expected reward paradigm, given experience.


```{r max-dispersion per larva densities split conditions, fig.show="hold", out.width="33%", echo=FALSE, cache=FALSE }
 ## plot est, Densities Compare Spont to Evoked

 ylimUp <- 0.5
 plot(density(datMaxDispersionPerExp.NF.Spont, kernel="gaussian",na.rm=TRUE, bw=pBW), lwd=4, ylim=c(0,ylimUp), col=colourDataScheme$NF$Spont,main="NF Trajectories  ",xlab="Max Dispersion (mm)",lty=1  )
 lines(density(datMaxDispersionPerExp.NF.Evoked,kernel="gaussian",na.rm=TRUE,bw=pBW),lwd=4,col=colourDataScheme$NF$Evoked,main=NA,lty=2)
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$NF$Spont,colourDataScheme$NF$Evoked),lwd=3 ) 
 
 
 plot(density(datMaxDispersionPerExp.LF.Spont, kernel="gaussian",na.rm=TRUE,bw=pBW), lwd=4, ylim=c(0,ylimUp),col=colourDataScheme$LF$Spont,main="LF  Trajectories",xlab="Max Dispersion (mm)",lty=1 )
 lines(density(datMaxDispersionPerExp.LF.Evoked,kernel="gaussian",na.rm=TRUE,bw=pBW),lwd=4,col=colourDataScheme$LF$Evoked,main=NA,lty=2 )
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$LF$Spont,colourDataScheme$LF$Evoked),lwd=3 ) 

 plot(density(datMaxDispersionPerExp.DF.Spont, kernel="gaussian",na.rm=TRUE,bw=pBW),lwd=4, ylim=c(0,ylimUp),col=colourDataScheme$DF$Spont,main="DF  Trajectories",xlab="max Dispersion (mm)",lty=1 )
 lines(density(datMaxDispersionPerExp.DF.Evoked,kernel="gaussian",na.rm=TRUE,bw=pBW),lwd=4,col=colourDataScheme$DF$Evoked,main=NA,lty=2 )
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$DF$Spont,colourDataScheme$DF$Evoked),lwd=3 ) 
```

# Clustering dispersal data

## Clustering dispersal using a mixture of 2 Gaussians (*GM Model*)

I made a simple mixture of C=`r Nclust` Gaussians model to cluster the disperal data pooled across larvae. I infer the Gaussian parameters for each group/condition using Bayesian inference and MCMC.  
Parameter inference is done on the Dispersion data of each group/condition separately,  using dispersion data that has been subsampled to  `r G_APPROXFPS/nsubsampleInterval`sec intervals.

#### todo: Fix Math model 
\[
D^G \sim \mathcal{N}(\mu^G,\sigma^G)\\
k_c \sim \mathbb{categorical}(\lambda)\\
d_l \sim \mathcal{N}(\mu_{k[c]},\sigma_{k[c]})
\]
where the $\sum^{K}_{k=1}\lambda_k = 1$.
```{r clustering-code-setup,eval=TRUE, include=FALSE}
## Because the Full Dispersion Record data is too large- I use a sparse subsampled version to cluster the motin
## this works because movement at 0.5 sec intervals should be sufficient to classify the  larva's dispersion   over the last 5 sec
# nsamp allows a quick random subset to be created for testing purposes .
makeDispersionDataInferenceSet <- function(bQuickTest = FALSE,nsamp=4000)
{
  #nsubsample <- 10000 
  ##Subsample The Dispersion Data into 0.5 sec bins - But Add the hunt Event Frames
  loadDispersionData()
  datSubDispersion  <- datDispersion[ !is.na(datDispersion$Dispersion), ]
  datSubDispersion <- datSubDispersion[seq(1,NROW(datSubDispersion),by=nsubsampleInterval ),]
  # add the exact frames of hunt events so we can cluster them in exploit/Explore easly datHEventDispersion$frameRow
  # Frame Records of Huntevents not in SubSampled frames
  missinghuntEvents.frameROW <- datHEventDispersion[!(datHEventDispersion$frameRow %in% datSubDispersion$frameRow),"frameRow"] 
  # Merge missing hunt Frames onto subsampled dispersion data so we can cluster Hunt Events Specifically
  datSubDispersion <- rbind(datSubDispersion,datDispersion[datDispersion$frameRow %in% missinghuntEvents.frameROW,])
  
  #Add Hunt Initiation Events
  datSubDispersion$HuntMode <- 0
  datSubDispersion[datSubDispersion$frameRow %in% datHEventDispersion$frameRow,"HuntMode"] <- 1
  ## Lastly / Model and Cluster All Data so we can then run a relative comparison between groupscompare

  if (bQuickTest)
      datSubDispersion   <- datSubDispersion[sample(1:NROW(datSubDispersion),nsamp),]
  
  return(datSubDispersion)
}

```

The GM model is implemented in RJags and its code is as as follows:
```{r dispersal-RJags-GaussianMix-pooled-data model,include=TRUE,ref.label='clustering-code-setup'}
strDispersionClusterModel <- "
var initR[1,Nclust];
model {
    # Likelihood: 
    for( i in 1 : N ) {
      y[i] ~ dnorm( muOfClust[ clust[i] ], tauOfClust[ clust[i] ] )
      #mu[i] <-  ]
      clust[i] ~ dcat( pClust[1:Nclust] )
    }
    
    # Prior:
    for ( clustIdx in 1: Nclust ) {
      muOfClust[clustIdx]  ~ dnorm( 0 , 1.0E-10 )
      tauOfClust[clustIdx] ~ dgamma( 0.01 , 0.01 )
      initR[1,clustIdx] <- 1
    }
    pClust[1:Nclust] ~ ddirch( initR )
}

"
```


```{r dispersion-GaussianMixture-clustering-model, eval=FALSE, include=FALSE,ref.label='clustering-code-setup'}

initfunct <- function(nchains,N)
{
  initlist <- replicate(nchains,list(#mID=c(rbinom(N,1,0.5)), 
#                                     sigma = matrix(c (  c(runif(1,min=0,max=0.1),runif(1,min=0,max=2)),
#s                                                         c(runif(1,min=0,max=0.1),runif(1,min=0,max=15))  ),nrow=2,byrow=T  ),
#                                     mu  = matrix(c (  c( rnorm(1,mean=1,sd=sqrt(1/10) ), rnorm(1,mean=8,sd=sqrt(1/2) ) ),
#                                                        c( rnorm(1,mean=1, sd=sqrt(1/10) ) , rnorm(1,mean=30, sd=sqrt(1/0.1) )    ) )
#                                                     ,nrow=2,byrow = T  ),
                                     ".RNG.name"="base::Super-Duper",
                                     ".RNG.seed"=round(runif(1,0,60000)) ),
                                     simplify=FALSE)
  return(initlist)
}

datSubDispersion <- makeDispersionDataInferenceSet(FALSE)

vDispersion.NF.E <- datSubDispersion[datSubDispersion$groupID == 'NL',"Dispersion",]
vDispersion.LF.E <- datSubDispersion[datSubDispersion$groupID == 'LL',"Dispersion",] 
#vDispersion.NF.E <- sample(datSubDispersion[datSubDispersion$groupID == 'NL',"Dispersion",] ,min(nsubsample,NROW(datSubDispersion[datSubDispersion$groupID == 'NL',]) )  )
vDispersion.DF.E <- datSubDispersion[datSubDispersion$groupID == 'DL',"Dispersion",]

vDispersion.NF.S <- datSubDispersion[datSubDispersion$groupID == 'NE',"Dispersion",]  
vDispersion.LF.S <- datSubDispersion[datSubDispersion$groupID == 'LE',"Dispersion",]
vDispersion.DF.S <- datSubDispersion[datSubDispersion$groupID == 'DE',"Dispersion",]


runGaussianMixClusterModel <- function(vDispersion)
{
  ##Cluster Membership
  N = NROW(vDispersion)
  Nclust <- 2
  clust = rep(NA,N) 
  clust[which.min(vDispersion)]=1 # smallest value assigned to cluster 1
  clust[which.max(vDispersion)]=2 # highest value assigned to cluster 2 
  
  dataList = list(
      y = vDispersion ,
      N = N,
      Nclust = 2 ,
      clust = clust 
      #onesRepNclust = rep(1,Nclust)
  )
  ##
  ##
  steps <-500
  nchains <- 3
  nthin <- 10
  #str_vars <- c("mu","rho","sigma","x_rand") #Basic model 
  str_vars <- c("clust","pClust","muOfClust","tauOfClust") #Mixture Model
  
  # Run the 2 chains in parallel (allowing the run.jags function
  # to control the number of parallel chains). We also use a
  # mutate function to convert the precision to standard deviation:
  results <- run.jags(model=strDispersionClusterModel, n.chains=nchains,
                         inits=initfunct(nchains,dataList$N),
                         thin=nthin,
                         sample=steps,
                         data= dataList,
                         monitor=str_vars,
                         method="parallel", mutate=list("prec2sd", vars="tauOfClust"))
 return(results) 
}


results.NF.E <- runGaussianMixClusterModel(vDispersion.NF.E)
write.jagsfile(results.NF.E, file=paste0(strDataExportDir,'jagsModel_clustDispersion_NL.txt') )
save(list=c("results.NF.E","vDispersion.NF.E"),file=paste0(strDataExportDir,'jagsModelResults_clustDispersion_NL.RData') )

results.LF.E <- runGaussianMixClusterModel(vDispersion.LF.E)
write.jagsfile(results.LF.E, file=paste0(strDataExportDir,'jagsModel_clustDispersion_LL.txt') )
save(list=c("results.LF.E","vDispersion.LF.E"),file=paste0(strDataExportDir,'jagsModelResults_clustDispersion_LL.RData') )

results.DF.E <- runGaussianMixClusterModel(vDispersion.DF.E)
write.jagsfile(results.DF.E, file=paste0(strDataExportDir,'jagsModel_clustDispersion_DL.txt') )
save(list=c("results.DF.E","vDispersion.DF.E"),file=paste0(strDataExportDir,'jagsModelResults_clustDispersion_DL.RData') )

## Spont
results.NF.S <- runGaussianMixClusterModel(vDispersion.NF.S)
write.jagsfile(results.NF.S, file=paste0(strDataExportDir,'jagsModel_clustDispersion_NE.txt') )
save(list=c("results.NF.S","vDispersion.NF.S"),file=paste0(strDataExportDir,'jagsModelResults_clustDispersion_NE.RData') )

results.LF.S <- runGaussianMixClusterModel(vDispersion.LF.S)
write.jagsfile(results.LF.S, file=paste0(strDataExportDir,'jagsModel_clustDispersion_LE.txt') )
save(list=c("results.LF.S","vDispersion.LF.S"),file=paste0(strDataExportDir,'jagsModelResults_clustDispersion_LE.RData') )

results.DF.S <- runGaussianMixClusterModel(vDispersion.DF.S)
write.jagsfile(results.DF.S, file=paste0(strDataExportDir,'jagsModel_clustDispersion_DE.txt') )
save(list=c("results.DF.S","vDispersion.DF.S"),file=paste0(strDataExportDir,'jagsModelResults_clustDispersion_DE.RData') )
  
  resultsGmix.All <- runGaussianMixClusterModel(datSubDispersion$Dispersion)
  write.jagsfile(resultsGmix.All, file=paste0(strDataExportDir,'jagsModel_clustDispersion_ALL.txt') )
  save(list=c("resultsGmix.All","datSubDispersion"),file=paste0(strDataExportDir,'jagsModelResults_clustDispersion_All.RData') )


##Convergence Check
muclustNF <- as.mcmc.list(results.NF.S, vars="muOfClust")
plot(muclustNF)

# View the results using the standard print method:
#summary(results.LF.E)

```

and the clustering results  of each group/condition are summarized in the following figures:

```{r plot-functions dispersion-clustering,  fig.show='hide', out.width="33%", eval=TRUE, include=FALSE, cache=FALSE, dev='png'}
#ref.label='clustering-code-setup'
##
library(rjags)
library(runjags)
library('coda')

loadDispersionData()

## Extracts the monitor values and returns them packaged in a list
getMCMCEstimatedParams <- function(results,groupID,ichain = 2)
{
  clustcoeff = as.mcmc.list(results, vars="clust")
  tauOfClust = as.mcmc.list(results, vars="tauOfClust")
  muOfClust = as.mcmc.list(results, vars="muOfClust")
  lret <- list(
  chain =  ichain,
  groupID = groupID,
  muOfClustcoeff = muOfClust,
  tauOfClustcoeff = tauOfClust,
  mean = muOfClust[[ichain]],
  sd = cbind(tauOfClust[[ichain]][,3],tauOfClust[[ichain]][,4]), ##Take the precision converted to sd Columns 
  pClustcoeff = as.mcmc.list(results, vars="pClust"),
  clustID = round(colMeans(clustcoeff[[ichain]]) ) 
  )
  
  return (lret)
}


#  clusterIDOffset, and groupIDOffset plot Allows function to work when multiple subgroups are modelled
# by extracting from these columns pClust[groupID,Clust] : pClust[1,1] pClust[2,1] ... pClust[5,2] pClust[6,2] 
plotClusterProb <- function(lmcmcRes,clustCol,groupIDOffset=1,clustIDOffset=1)
{
   ##plot prob of occupying each cluster
  breaksProb <- seq(0,1.01,by=0.01)
  list_histo <- hist(lmcmcRes$pClustcoeff[[lmcmcRes$chain]],breaks=breaksProb,plot=FALSE )
  h1<-hist( lmcmcRes$pClustcoeff[[lmcmcRes$chain]][,groupIDOffset], breaks=breaksProb,plot=FALSE) ##Cluster 1 ylim=c(0,max(list_histo$counts))
  h2 <- hist( lmcmcRes$pClustcoeff[[lmcmcRes$chain]][,groupIDOffset + clustIDOffset], breaks=breaksProb, plot=FALSE ) ## ##Cluster 1 
  
  ##Colour Determines which Cluster is fast and slow
   barplot(rbind(h1$density,h2$density),beside = FALSE, col = c(clustCol[1],clustCol[2],"white"),
           names.arg = (h1$breaks[-length(h1$breaks)]),
           main=paste("Clustered Occupancies", lmcmcRes$groupID ),
           xlab = "Prob. of cluster membership (pClust)"
           
           )
   
   txtLeg <- c("Exploit","Explore")
   ## Make Legend order match the colour classes
   ##            being Exploit (Cyan), Explore (Yellow)
  muClustAllChain <- as.data.frame(lmcmcRes$mean)#rbind(
  if ( mean(unlist(muClustAllChain[1]) ) > mean(unlist( muClustAllChain[2]) ) )
    txtLeg<- rev(txtLeg)
  ##Add legend colouring Clusters correctly
   legend("topright",legend=txtLeg, fill=clustCol)
}

# Plot probability densities of initiating hunting within each Dispersal cluster  for each group
#  clusterIDOffset, and groupIDOffset plot Allows function to work when multiple subgroups are modelled
# by extracting from these columns pClust[groupID,Clust] : pClust[1,1] pClust[2,1] ... pClust[5,2] pClust[6,2] 
plotHuntProb <- function(lmcmcRes,clustCol,groupIDOffset=1,clustIDOffset=1)
{
  d1 <- density( lmcmcRes$pHunt[[lmcmcRes$chain]][,groupIDOffset] )
  d2 <- density(lmcmcRes$pHunt[[lmcmcRes$chain]][,groupIDOffset + clustIDOffset]) ##The Indexes are organized as such
  plot(d1, lty=1, lwd=3, col=clustCol[1],
                main=paste("Hunt initiation", lmcmcRes$groupID ),
                xlab = "Prob. of hunt initiation per cluster (pHunt)",xlim=c(0,1),ylim=c(0,max(max(max(d2$y),max(d1$y)))*1.10 ))
  lines(d2,lwd=3,lty=2,col=clustCol[2])
  
   txtLeg <- c("Exploit","Explore")
   ## Make Legend order match the colour classes
   ##            being Exploit (Cyan), Explore (Yellow)
  muClustAllChain <- as.data.frame(lmcmcRes$mean)#rbind(
  if ( mean(unlist(muClustAllChain[1]) ) > mean(unlist( muClustAllChain[2]) ) )
    txtLeg<- rev(txtLeg)
  ##Add legend colouring Clusters correctly
   legend("topright",legend=txtLeg, fill=clustCol)
}


# Colour Coded Histogram of Dispersion Data Showing plit between Exploit[1] / Explore[2]
histClusteredDispersion <- function(lmcmcRes,vDispersion,clustCol)
{
  ## Plot Clustered  Histogram 
  breaksSlots <-  seq(0,11,by=0.5)
  h0 <- hist(vDispersion, breaks=breaksSlots,plot=FALSE) # freq=TRUE,
  h1 <- hist(vDispersion[lmcmcRes$clustID == 1], breaks=breaksSlots, plot=FALSE) #xlim=c(0,10),ylim=c(0,max(h0$counts))
  h2 <- hist(vDispersion[lmcmcRes$clustID == 2], breaks=breaksSlots, plot=FALSE)  #xlim=c(0,10),
  
  barplot(rbind(h1$density,h2$density),beside = FALSE, col = c(clustCol,"white"),names.arg = (h1$breaks[-length(h1$breaks)]),main=paste("Clustered densities", lmcmcRes$groupID ),xlab = "Dispersion (mm)")
  
}


# Colour Coded Histogram of Dispersion Data  Showing plit between Exploit[1] / Explore[2] - Using Data frame as input
histClusteredDispersionFrame <- function(datSubDispersion,dispfield="Dispersion")
{
  clustCol <- c(colourClusters[1],colourClusters[2])
  ##Validate Colouring - Fast Cluster - Yellow / Slow Cluster Blue
  muC1 <- mean(datSubDispersion[datSubDispersion$clustID == 1,dispfield],na.rm = TRUE)
  muC2 <- mean(datSubDispersion[datSubDispersion$clustID == 2,dispfield],na.rm = TRUE)
  if (muC1>muC2)
    clustCol <- rev(clustCol)
  
  ## Plot Clustered  Histogram 
  upLim <- round(max(datSubDispersion[,dispfield],na.rm = TRUE))
  breaksSlots <-  seq(0,upLim*1.1,by=upLim/30)
  h0 <- hist(datSubDispersion[,dispfield], breaks=breaksSlots,plot=FALSE) # freq=TRUE,
  h1 <- hist(datSubDispersion[datSubDispersion$clustID == 1,dispfield], breaks=breaksSlots, plot=FALSE) #xlim=c(0,10),ylim=c(0,max(h0$counts))
  h2 <- hist(datSubDispersion[datSubDispersion$clustID == 2,dispfield], breaks=breaksSlots, plot=FALSE)  #xlim=c(0,10),
  
  barplot(rbind(h1$density,h2$density),beside = FALSE, col = c(clustCol,"white"),names.arg = (h1$breaks[-length(h1$breaks)]),
          main=paste("Clustered dispersion", paste(unique( datSubDispersion$groupID),collapse="," ) ),xlab = paste(dispfield))
  
}



## Plot Estimated Mean of each Gaussian
plotClusterMeans <- function(lmcmcRes,clustCol)
{
  
  #hist( mucoeff[[3]],xlim=c(0,10), breaks=20,col=colourDataScheme[[groupID]],main=groupID,xlab = "Sample Means (mm)" )  
  tauClustAllChain <- as.data.frame(lmcmcRes$var)#rbind( as.data.frame(tauOfClustcoeff[[3]]),as.data.frame(tauOfClustcoeff[[2]]),as.data.frame(tauOfClustcoeff[[1]]))
  muClustAllChain <- as.data.frame(lmcmcRes$mean)#rbind( as.data.frame(muOfClustcoeff[[3]]),as.data.frame(muOfClustcoeff[[2]]),as.data.frame(muOfClustcoeff[[1]]) )
  
  ## Plot Estimated Mean of each Gaussian
  plot(density(unlist(muClustAllChain[1]) ) ,xlim=c(0,10),col=clustCol[1],lwd=3,lty=1,main=paste("Cluster means", lmcmcRes$groupID ),xlab = "Estimated means of each cluster (mu)")
  lines(density(unlist(muClustAllChain[2]) ) ,xlim=c(0,10),col=clustCol[2],lwd=3,lty=2)

}

## Compare NegBin To Clustered Data distribution using CDF plots
plotNBFitcdf <- function(vDispersion,resParams)
{
  XLim <- 100
  x <- seq(0,XLim,1)
  ntail <- 20
  clustCol <-c(colourClusters[1],colourClusters[2])
  if ( mean(resParams$mean[,1])  > mean(resParams$mean[,2]) )
    clustCol <- rev(clustCol)
  
  cdfD_C1 <- ecdf(vDispersion[resParams$clustID == 1]*10)
  cdfD_C2 <- ecdf(vDispersion[resParams$clustID == 2]*10)
  plot(cdfD_C1,col="red",pch=5,xlab=NA,ylab=NA,main="",xlim=c(0,XLim),ylim=c(0,1))
  lines(cdfD_C2,col="blue",pch=5,xlab=NA,ylab=NA,main="",xlim=c(0,XLim),ylim=c(0,1))
  ##Construct CDF of Model by Sampling randomly from Model distribution for exp rate parameter
  for (c in 1:2) {
    for (i in (NROW(resParams$q[,1])-ntail):NROW(resParams$q[,1]) )
    {
      cdfM <- dnbinom(x,size=resParams$r[i,c],prob= resParams$q[i,c]  )##1-exp(-q*x) ##ecdf(  dexp( x, q  ) )
      lines(x,cumsum(cdfM),col=clustCol[c],lty=1) #add=TRUE,
    }
  }
  ##Model AND Data Densities
  c<-1
  plot(((dnbinom(x,size=mean(resParams$r[,c] ), prob= mean(resParams$q[,c]))  ) ), col=clustCol[c],lwd=2,main="NB Model and data distributions",xlim=c(0,XLim),ylim=c(0,2*max(cdfM)),type="l",ylab="Density",xlab="Dispersal (mm x 10)")
  lines(density(vDispersion[resParams$clustID == c]*10,na.rm=TRUE), col=clustCol[c],lty=2,lwd=3)
  #hist( dnbinom( x, size=1/mean(resParams$r[,c] ), prob = mean(resParams$q[,c]) ) ,col=colourClusters[c],freq=FALSE,breaks=20)
  #hist(vDispersion[resParams$clustID == c]*10,col=colourClusters[c],freq=FALSE,add=TRUE)
  
  c<-2
  lines((dnbinom(x,size=resParams$r[,c],prob= resParams$q[,c] )),col=clustCol[c],lwd=2)
  lines(density(vDispersion[resParams$clustID == c]*10,na.rm=TRUE),col=clustCol[c],lty=2,lwd=3)
  #hist( dnbinom(x, size=mean(resParams$r[,c] ), prob= mean(resParams$q[,c]) ) ,col=colourClusters[c],freq=FALSE)
  #hist(vDispersion[resParams$clustID == c]*10,col=colourClusters[c],freq=FALSE,add=TRUE)
  legend("topright",legend=c("NB Model","Data"),lty=c(1,2),lw=c(2,3) )
  legend("bottomright",legend=c("Exploit","Explore"),fill=colourClusters)
}

# Plot Clustering Dispersion Results #
# Colour coded Histogram, Prob of cluster membership, mean dispersion per Gaussian cluster 
plotClusterModel <- function(results, vDispersion, groupID, lmcmcRes)
{
  
  muClustAllChain <- as.data.frame(lmcmcRes$mean)#rbind(
  ## Make Colour code match Low/High Dispersal 
  ##            being Exploit (Cyan), Explore (Yellow)
  clustCol <- c(colourClusters[1],colourClusters[2])
  if ( mean(unlist(muClustAllChain[1]) ) > mean(unlist( muClustAllChain[2]) ) )
    clustCol <- rev(clustCol) ##Reverse Colour Order so C1 - has explore colour , and C2 has exploit colour

  histClusteredDispersion(lmcmcRes,vDispersion,clustCol)
  ## Plot Estimated Mean of each Gaussian
  plotClusterMeans(lmcmcRes,clustCol)
  #plot(density(muClustAllChain$`muOfClust[1]`),xlim=c(0,10),col=clustCol[1],lwd=3,lty=1,main=paste("Cluster means", groupID ),xlab = "Estimated means of each cluster (mu)")
  #lines(density(muClustAllChain$`muOfClust[2]`),xlim=c(0,10),col=clustCol[2],lwd=3,lty=2)
  
  ##plot prob of occupying each cluster
  if (groupID != "All")
    plotClusterProb(lmcmcRes,clustCol)
  #breaksProb <- seq(0,1,by=0.01)
  #list_histo <- hist(lmcmcRes$pClustcoeff[[lmcmcRes$chain]],breaks=breaksProb,main=groupID,freq = FALSE)
  #hist( lmcmcRes$pClustcoeff[[lmcmcRes$chain]][,1],xlim=c(0,1),ylim=c(0,max(list_histo$counts)), breaks=breaksProb,col=clustCol[1],xlab = "Prob. of cluster membership (pClust)" ,add=TRUE,freq=FALSE)
  #hist( lmcmcRes$pClustcoeff[[lmcmcRes$chain]][,2],xlim=c(0,1), breaks=breaksProb,col=clustCol[2],main=groupID,add=TRUE,freq=FALSE )
  
}

##plot Cluster Dists

## Evoked


#results <- results.NF.E
#vDispersion <- vDispersion.NF.S
#groupID <- "NL"

```
#### GM Cluster Dispersal Not-Fed group
```{r plot-clustering-results-NF, fig.show='hold', out.width="33%",dev='png',warnings=FALSE,cache=FALSE} 
#ref.label='plot-functions dispersion-clustering'
## Load Gaussian Mixture Clustering Results
#if (!exists("results.NF.E"))
   load(file=paste0(strDataExportDir,'jagsModelResults_clustDispersion_NL.RData') )
#if (!exists("results.NF.S"))
   load(file=paste0(strDataExportDir,'jagsModelResults_clustDispersion_NE.RData') )
#if (!exists("results.LF.E"))
   load(file=paste0(strDataExportDir,'jagsModelResults_clustDispersion_LL.RData') )
#if (!exists("results.LF.S"))
   load(file=paste0(strDataExportDir,'jagsModelResults_clustDispersion_LE.RData') )
#if (!exists("results.DF.E"))
   load(file=paste0(strDataExportDir,'jagsModelResults_clustDispersion_DL.RData') )

   load(file=paste0(strDataExportDir,'jagsModelResults_clustDispersion_DE.RData') )
#if (!exists("resultsGmix.All"))
   load(file=paste0(strDataExportDir,'jagsModelResults_clustDispersion_All.RData') )


plotClusterModel(results.NF.E,vDispersion.NF.E, "NL", getMCMCEstimatedParams(results.NF.E,"NL",2))
plotClusterModel(results.NF.S,vDispersion.NF.S, "NE", getMCMCEstimatedParams(results.NF.S,"NE",2))
```
#### GM Cluster Dispersal Life-Fed group
```{r plot-clustering-results-LF,fig.show='hold', out.width="33%",dev='png'}
plotClusterModel(results.LF.E,vDispersion.LF.E, "LL", getMCMCEstimatedParams(results.LF.E,"LL",2))
plotClusterModel(results.LF.S,vDispersion.LF.S, "LE", getMCMCEstimatedParams(results.LF.S,"LE",2))
```

#### GM Cluster Dispersal Dry-Fed group
```{r plot-clustering-results-DF,fig.show='hold', out.width="33%",dev='png'}
plotClusterModel(results.DF.E,vDispersion.DF.E,"DL",getMCMCEstimatedParams(results.DF.E,"DL",2))
plotClusterModel(results.DF.S,vDispersion.DF.S, "DE",getMCMCEstimatedParams(results.DF.S,"DE",2))
```


#### GM Cluster Dispersal *across all groups*
```{r plot-clustering-results-All,fig.show='hold', out.width="33%",dev='png'}
plotClusterModel(resultsGmix.All,datSubDispersion$Dispersion,"All",getMCMCEstimatedParams(resultsGmix.All,"All",2))
```

<!--![Clustered Dispersion DF Evoked ](`r ## knitr::fig_chunk('plot-clustering-results-DF', 'png')`)-->
<!--![Clustered Dispersion DF Spontaneous ](`r ## knitr::fig_chunk('plot-clustering-results-DF', 'png')`)-->

<!--- ![LF Evoked](`r #knitr::fig_chunk('dispersion-clustering-results', 'png',4:6)`)-->
## Clustering Using an Negative-Binomial Mixture (*NBM Model*)

Negative binomial is a integer distribution and thus for fitting we discretize the dispesion values in 0.1mm intervals. The probability mass function is 
\[
f(k;r,p)={\binom {k+r-1}{k}}p^{k}(1-p)^{r}.
\]

The idea here is to look at the dispersal length as a discrete time stochastic process generating either dispersal expansion events or events that do not expand dispersal
, thereby looking at the size of dispersal generated during Xsec as of a sum of independent bernoulli random variables. 
Each dispersal size amounts to a fixed size of $e$ steps that produced dispersal expansion and $k$ did not increase dispersion (they were inward for example).

Yet NB works on integers and our dispersal data is continuous.
There is way to convert the NB to continuous ([see](3)), as the NB distribution arises as a gamma mixture of Poisson distributions, 
\[
(y_t | \lambda_t) \sim \mathtt{Pois}(\lambda_t)
(\lambda_t | \xi,\psi_t) \sim \mathtt{Gamma}(\xi,e^{\psi_t})
\]
, whereby marginalizing over the top-level model for t, we recover a negative-binomial distribution for $y_t$
This I used in my previous paper to model hunt-rates. 

Ideally here we would need to model dispersal sizes as a continuous quantity.
The continuous NB distribution arises by replacing the Poisson distribution with its continuous analog with pdf 
\[ 
f(x;\lambda)=a(\lambda)\frac{e^{-\lambda}\lambda^x}{\Gamma(x+1)}
\]
for $x\ge0$ where $a(\lambda)$ is a normalizing constant to ensure the density integrates to 1. 

<!--From the RJags Manual-->
The  size  parameter does  not  need  to  be  an  integer.   However  when it is  an  integer,the negative binomial distribution can be interpreted in terms of a series of Bernoulli trials,i.e.independent experiments with a binary outcome where the probability of “success” isp.The number of failures that occur beforersuccesses are achieved has a negative binomialdistribution.The  negative  binomial  distribution  has  mean $r(1−p)/p$ and  variance  $(1−p)r/p^2$.   Itcollapses to a single point if eitherr= 0 orp= 1.  In this case P(Y= 0) = 1.  Conversely,the valuep= 0 is not permitted (even ifr= 0) because “success” in the Bernoulli trials isthen impossible.Both  the  binomial  and  negative  binomial  distributions  can  be  explained  in  terms  ofBernoulli  trials.
For  the  binomial  distribution the  number  of  trials  is  fixed  andthe number of success is random; *for the negative binomial the number of successes is fixed and the number of trials is random*

Thus we use \[ n[j] ~  dnegbin(q,r) \]
to model number of disperal step Hunt Events Per Larvae, and we compose a model that contains a mixture of 2 such NB distributions, one to model the small dispersal modes and one the larger (these I initially believed to be exploit/explore locomotive modes).
Each dispersal data point is assigned to a cluster with probability $P(C) \sim dCat(p_{c1},p_{c2})$.
The prior for $p_{c1/2}$ is the Dirichlet distribution, which is conjugate prior of the categorical distribution (ie. the posterior parameters of dcat, $p_{c1..2}$ are also distributed as a Dirichlet ).
This is common in these situations but needs to be *noted that the Dirichlet models a system where event X have a positive feedback*, and thus the occurance of event X increases the probability of re-occurance (auto-correlations). This maybe suitable model for Dispersions data that is close in time, but not for clustering  pooled data points across time.


```{r dispersal-RJags-NBMixture-pooledData model,include=FALSE}

strDispersionNBClusterModel <- "
var initR[1,Nclust];
model {
    # Likelihood: 
    for( i in 1 : N ) {
      # Model Number Of Dispersal expansion steps within a recent trajectory timewindow (5 sec)
      y[i] ~ dnegbin(q[clust[i] ],r[ clust[i] ]) 
      clust[i] ~ dcat( pClust[1:Nclust] )
    }
    
    #  Prior:
    for ( clustIdx in 1: Nclust ) {
      q[clustIdx]  ~ dunif(0.0,1)
      r[clustIdx] ~ dgamma(1,1)
       initR[1,clustIdx] <- 1
    }
    #
    pClust[1:Nclust] ~ ddirch( initR )
}
"

## Extracts the monitor values and returns them packaged in a list
getMCMCNBEstimatedParams <- function(results,groupID,ichain = 2,NBScaling = 1/10)
{
  clustcoeff = as.mcmc.list(results, vars="clust")
  q =  as.mcmc.list(results, vars="q")
  r =  as.mcmc.list(results, vars="r")
  lret <- list(
  chain =  ichain,
  groupID = groupID,
  q = q[[ichain]],
  r = r[[ichain]],
  mean = (1-q[[ichain]])*r[[ichain]]/(q[[ichain]])*NBScaling, ## Calc NB Mean
  sd = sqrt( (1-q[[ichain]])*r[[ichain]]/(q[[ichain]])^2)*NBScaling, ## Calc NB Var
  pClustcoeff = as.mcmc.list(results, vars="pClust"),
  clustID = round(colMeans(clustcoeff[[ichain]]) ) 
  )
  
  return (lret)
}


## Load Clustering Results
#if (!exists("results.NF.E"))

   load(file=paste0(strDataExportDir,'jagsModelResults_NBMixclustDispersion_NL.RData') )
#if (!exists("results.NF.S"))
   load(file=paste0(strDataExportDir,'jagsModelResults_NBMixclustDispersion_NE.RData') )
#if (!exists("results.LF.E"))
   load(file=paste0(strDataExportDir,'jagsModelResults_NBMixclustDispersion_LL.RData') )
#if (!exists("results.LF.S"))
   load(file=paste0(strDataExportDir,'jagsModelResults_NBMixclustDispersion_LE.RData') )
#if (!exists("results.DF.E"))
   load(file=paste0(strDataExportDir,'jagsModelResults_NBMixclustDispersion_DL.RData') )
#if (!exists("results.DF.S"))
   load(file=paste0(strDataExportDir,'jagsModelResults_NBMixclustDispersion_DE.RData') )
   load(file=paste0(strDataExportDir,'jagsModelResults_NBMixclustDispersion_All.RData') )
```

 References: 
    1. Pillow, J.W. and Scott, J., 2012. Fully Bayesian inference for neural models with negative-binomial spiking. In Advances in neural information processing systems (pp. 1898-1906).
    2. Chandra, N.K. and Roy, D., 2012. A continuous version of the negative binomial distribution. Statistica, 72(1), pp.81-92.
    3. [Stackexchange:Continuous generalization of the negative binomial distribution]( https://stats.stackexchange.com/questions/310676/continuous-generalization-of-the-negative-binomial-distribution/311927)

```{r dispersal-RJags-NBMixture-Run-model,ref.label='clustering-code-setup',include=FALSE,eval=FALSE}
## Cluster Using Negative Binomial Model
initfunct <- function(nchains,N)
{
  initlist <- replicate(nchains,list(
                                     ".RNG.name"="base::Super-Duper",
                                     ".RNG.seed"=round(runif(1,0,60000)) ),
                                     simplify=FALSE)
  return(initlist)
}

runNBMixClusterModel <- function(vDispersion)
{
  ##Make Integer Discrete
  vDispersion <- round(vDispersion*10.0)
  
  N = NROW(vDispersion)
  ##Cluster Membership
  Nclust <- 2
  clust = rep(NA,N) 
  clust[which.min(vDispersion)]=1 # smallest value assigned to cluster 1
  clust[which.max(vDispersion)]=2 # highest value assigned to cluster 2 
  
  dataList = list(
      y = vDispersion ,
      N = N,
      Nclust = 2 ,
      clust = clust 
      #onesRepNclust = rep(1,Nclust)
  )
  ##
  steps <-500
  nchains <- 3
  nthin <- 10
  #str_vars <- c("mu","rho","sigma","x_rand") #Basic model 
  str_vars <- c("clust","pClust","q","r") #Mixture Model
    # Run the 2 chains in parallel (allowing the run.jags function
  # to control the number of parallel chains). We also use a
  # mutate function to convert the precision to standard deviation:
  results <- run.jags(model=strDispersionNBClusterModel, n.chains=nchains,
                         inits=initfunct(nchains,dataList$N),
                         thin=nthin,
                         sample=steps,
                         data= dataList,
                         adapt = 1000,
                         burnin = 1000,
                         monitor=str_vars,
                         method="parallel")
 return(results) 
}

results.NF.E <- runNBMixClusterModel(vDispersion.NF.E )
write.jagsfile(results.NF.E, file=paste0(strDataExportDir,'jagsModel_NBMixclustDispersion_NL.txt') )
save(list=c("results.NF.E","vDispersion.NF.E"),file=paste0(strDataExportDir,'jagsModelResults_NBMixclustDispersion_NL.RData') )

results.LF.E <- runNBMixClusterModel(vDispersion.LF.E)
write.jagsfile(results.LF.E, file=paste0(strDataExportDir,'jagsModel_NBMixclustDispersion_LL.txt') )
save(list=c("results.LF.E","vDispersion.LF.E"),file=paste0(strDataExportDir,'jagsModelResults_NBMixclustDispersion_LL.RData') )

results.DF.E <- runNBMixClusterModel(vDispersion.DF.E)
write.jagsfile(results.DF.E, file=paste0(strDataExportDir,'jagsModel_NBMixclustDispersion_DL.txt') )
save(list=c("results.DF.E","vDispersion.DF.E"),file=paste0(strDataExportDir,'jagsModelResults_NBMixclustDispersion_DL.RData') )

## Spont
results.NF.S <- runNBMixClusterModel(vDispersion.NF.S)
write.jagsfile(results.NF.S, file=paste0(strDataExportDir,'jagsModel_NBMixclustDispersion_NE.txt') )
save(list=c("results.NF.S","vDispersion.NF.S"),file=paste0(strDataExportDir,'jagsModelResults_NBMixclustDispersion_NE.RData') )

results.LF.S <- runNBMixClusterModel(vDispersion.LF.S)
write.jagsfile(results.LF.S, file=paste0(strDataExportDir,'jagsModel_NBMixclustDispersion_LE.txt') )
save(list=c("results.LF.S","vDispersion.LF.S"),file=paste0(strDataExportDir,'jagsModelResults_NBMixclustDispersion_LE.RData') )

results.DF.S <- runNBMixClusterModel(vDispersion.DF.S)
write.jagsfile(results.DF.S, file=paste0(strDataExportDir,'jagsModel_NBMixclustDispersion_DE.txt') )
save(list=c("results.DF.S","vDispersion.DF.S"),file=paste0(strDataExportDir,'jagsModelResults_NBMixclustDispersion_DE.RData') )

## Lastly / Model and Cluster All Data so we can then run a relative comparison between groupscompare
results.All <- runNBMixClusterModel(datSubDispersion$Dispersion)
write.jagsfile(results.All, file=paste0(strDataExportDir,'jagsModel_NBMixclustDispersion_All.txt') )
save(list=c("results.All","datSubDispersion"),file=paste0(strDataExportDir,'jagsModelResults_NBMixclustDispersion_All.RData') )


#plotNBFitcdf(vDispersion.LF.S,getMCMCNBEstimatedParams(results.LF.S,"LE",2))
#resParams <- getMCMCNBEstimatedParams(results.LF.S,"LE",2)
#c<-1
#plot(density(vDispersion.LF.S[resParams$clustID == c]*10), col=colourClusters[c],lty=2,lwd=2)
#c<-2
#lines(density(vDispersion.LF.S[resParams$clustID == c]*10), col=colourClusters[c],lty=2,lwd=2)
```

### ALL NB Clustering
```{r plot-NBMix-clustering-results-All,fig.show='hold', out.width="20%",dev='png'}
plotClusterModel(results.All,datSubDispersion$Dispersion, "All",getMCMCNBEstimatedParams(results.All,"All",2))
plotNBFitcdf(datSubDispersion$Dispersion,getMCMCNBEstimatedParams(results.All,"All",2))
```

### NF NB Clustering
```{r plot-NBMix-clustering-results-NF,fig.show='hold', out.width="20%",dev='png'}
plotClusterModel(results.NF.E,vDispersion.NF.E, "NL",getMCMCNBEstimatedParams(results.NF.E,"NL",2))
plotNBFitcdf(vDispersion.NF.E,getMCMCNBEstimatedParams(results.NF.E,"NL",2))
plotClusterModel(results.NF.S,vDispersion.NF.S, "NE",getMCMCNBEstimatedParams(results.NF.S,"NE",1))
plotNBFitcdf(vDispersion.NF.S, getMCMCNBEstimatedParams(results.NF.S,"NE",1))
```

### LF NB Clustering
```{r plot-NBMix-clustering-results-LF,fig.show='hold', out.width="20%",dev='png'}
plotClusterModel(results.LF.E,vDispersion.LF.E, "LL",getMCMCNBEstimatedParams(results.LF.E,"LL",1))
plotNBFitcdf(vDispersion.LF.E,getMCMCNBEstimatedParams(results.LF.E,"LL",3))
plotClusterModel(results.LF.S,vDispersion.LF.S, "LE",getMCMCNBEstimatedParams(results.LF.S,"LE",3))
plotNBFitcdf(vDispersion.LF.S,getMCMCNBEstimatedParams(results.LF.S,"LE",3))
```

### DF NB Clustering
```{r plot-NBMix-clustering-results-DF,fig.show='hold', out.width="20%",dev='png'}
plotClusterModel(results.DF.E,vDispersion.DF.E, "DL",getMCMCNBEstimatedParams(results.DF.E,"DL",2))
plotNBFitcdf(vDispersion.DF.E,getMCMCNBEstimatedParams(results.DF.E,"DL",2))
plotClusterModel(results.DF.S,vDispersion.DF.S, "DE",getMCMCNBEstimatedParams(results.DF.S,"DE",2))
plotNBFitcdf(vDispersion.DF.S,getMCMCNBEstimatedParams(results.DF.S,"DE",2))
```



## Clustering across all larval dispersion data using NB mix  - (Global Clustering reference frame)

To compare differences in dispersal between groups it would be best to define consistent models for the clusters that define the exploration and exploitation state by using data across groups. 
From there we may then compare the relative occupancy in each state depending on test condition and rearing group, such that we can detect changes in behaviour relevant to a global frame of reference. Aims:
  - Define a clusters for exploit and exploration dispersal using NB model on all data. 
  - infer cluster occupancy of each condition/group #
      - Define separate pClust for each condition/group (n=6)
  - infer mean exploration and explotation dispersals for each group/condition

Here, instead of clustering each experimental condition/group separatelly, I cluster all the (discretized x10) dispersion data together using a mixture of 2 NB distributions, such that we infer global reference on which to classify exploit/explore dispersal motion patterns. 
To compare the dispersal behaviour between groups-conditions, I also infer the probability of a dispersion being clustered as as exploit/explore (small/large) for each group-condition. 

  
```{r dispersal-RJags-Global-model,include=TRUE}
#ref.label='clustering-code-setup'
  strDispersionGroupClusterModel <- "
  var initR[1,Nclust];
model {
    
     # Likelihood: 
    for( i in 1 : N ) {
      # Model Number Of Dispersal expansion steps within a recent trajectory timewindow (5 sec)
      y[i] ~ dnegbin( q[clust[i] ], r[ clust[i] ] ) 
      clust[i] ~ dcat( pClust[groupID[i],1:Nclust] )
      huntMode[i] ~  dbern( pHunt[ groupID[i],clust[i] ] ) 
    }
    
    # Top Level Prior:
    for ( clustIdx in 1: Nclust ) {
      q[clustIdx]  ~ dunif(0.0,1)
      r[clustIdx]  ~ dgamma(1,1)
      initR[1,clustIdx] <- 1
    }
    
    ## Make Separate Prob Cluster priors for each group/condition
    for ( g in 1: 6 ) {
      pClust[g,1:Nclust] ~ ddirch( initR )
      pHunt[ g,1 ] ~ dunif(0.0,1) ##Prob Of Hunt Init Per Cluster for each Group
      pHunt[ g,2 ] ~ dunif(0.0,1) ##Prob Of Hunt Init Per Cluster for each Group
    }
  
    
}

"

## Extracts the monitor values and returns them packaged in a list
getMCMCNBGroupEstimatedParams <- function(results,groupID,ichain = 2,NBScaling = 1/10)
{
  clustcoeff = as.mcmc.list(results, vars="clust")
  q =  as.mcmc.list(results, vars="q")
  r =  as.mcmc.list(results, vars="r")
  NBmean = (1-q[[ichain]])*r[[ichain]]/(q[[ichain]])*NBScaling ## Calc NB Mean
  
  ## Make Colour code match Low/High Dispersal 
  ##            being Exploit (Cyan), Explore (Yellow)
  clustCol <- c(colourClusters[1],colourClusters[2])
  if ( mean(unlist(NBmean[,1]) ) > mean(unlist( NBmean[,2]) ) )
    clustCol <- rev(clustCol) ##Reverse Colour Order so C1 - has explore colour , and C2 has exploit colour

  lret <- list(
  chain =  ichain,
  groupID = groupID,
  q = q[[ichain]],
  r = r[[ichain]],
  mean = NBmean,
  sd = sqrt( (1-q[[ichain]])*r[[ichain]]/(q[[ichain]])^2)*NBScaling, ## Calc NB Var
  pClustcoeff = as.mcmc.list(results, vars="pClust"),
  pHunt = as.mcmc.list(results, vars="pHunt"),
  clustID = round(colMeans(clustcoeff[[ichain]]) ),
  clustCol = clustCol
  )
  
  return (lret)
}

bQuickTest = FALSE
strOutFilename <- "jagsModelResults_NBMixGroupclustDispersionAndHuntEvents_All"

##Quicker Test - Subsampling
if (bQuickTest){
     strOutFilename <- "jagsModelResults_NBMixTestGroupclustDispersionAndHuntEvents_All2"
}

load(file=paste0(strDataExportDir,'jagsModelResults_NBMixGroupclustDispersionAndHuntEvents_All3.RData') )
```


```{r dispersal-RJags-NBMixture-Global-Run-model,include=FALSE,eval=FALSE}
## Cluster Using Negative Binomial Model

initfunct <- function(nchains,N)
{
  initlist <- replicate(nchains,list(
                                     ".RNG.name"="base::Super-Duper",
                                     ".RNG.seed"=round(runif(1,0,60000)) ),
                                     simplify=FALSE)
  return(initlist)
}


runNBMixGroupClusterModel <- function(vDispersion,vHuntInitiation,vGroupID, bQuickTest = TRUE)
{

  ##Make Integer Discrete
  vDispersion <- round(vDispersion*10.0)
  
  N = NROW(vDispersion)
  ##Cluster Membership
  Nclust <- 2
  clust = rep(NA,N) 
  clust[which.min(vDispersion)]=1 # smallest value assigned to cluster 1
  clust[which.max(vDispersion)]=2 # highest value assigned to cluster 2 
  
  dataList = list(
      y = vDispersion ,
      huntMode = vHuntInitiation,
      groupID = vGroupID,
      N = N,
      Nclust = 2 ,
      clust = clust
      #onesRepNclust = rep(1,Nclust)
  )
  ##
  nsteps <- 500 #500
  nadapt <- 2000 #500
  nburnin <- 2000 #500
  nchains <- 9
  
  if (bQuickTest)
  {
    nsteps <- 200 #
    nadapt <- 1000 #
    nburnin <- 1000 #
    nchains <- 3
  }

  
  nthin <- 10
  #str_vars <- c("mu","rho","sigma","x_rand") #Basic model 
  str_vars <- c("clust","pClust","pHunt","q","r") #Mixture Model
    # Run the chains in parallel (allowing the run.jags function
  # to control the number of parallel chains). We also use a
  #The advantage of the 'rjags' method is that the model will not need to be recompiled between successive calls to extend.jags, all other methods require a   re-compilation (and adaptation if necessary) every time the model is extended. 
  #Note that the 'rjparallel' and 'snow' methods may leave behind zombie JAGS processes
    results <- run.jags(model=strDispersionGroupClusterModel, n.chains=nchains,
                         inits=initfunct(nchains,dataList$N),
                         data= dataList,
                         thin=nthin,
                         sample=nsteps,
                         adapt = nadapt,
                         burnin = nburnin,
                         monitor=str_vars,
                         method="rjparallel")
 return(results) 
}

# add the frames of hunt events for easier classification of hunt events : datHEventDispersion$frameRow
##Subsample The Dispersion Data into 0.5 sec bins - But Add the hunt Event Frames

datSubDispersion <- makeDispersionDataInferenceSet(bQuickTest,10000) 
results.All <- runNBMixGroupClusterModel(datSubDispersion$Dispersion,
                                         datSubDispersion$HuntMode,
                                         as.numeric(datSubDispersion$groupID),
                                         bQuickTest = bQuickTest)

write.jagsfile(results.All, file=paste0(strDataExportDir,strOutFilename,'.txt') )
save(list=c("results.All","datSubDispersion"),file=paste0(strDataExportDir,strOutFilename,'.RData') )
#Run or Extend a User Specified Bayesian MCMC Model in JAGS with Automatically Calculated Run Length and Convergence Diagnostics
results.All <- autoextend.jags(results.All,max.time = "1hr")
save(list=c("results.All","datSubDispersion"),file=paste0(strDataExportDir,strOutFilename,'.RData') )
#extend.jags(results.All, sample = 1000) #Using rjags allows extending without recompiling
  
##Run model From File
#results.All <- run.jags(paste0(strDataExportDir,strOutFilename,'.txt'))

```

### Results from NB global clustering 

I find that **there are clear differences in movement behaviour between the rearing groups**, and how these modify their motion behaviour between spontaneous and evoked conditions. 

  - NF : Evidence for bimodality are not clear, while forcing 2 clusters shows time split almost equally in fast/slow
  - DF, LF show bimodal dispersions in both Evoked and spontaneous conditions but:
    - DF modes could be simply no movement vs Moving
    - LF shows a mode of slow/low dispersal motion and another that is large dispersal - in agreement with Marquez et al. 2019
  
```{r plot-NBMix-Globalclustering-results-All, fig.show='hold', out.width="33%",dev='png'}
#,ref.label='dispersal-RJags-Global-model'
lparamsAll <- getMCMCNBGroupEstimatedParams(results.All,"All",2)
if (!("clustID" %in% names(datSubDispersion))) 
  datSubDispersion$clustID <- as.vector(lparamsAll$clustID)

clustCol <- c(colourClusters[1],colourClusters[2])
##Validate Colouring - Fast Cluster - Yellow / Slow Cluster Blue
muC1 <- mean(datSubDispersion[datSubDispersion$clustID == 1,"Dispersion"],na.rm = TRUE)
muC2 <- mean(datSubDispersion[datSubDispersion$clustID == 2,"Dispersion"],na.rm = TRUE)
if (muC1>muC2)
  clustCol <- rev(clustCol)

# Show Count Of Hunt Events Per Cluster Per Exp. Condition
barplot((table(datSubDispersion$clustID,datSubDispersion$groupID)*nsubsampleInterval/G_APPROXFPS)/60,
        col=clustCol,
        main="Recording minutes per cluster/cond-group",ylab="Recording time (min)",xlab=)
legend("topleft",legend=( paste( round(table(datSubDispersion$clustID)*nsubsampleInterval/G_APPROXFPS/60), "min.")   ) , fill=clustCol  )


## Sanity Check The cluster with Most Hunt Events (Appears to Be )
boxplot(Dispersion ~ clustID*groupID,data=datSubDispersion,col=clustCol,  main="Dispersion per cluster",ylab="Dispersion (mm)")
legend("topleft",legend=( paste( round(table(datSubDispersion$clustID)*nsubsampleInterval/G_APPROXFPS/60), "min.")   ) , fill=clustCol  )


## Plot Histy And Cluster Memberships
plotClusterModel(results.All,datSubDispersion$Dispersion, "All",lparamsAll)
plotNBFitcdf(datSubDispersion$Dispersion,lparamsAll)


```



#### Spontaneous
  * NF bimodality is not clear, best do model comparison 
  * DF, LF show bimodality - but the slow cluster is not the same between the groups/ DF - likely either stops or runs.
 
```{r plot-NBMix-Groupclustering-results-Spontaneous,fig.show='hold', out.width="33%",dev='png', include=TRUE,eval=TRUE}

lparamsAll$groupID = "NE"
plotGroup<- which(levels(datSubDispersion$groupID)==lparamsAll$groupID)
plotClusterProb(lparamsAll,lparamsAll$clustCol ,plotGroup,6)
lparamsAll$groupID = "LE"
plotGroup<- which(levels(datSubDispersion$groupID)==lparamsAll$groupID)
plotClusterProb(lparamsAll,lparamsAll$clustCol,plotGroup,6)
lparamsAll$groupID = "DE"
plotGroup<- which(levels(datSubDispersion$groupID)==lparamsAll$groupID)
plotClusterProb(lparamsAll,lparamsAll$clustCol,plotGroup,6)

##Show Histograms of Raw Dispersion Clustered for each group
histClusteredDispersionFrame(datSubDispersion[datSubDispersion$groupID == 'NE',])
histClusteredDispersionFrame(datSubDispersion[datSubDispersion$groupID == 'LE',])
histClusteredDispersionFrame(datSubDispersion[datSubDispersion$groupID == 'DE',])

histClusteredDispersionFrame(datSubDispersion[datSubDispersion$groupID == 'NE',],"Dispersion_larval_norm")
histClusteredDispersionFrame(datSubDispersion[datSubDispersion$groupID == 'LE',],"Dispersion_larval_norm")
histClusteredDispersionFrame(datSubDispersion[datSubDispersion$groupID == 'DE',],"Dispersion_larval_norm")



```
#### Evoked
```{r plot-NBMix-Groupclustering-results-Evoked,fig.show='hold', out.width="33%",dev='png',include=TRUE,eval=TRUE}

lparamsAll <- getMCMCNBGroupEstimatedParams(results.All,"All",2)
lparamsAll$groupID = "NL"
plotGroup<- which(levels(datSubDispersion$groupID)==lparamsAll$groupID)
plotClusterProb(lparamsAll,lparamsAll$clustCol ,plotGroup,6)
lparamsAll$groupID = "LL"
plotGroup<- which(levels(datSubDispersion$groupID)==lparamsAll$groupID)
plotClusterProb(lparamsAll,lparamsAll$clustCol,plotGroup,6)
lparamsAll$groupID = "DL"
plotGroup<- which(levels(datSubDispersion$groupID)==lparamsAll$groupID)
plotClusterProb(lparamsAll,lparamsAll$clustCol,plotGroup,6)

histClusteredDispersionFrame(datSubDispersion[datSubDispersion$groupID == 'NL',])
histClusteredDispersionFrame(datSubDispersion[datSubDispersion$groupID == 'LL',])
histClusteredDispersionFrame(datSubDispersion[datSubDispersion$groupID == 'DL',])

histClusteredDispersionFrame(datSubDispersion[datSubDispersion$groupID == 'NL',],"Dispersion_larval_norm")
histClusteredDispersionFrame(datSubDispersion[datSubDispersion$groupID == 'LL',],"Dispersion_larval_norm")
histClusteredDispersionFrame(datSubDispersion[datSubDispersion$groupID == 'DL',],"Dispersion_larval_norm")

```

## Path length and dispersion ratio distributions 

Within Low dispersions hides a locomotive behaviour of pause, where the larva is not actually moving. We want to explore how experience modifies their locomotion strategy and thus this is best done by examining dispersion in relation to the distance travelled. Particularly I will look into a a state of locomotion pause, when the larva stop moving. 

Thus, similar to the measure of dispersion, we plot the 5sec recent trajectory lengths over all movement and over hunt event initiations, side by side:
### Distributions of path length


```{r length histograms per group across conditions, fig.show="hold", out.width="50%", echo=FALSE, results='hide'  }
loadDispersionData()
xbreaks <-seq(0,max(datDispersion$Length,na.rm=TRUE)+1,2)
h_Length_LE <- hist(datDispersion[datDispersion$groupID %in% c('LE'), ]$Length,breaks=xbreaks,main="LF Spont.",xlab="Length (mm)",col=colourDataScheme$LF$Spont)
hist(datHEventDispersion[datHEventDispersion$groupID=='LE', ]$Length,breaks=xbreaks,main="LF Spont Hunt-events",xlab="Length ",col=colourDataScheme$LF$Spont)


h_Length_LL <- hist(datDispersion[datDispersion$groupID %in% c('LL'), ]$Length,breaks=xbreaks,main="LF Evoked.",xlab="Length (mm)",col=colourDataScheme$LF$Evoked)
hist(datHEventDispersion[datHEventDispersion$groupID=='LL', ]$Length,breaks=xbreaks,main="LF Evoked Hunt-events",xlab="Length ",col=colourDataScheme$LF$Evoked)

h_Length_NE <- hist(datDispersion[datDispersion$groupID %in% c('NE'), ]$Length,breaks=xbreaks,main="NF Spont.",xlab="Length (mm)",col=colourDataScheme$NF$Spont)
hist(datHEventDispersion[datHEventDispersion$groupID=='NE', ]$Length,breaks=xbreaks,main="NF Spont Hunt-events",xlab="Length",col=colourDataScheme$NF$Spont)

h_Length_NL <- hist(datDispersion[datDispersion$groupID %in% c('NL'), ]$Length,breaks=xbreaks,main="NF Evoked.",xlab="Length (mm)",col=colourDataScheme$NF$Evoked)
hist(datHEventDispersion[datHEventDispersion$groupID=='NL', ]$Length,breaks=xbreaks,main="NF Evoked Hunt-events",xlab="Length",col=colourDataScheme$NF$Evoked)


h_Length_DE <- hist(datDispersion[datDispersion$groupID %in% c('DE'), ]$Length,breaks=xbreaks,main="DF Spont.",xlab="Length (mm)",col=colourDataScheme$DF$Spont)
hist(datHEventDispersion[datHEventDispersion$groupID=='DE', ]$Length,breaks=xbreaks,main="DF Spont Hunt-events",xlab="Length",col=colourDataScheme$DF$Spont)

h_Length_DL <- hist(datDispersion[datDispersion$groupID %in% c('DL'), ]$Length,breaks=xbreaks,main="DF Evoked.",xlab="Length (mm)",col=colourDataScheme$DF$Evoked)
hist(datHEventDispersion[datHEventDispersion$groupID=='DL', ]$Length,breaks=xbreaks,main="DF Evoked Hunt-events",xlab="Length",col=colourDataScheme$DF$Evoked)

```

Comparing between general and hunt-event lengths it appears:
  - path lengths can be bimodal, like dispersions, in spontaneous conditions
  - LF Show higher motility to controls in both conditions
  - LF Spont. Shows overal higher motility to controls- Low occupancy in small movement mode
  - Locomotion in Evoked conditions  shows higher motility, and motion range, than Spontaneous. 
  - Evoked Hunt events occur over the higher movement sub range than the one observed overall   

To better examine tendencies to move towards dispersing trajectories we need to account for the effect of general motion, ie the length of a trajectory.
Here I examine recent dispersion as a ratio of recent trajectory length (5 sec window). A ration of 0.5 means larva moved in a straight line, as dispersal is the *radius* not the diameter of the  circle encompassing the recent trajectory

I next plot on logarithmic scale the percentage of each Path length and try to see if a power law like regime exists in the distribution, but also if the presence of prey changes the linear - drop off regime of the distribution. This is inspired by Fig 3 from Viswanathan et al 1999

```{r length log distributions conditions, fig.show="hold", out.width="33%", echo=FALSE, results='hide' ,warning=FALSE }
##DY DX
getLogPowerSlope <- function (h_Length_G, length_lin_region = 10)
{ ##linear Region
  idxFrom <- 7
  idxTo <- 11
 # mu<-log10( (100*h_Length_G$counts/sum(h_Length_G$counts))[idxFrom] - (100*h_Length_G$counts/sum(h_Length_G$counts))[idxTo]  /  (h_Length_G$mids[idxTo]-h_Length_G$mids[idxFrom]) )
  
  
  datHist <- data.frame(length=log10(h_Length_G$mids), proportion=log10(100*h_Length_G$counts/sum(h_Length_G$counts) ) )
  linFit <- lm(proportion~length,data=datHist[!is.infinite(datHist$proportion) & 10^datHist$length >=length_lin_region ,] )
  
  y_linModel <- (linFit$coefficients[1] + (linFit$coefficients[2]* (linFit$model$length ) ) )
  x_linModel <- linFit$model$length

#return (round(mu*100)/100 )
return(list(coeff=linFit$coefficients[2],ptx_line=x_linModel,pty_line=y_linModel) )
}

#,log="xy" 
lLinModel_NE <- getLogPowerSlope(h_Length_NE,10)
lLinModel_NL <- getLogPowerSlope(h_Length_NL,10)
plot(log10(h_Length_NE$mids),log10(100*h_Length_NE$counts/sum(h_Length_NE$counts) ),main=paste("NF Log-Log percentage of lengths " ),xlab="log Length (mm)",col=colourDataScheme$NF$Spont,pch=16,xlim=c(0,2.0),ylim=c(-4,3), ylab="log N(l) %")
points(log10(h_Length_NL$mids),log10(100*h_Length_NL$counts/sum(h_Length_NL$counts) ),
       #main=paste("NF Evoked. mu:",getLogPowerSlope(h_Length_NL)), 
       xlab="Length (mm)",col=colourDataScheme$NF$Evoked,pch=16)
lines(lLinModel_NE$ptx_line,lLinModel_NE$pty_line,lwd=3,col=colourDataScheme$NF$Spont)

lines(lLinModel_NL$ptx_line,lLinModel_NL$pty_line,lwd=3,col=colourDataScheme$NF$Evoked)
legend("topright",legend=c(paste("Spont μ",format(lLinModel_NE$coeff,digits=2)),paste("Evoked μ",format(lLinModel_NL$coeff,digits=2) ) ),col=c(colourDataScheme$NF$Spont,colourDataScheme$NF$Evoked) ,pch=c(16,16) )


#,log="xy" 
lLinModel_LE <- getLogPowerSlope(h_Length_LE,14)
lLinModel_LL <- getLogPowerSlope(h_Length_LL,14)
plot(log10(h_Length_LE$mids),log10(100*h_Length_LE$counts/sum(h_Length_LE$counts) ),main=paste("LF Log-Log percentage of lengths " ),xlab="log Length (mm)",col=colourDataScheme$LF$Spont,pch=16,xlim=c(0,2.0),ylim=c(-4,3), ylab="log N(l) %")
points(log10(h_Length_LL$mids),log10(100*h_Length_LL$counts/sum(h_Length_LL$counts) ),
       #main=paste("NF Evoked. mu:",getLogPowerSlope(h_Length_NL)), 
       xlab="Length (mm)",col=colourDataScheme$LF$Evoked,pch=16)
lines(lLinModel_LE$ptx_line,lLinModel_LE$pty_line,lwd=3,col=colourDataScheme$LF$Spont)
lines(lLinModel_LL$ptx_line,lLinModel_LL$pty_line,lwd=3,col=colourDataScheme$LF$Evoked)
legend("topright",legend=c(paste("Spont μ",format(lLinModel_LE$coeff,digits=2)), paste("Evoked μ",format(lLinModel_LL$coeff,digits=2) ) ),col=c(colourDataScheme$LF$Spont,colourDataScheme$LF$Evoked) ,pch=c(16,16) )



lLinModel_DE <- getLogPowerSlope(h_Length_DE,10)
lLinModel_DL <- getLogPowerSlope(h_Length_DL,10)
plot(log10(h_Length_DE$mids),log10(100*h_Length_DE$counts/sum(h_Length_DE$counts) ),main=paste("DF Log-Log percentage of lengths " ),xlab="log Length (mm)",col=colourDataScheme$DF$Spont,pch=16,xlim=c(0,2.0),ylim=c(-4,3), ylab="log N(l) %")
points(log10(h_Length_DL$mids),log10(100*h_Length_DL$counts/sum(h_Length_DL$counts) ),
       #main=paste("NF Evoked. mu:",getLogPowerSlope(h_Length_NL)), 
       xlab="Length (mm)",col=colourDataScheme$DF$Evoked,pch=16)
lines(lLinModel_DE$ptx_line,lLinModel_DE$pty_line,lwd=3,col=colourDataScheme$DF$Spont)
lines(lLinModel_DL$ptx_line,lLinModel_DL$pty_line,lwd=3,col=colourDataScheme$DF$Evoked)
legend("topright",legend=c(paste("Spont μ",format(lLinModel_DE$coeff,digits=2)), paste("Evoked μ",format(lLinModel_DL$coeff,digits=2) ) ),col=c(colourDataScheme$DF$Spont,colourDataScheme$DF$Evoked) ,pch=c(16,16) )

```

I have fitted a standard linear model on the log-log relationship at the drop off, where power-law like relationship appears on the data. 
No Differences between test conditions can be seen for NF, and generally the linear/ power law like exponent of drop-off is very similar between conditions, unlike the foraging examples reported in Viswanathan et al. 1999. 
This is not over a fixed radius boundary however, but over all paths. I will  look at this question for specific dispersion sizes in future section, first I look at the 
ratio of dispersion to path-lenth ratio, and find evidence of structure and difference between spont. and evoked events.

## Path-lenth to dispersion ratios

```{r  hunt-event-length-dispersion ratios histograms , fig.show="hold", out.width="50%", echo=FALSE, cache=TRUE }
## Normalized Dispersion In Hunt Events
nBreaks <-seq(0,0.5,0.02)
xbreaks <-seq(0,0.5,0.02)

## Check NF
hist(datDispersion[datDispersion$groupID %in% c('NE'), ]$Dispersion/ datDispersion[datDispersion$groupID %in% c('NE'), ]$Length,
     breaks=xbreaks,main="NF Spont.",xlab="Dispersion/Length ",col=colourDataScheme$NF$Spont)

hist(datHEventDispersion[datHEventDispersion$groupID=='NE', ]$Dispersion/datHEventDispersion[datHEventDispersion$groupID=='NE', ]$Length,
     breaks=nBreaks,main="NF Spont Hunt-events",xlab="Length",col=colourDataScheme$NF$Spont)

hist(datDispersion[datDispersion$groupID %in% c('NL'), ]$Dispersion/ datDispersion[datDispersion$groupID %in% c('NL'), ]$Length,
     breaks=xbreaks,main="NF Evoked",xlab="Dispersion/Length ",col=colourDataScheme$NF$Evoked)

hist(datHEventDispersion[datHEventDispersion$groupID=='NL', ]$Dispersion/datHEventDispersion[datHEventDispersion$groupID=='NL', ]$Length,
     breaks=nBreaks,main="NF Evoked Hunt-events",xlab="Length",col=colourDataScheme$NF$Evoked)


## Check LF
#'Spont
hist(datDispersion[datDispersion$groupID %in% c('LE'), ]$Dispersion/ datDispersion[datDispersion$groupID %in% c('LE'), ]$Length,
     breaks=xbreaks,main="LF Spont.",xlab="Dispersion/Length ",col=colourDataScheme$LF$Spont)

hist(datHEventDispersion[datHEventDispersion$groupID=='LE', ]$Dispersion/datHEventDispersion[datHEventDispersion$groupID=='LE', ]$Length,
     breaks=nBreaks,main="LF Spont Hunt-events",xlab="Length ",col=colourDataScheme$LF$Spont)

## Evoked
hist(datDispersion[datDispersion$groupID %in% c('LL'), ]$Dispersion/ datDispersion[datDispersion$groupID %in% c('LL'), ]$Length,
     breaks=xbreaks,main="LF Evoked.",xlab="Dispersion/Length ",col=colourDataScheme$LF$Evoked)

hist(datHEventDispersion[datHEventDispersion$groupID=='LL', ]$Dispersion/datHEventDispersion[datHEventDispersion$groupID=='LL', ]$Length,
     breaks=nBreaks,main="LF Evoked Hunt-events",xlab="Length ",col=colourDataScheme$LF$Evoked)


## Check DF
hist(datDispersion[datDispersion$groupID %in% c('DE'), ]$Dispersion/ datDispersion[datDispersion$groupID %in% c('DE'), ]$Length,
     breaks=xbreaks,main="DF Spont.",xlab="Dispersion/Length ",col=colourDataScheme$DF$Spont)

hist(datHEventDispersion[datHEventDispersion$groupID=='DE', ]$Dispersion / datHEventDispersion[datHEventDispersion$groupID=='DE', ]$Length,
     breaks=nBreaks,main="DF Spont Hunt-events",xlab="Length",col=colourDataScheme$DF$Spont)

hist(datDispersion[datDispersion$groupID %in% c('DL'), ]$Dispersion/ datDispersion[datDispersion$groupID %in% c('DL'), ]$Length,
     breaks=xbreaks,main="DF Evoked",xlab="Dispersion/Length ",col=colourDataScheme$DF$Evoked)

hist(datHEventDispersion[datHEventDispersion$groupID=='DL', ]$Dispersion/datHEventDispersion[datHEventDispersion$groupID=='DL', ]$Length,breaks=nBreaks,main="DF Evoked Hunt-events",xlab="Length",col=colourDataScheme$DF$Evoked)


BW=0.1
```

These distribution are interesting as they show some well defined structure, especially in spontaneous conditions. They could underly some general well known movement/exploration strategy, which I need to look for.

Generally, lower ratios are indicative of turtuous paths of low dispersion, ie where the larva moves but is generally constrained to the same region.

  - In all trajectories the higherst ratio - indicating straight motion- has the higher occupancy
  - Across groups, evoked conditions augment the frequency of low ratios, ie low dispersion movement
  - Ratios over hunt-event initiation suggest that low-dispersal frequencies are relativelly over represented compared to general motility in evoked conditions, but not in spontaneous conditions, ie spontaneous events occur randomly across general motion, in evoked conditions low dispersion motion appears favouroble to hunt-event initiation. 


## Path length per dispersion size

### Mean Path length scales with dispersion
*Evidence of invariance*
For example, take a random walk until it hits a circle of radius r times the step length. The average number of steps it performs is $r^2$.[citation needed] 
This fact is the discrete version of the fact that a Wiener process walk is a fractal of Hausdorff dimension 2.[citation needed]

For random walks, the mean length $<s>$ does not depend on the characteristic mean free path ℓ, but only on the ratio between the surface A and the perimeter C—that is $<s>=\pi A/C$
Thus the corresponding mean values are constrained by the sole free surface to perimeter ratio (see
[1](https://science.sciencemag.org/content/358/6364/765/tab-figures-data) [2](https://www.nature.com/articles/s41467-019-10455-y) ).

To see such an *invariance principle holds* (see)[https://iopscience.iop.org/article/10.1209/epl/i2003-00208-x/meta], where by the mean path length is only proportional to the Area/Circumfarence ratio for a random walk,  I look at mean path lengths for a set of fixed dispersion sizes:

```{r  path-length per dispersion , fig.show="hold", out.width="50%", echo=FALSE, cache=TRUE }
## iNvariance Principle Theoretical Mean Path Length
theoreticalMeanLength <- function(D,propFactor=1.5)
{
  A <- pi*( (D)^2)
  C <- 2*pi*(D)
  return(round(100*(propFactor* pi*A/C)) /100 )
}
## Plot mean path length for each boundary dispersion size 
# This is to examine the similarity to the random walk invariance principle by which the mean pathlength within a circle of radius r is proportional to pi*A/C
# ie legth to hit the boundary of the observation circle, is only proportional to the circle (in 2D), volume in 3D- 
plot_meanPathLengthPerDispersion <- function(datDispersion,strGroupID)
{
  datGroupDispersion <- datDispersion[datDispersion$groupID %in% strGroupID,]
  dispBreaks <- seq(1,11,0.3)
  datGroupDispersion$dispRange <- cut(datGroupDispersion[datGroupDispersion$groupID %in% strGroupID ,"Dispersion" ],breaks=dispBreaks)
  strTitle <- paste("Mean path length per dispersion", strGroupID,"#",NROW(datGroupDispersion$dispRange))
  
  vmeanPathLengthPerDispersion <- tapply(datGroupDispersion$Length,datGroupDispersion$dispRange,mean,na.rm=TRUE)
  plot(seq(1,10.5,length.out = NROW(vmeanPathLengthPerDispersion)), vmeanPathLengthPerDispersion,pch=16,main=strTitle,xlab="Circle radius / Dispersion (mm)",
       ylim=c(0,25),xlim=c(0,11),col=colourDataScheme[[strGroupID]] )
  rpoints <- seq(0.5,10.5, length.out = NROW(vmeanPathLengthPerDispersion) )
  points(rpoints,theoreticalMeanLength(rpoints ),pch=2,cex=0.8 ) #Low Lim
  points(seq(2,12,1),theoreticalMeanLength(seq(2,12,1) ),pch=2,cex=0.5 ) #Up Lim
  points(seq(1,11,1),theoreticalMeanLength(seq(1,11,1) ),pch=2,cex=0.5 ) #Up Lim
  legend("topleft",pch=c(16,2),legend=c("Data","Theory"),col=c(colourDataScheme[[strGroupID]],"black") )
  
  #boxplot(datGroupDispersion$Length~datGroupDispersion$dispRange,main=strTitle,col=colourDataScheme[[strGroupID]],ylim=c(0,35))
}

## Take Group 
plot_meanPathLengthPerDispersion(datDispersion,'NE')
plot_meanPathLengthPerDispersion(datDispersion,'NL')

plot_meanPathLengthPerDispersion(datDispersion,'LE')
plot_meanPathLengthPerDispersion(datDispersion,'LL')

plot_meanPathLengthPerDispersion(datDispersion,'DE')
plot_meanPathLengthPerDispersion(datDispersion,'DL')

```


I find that the length of every path contained in a dispersion circle with radius $r$ increases linearly with $r$, specifically the relationship appears to be :
\[
<s> = \frac{3\pi}{2}  \frac{\pi r^2}{2 \pi r}
\]
but why? some invariance principle seems to hold similar to the one reported in @blanco2003invariance, at least clearly so in the absence of prey.
In the presence of prey this linear relationship deviates somewhat, showing that path lengths increase - most likely as a result of hunting events. 
 This way of looking at such path-data is new. Usually mean free paths are measured, as the path between two changes in direction, or the time of entry and exit from a circle bound area.
 It may well have been that path-length would scaling as the $<s> \approx  r^2$, but instead, at least without prey, we find that it scales with $r$, which here is the dispersion radius containing the path.
 I need to investigate further what this means, and whether it amounts to paths being diffusion/random walks or Levy processes.
 

I next look at the Log-Log distribution of path-lengths for a specified dispersion boundary. 
*Note:* This is not equivalent to looking at the exit time, or time to hit boundary as in the Levy type investigations, becauce here all paths chosen have produced a specific dispersal and it is not that we are looking a the escape from random starting point within the cycle, or the mean escape time upon entering an area nor the mean time to hit two target sites (food items) as in FIG 3 (Viswanathan et al. 2009).

Nevertheless we expect to see that the addition of prey should increase the path-lengths even among paths with the same Dispersion, as response to prey/ prey detection should make paths more turtuous.

##  path-length Log-Log distribution per *specific dispersion*
```{r  path-length for dispersion log-log distribution , fig.show="hold", out.width="33%", echo=FALSE, cache=TRUE }
#,log="xy" 

plotLogLogPathLengthForFixedDispersion  <- function(datDispersion,strGroupID,dispRange = 10)
{
    datGroupDispersion <- datDispersion[datDispersion$groupID %in% strGroupID,]
    dispBreaks <- seq(1,11,0.3)
    datGroupDispersion$dispRange <- cut(datGroupDispersion[datGroupDispersion$groupID %in% strGroupID ,"Dispersion" ],breaks=dispBreaks)
    strTitle <- paste("Path length per dispersion", strGroupID,"#",NROW(datGroupDispersion$dispRange))

    xbreaks <-seq(0,max(datDispersion$Length,na.rm=TRUE)+1,2)
    strDispRange <-levels(datGroupDispersion$dispRange)[dispRange]
    print(strDispRange) 
    h_Length_GE <- hist(datGroupDispersion[datGroupDispersion$groupID == strGroupID[1] & datGroupDispersion$dispRange %in% levels(datGroupDispersion$dispRange)[dispRange] , ]$Length,breaks=xbreaks,plot=FALSE)
    h_Length_GL <- hist(datGroupDispersion[datGroupDispersion$groupID == strGroupID[2] & 
                                             datGroupDispersion$dispRange %in% levels(datGroupDispersion$dispRange)[dispRange] , ]$Length,breaks=xbreaks,plot=FALSE)

    lLinModel_GE <- getLogPowerSlope(h_Length_GE,10)
    lLinModel_GL <- getLogPowerSlope(h_Length_GL,10)
    
    plot(log10(h_Length_GE$mids),log10(100*h_Length_GE$counts/sum(h_Length_GE$counts) ),
         main=paste(" Log-Log percentage of lengths for disp:",strDispRange ),
         xlab="log Length (mm)", col=colourDataScheme[strGroupID[1]][[1]], pch=16,xlim=c(0,2.0),ylim=c(-4,3), ylab="log N(l) %")
    
    points(log10(h_Length_GL$mids),log10(100*h_Length_GL$counts/sum(h_Length_GL$counts) ),
           xlab="Length (mm)",col=colourDataScheme[strGroupID[2]][[1]], pch=16)
    lines(lLinModel_GE$ptx_line,lLinModel_GE$pty_line,lwd=3,col=colourDataScheme[strGroupID[1]][[1]])
    
    lines(lLinModel_GL$ptx_line,lLinModel_GL$pty_line,lwd=3,col=colourDataScheme[strGroupID[2]][[1]])
    legend("topright", 
           legend=c(paste("Spont μ",format(lLinModel_GE$coeff,digits=2)),paste("Evoked μ",format(lLinModel_GL$coeff,digits=2) ) ),col=c(colourDataScheme[strGroupID[2]][[1]] ,colourDataScheme[strGroupID[2]][[1]]) ,pch=c(16,16) )

}
##Low Dispersal - Larval Size - 4.3mm
plotLogLogPathLengthForFixedDispersion(datDispersion,c("NE","NL"),dispRange = 12)
plotLogLogPathLengthForFixedDispersion(datDispersion,c("LE","LL"),dispRange = 12)
plotLogLogPathLengthForFixedDispersion(datDispersion,c("DE","DL"),dispRange = 12)
## 5.2mm
plotLogLogPathLengthForFixedDispersion(datDispersion,c("NE","NL"),dispRange = 15)
plotLogLogPathLengthForFixedDispersion(datDispersion,c("LE","LL"),dispRange = 15)
plotLogLogPathLengthForFixedDispersion(datDispersion,c("DE","DL"),dispRange = 15)
##High Range 7.3
plotLogLogPathLengthForFixedDispersion(datDispersion,c("NE","NL"),dispRange = 22)
plotLogLogPathLengthForFixedDispersion(datDispersion,c("LE","LL"),dispRange = 22)
plotLogLogPathLengthForFixedDispersion(datDispersion,c("DE","DL"),dispRange = 22)



```

When looking at small dispersion circles $(3.7,4]$ we find here is that the path-lengths increase between spontaneous and evoked conditions, across groups. 
For larger dispersions cicles $(5.2,5.5]$ we find an effect specific to LF, whereby the food and non food (evoked, spontaneous) conditions differ in a manner shown as in (Viswanathan et al. 2009)!

The way the data is looked at here is different, and exponent $\mu$, shown as the linear power law within the log-log, would not match the investigations from (Viswanathan et al. 2009)

##  path-length to dispersion ratios fixed dispersion range
```{r  path-length to dispersion ratio distribution , fig.show="hold", out.width="33%", echo=FALSE, cache=TRUE }

hist_pathLengthPerDispersion <- function(datDispersion,strGroupID)
{
  datGroupDispersion <- datDispersion[datDispersion$groupID %in% strGroupID,]
  ##get Dispersion Levels, as discrete circles with thing 1mm boundary
  dispLevel <- cut(datGroupDispersion[,"Dispersion" ],breaks=seq(1,11,1))
  y <- datGroupDispersion[!is.na(dispLevel) & dispLevel == '(3,4]',"Length"]
  strTitle <- paste( strGroupID,"#",NROW(y),"D=3-4mm l",theoreticalMeanLength(3),"-", theoreticalMeanLength(4), "<s>=",mean(y,na.rm=TRUE) )

  #x <- datDispersion[!is.na(dispLevel) & dispLevel == '(3,4]',"Dispersion"]
  hist(y,breaks=seq(0,46,2),
  main=strTitle,
  col=colourDataScheme[[strGroupID]]  )
  
  ##get Dispersion Levels, as discrete circles with thing 1mm boundary
  y <- datGroupDispersion[!is.na(dispLevel) & dispLevel == '(4,5]',"Length"]
  strTitle <- paste( strGroupID,"#",NROW(y),"D=4-5mm l~",theoreticalMeanLength(4),"-", theoreticalMeanLength(5), "<s>=",mean(y,na.rm=TRUE) )
  #x <- datDispersion[!is.na(dispLevel) & dispLevel == '(3,4]',"Dispersion"]
  hist(y,breaks=seq(0,46,2),main=strTitle,
       col=colourDataScheme[[strGroupID]]  )
  
  y <- datGroupDispersion[!is.na(dispLevel) & dispLevel == '(5,6]',"Length"]
  strTitle <- paste( strGroupID,"#",NROW(y),"D=5-6mm l~",theoreticalMeanLength(5),"-", theoreticalMeanLength(6), "<s>=",mean(y,na.rm=TRUE) )
  #x <- datDispersion[!is.na(dispLevel) & dispLevel == '(3,4]',"Dispersion"]
  hist(y,breaks=seq(0,46,2),
       main=strTitle , col=colourDataScheme[[strGroupID]]  )
}

## Take Group 
hist_pathLengthPerDispersion(datDispersion,'NE')
hist_pathLengthPerDispersion(datDispersion,'NL')

hist_pathLengthPerDispersion(datDispersion,'LE')
hist_pathLengthPerDispersion(datDispersion,'LL')

hist_pathLengthPerDispersion(datDispersion,'DE')
hist_pathLengthPerDispersion(datDispersion,'DL')




```

Interestingly, it appears that the invariance principle does hold, the *mean path length depends on size of the observation area $\pi A/C$*, 
so indeed these paths may have a random walk structure.

This is evidence towards the larval trajectories appearing  as a stochastic diffussive process. 
>What is the most efficient strategy to adopt while searching for randomly placed sites whose
locations are not apriori known for situations when the searcher has information only about
its close vicinity? (see  E P Raposo et al 2009)

  - Are these larvae executing Levy walks?

In general the above data suggest that the characteristics  **dynamics governing foraging motion  may  modified by experience **

>From an evolutionary perspective, it is certainly pertinent to ask if efficient encounter rates are driven from selective pressures that systematically force organism adaption toward some optimal (or sub-optimal) solution.

 I need to understand what changes in these walks, in terms of step length -
 Generally the LF group shows a bimodal distribution of path length  and an increase in the overall path length. which could be indicative of increased number of re-orientations. There is also a decrease in path-length between spontaneous and evoked conditions (most evident in LF )


## Mean-Squared-Distance over time

```{r  mean-squared-distance over time , fig.show="hold", out.width="33%", echo=FALSE, cache=TRUE }
rm(ldatDispersion)
ldatDispersion <- list()
vtimeWindows <- c(2,4,6,8,10,15,20,40)
for (t in vtimeWindows)
  ldatDispersion[[as.character(t)]]<- readRDS(file=paste0(strDataExportDir,"/foragingState_Dispersion",t,"sec.rds") ) 

strG <- 'DE'
hist(ldatDispersion[["40"]][ldatDispersion[["40"]]$groupID == strG,"MSD"],main=paste(strG,mean(ldatDispersion[["40"]][ldatDispersion[["40"]]$groupID == strG,"MSD"],na.rm=TRUE) ),xlim=c(0,210))
hist(ldatDispersion[["20"]][ldatDispersion[["20"]]$groupID == strG,"MSD"],main=paste(strG,mean(ldatDispersion[["20"]][ldatDispersion[["20"]]$groupID == strG,"MSD"],na.rm=TRUE) ),xlim=c(0,210))
hist(ldatDispersion[["7"]][ldatDispersion[["7"]]$groupID == strG,"MSD"],main=paste(strG,mean(ldatDispersion[["7"]][ldatDispersion[["7"]]$groupID == strG,"MSD"],na.rm=TRUE) ),xlim=c(0,210))

strG <- 'DL'
hist(datDispersion_40[datDispersion_40$groupID == strG,"MSD"],main=paste(strG,mean(datDispersion_40[datDispersion_40$groupID == strG,"MSD"],na.rm=TRUE) ) ,xlim=c(0,210))
hist(datDispersion_20[datDispersion_20$groupID == strG,"MSD"],main=paste(strG,mean(datDispersion_20[datDispersion_20$groupID == strG,"MSD"],na.rm=TRUE) ) ,xlim=c(0,210))
hist(datDispersion_7[datDispersion_7$groupID == strG,"MSD"],main=paste(strG,mean(datDispersion_7[datDispersion_7$groupID == strG,"MSD"],na.rm=TRUE) ),xlim=c(0,210))


plotLogLogMSD <- function(datDispersion,strG,addPlot=FALSE,powerLawRange = 100)
{
    datGroupDispersion <- datDispersion[datDispersion$groupID %in% strG,]
    #dispBreaks <- seq(1,max(datDispersion$MSD,na.rm=TRUE)+1,15)
    #datGroupDispersion$dispRange <- cut(datGroupDispersion[,"Dispersion" ],breaks=dispBreaks)
    strTitle <- paste("MSD length (20sec)", strG,"#",NROW(datGroupDispersion))

    xbreaks <-seq(0,max(datDispersion$MSD,na.rm=TRUE)+15,15)
    #strDispRange <-levels(datGroupDispersion$dispRange)[dispRange]
    #print(strDispRange) 
    h_Length_GE <- hist(datGroupDispersion[ ,"MSD"], breaks=xbreaks,plot=FALSE)
    lLinModel_GE <- getLogPowerSlope(h_Length_GE,powerLawRange)
    
    if (!addPlot) 
    {
      plot(log10(h_Length_GE$mids),log10(100*h_Length_GE$counts/sum(h_Length_GE$counts) ),
         main=paste(" Log-Log percentage of MSD " ),
         xlab="log Length (mm)", col=colourDataScheme[strG][[1]], pch=16,xlim=c(0,3.0),ylim=c(-4,3), ylab="log N(l) %")
    }else
    {
        points(log10(h_Length_GE$mids),log10(100*h_Length_GE$counts/sum(h_Length_GE$counts) ),
         main=paste(" Log-Log percentage of MSD " ),
         xlab="log Length (mm)", col=colourDataScheme[strG][[1]], pch=16,xlim=c(0,3.0),ylim=c(-4,3), ylab="log N(l) %")
    }
    
    lines(lLinModel_GE$ptx_line,lLinModel_GE$pty_line,lwd=3,col=colourDataScheme[strG][[1]])
    lLinModel_GE$meanMSD <- mean(datGroupDispersion[ ,"MSD"],na.rm=TRUE) ##Add Mean MSD for timeWindow
    lLinModel_GE$groupID <- strG
    
    return(lLinModel_GE)
}
##Collect the mean MSD from each Dispersion Calcl integration Window and show mean diffusion
plotMSDPerTime <- function(lModelwithMSD,addPlot=FALSE)
{
  vMSD <- vector()
  vTimeWindow <- vector()
  for (i in 1:NROW(lModelwithMSD))
  {
    vMSD[i] <- lModelwithMSD[[i]]$meanMSD
    vTimeWindow[i] <-as.numeric( names(lModelwithMSD[i]) )
  }
  if (!addPlot)
  {
    plot(vTimeWindow,vMSD,xlim=c(0,60),ylim=c(0,70), col=colourDataScheme[[lModelwithMSD[[1]]$groupID]],pch=16)
  }else
    points(vTimeWindow,vMSD,xlim=c(0,60),ylim=c(0,70), col=colourDataScheme[[lModelwithMSD[[1]]$groupID]],pch=16)
  
  lines(vTimeWindow,vMSD,xlim=c(0,60),ylim=c(0,70), col=colourDataScheme[[lModelwithMSD[[1]]$groupID]],pch=16)
}

plotMSDPerIntegrationTime <- function(ldatDispersion,strG,lLinModel)
{
  bAddPlot <- FALSE
  for (tt in names(ldatDispersion))
  {
    lLinModel[[strG]] <- list() ##list per twindow integration for this group
    lLinModel[[strG]][[tt]] <- plotLogLogMSD(ldatDispersion[[tt]],strG,bAddPlot)
    bAddPlot <- TRUE
  }
  
  return(lLinModel)
   
}

##Get Distribution of MSD and Mean MSD for each time integration window 
lLinModel <- list() ##Start new list Containing The mean Vals per group per time
lLinModel[["NE"]] <- plotMSDPerIntegrationTime(ldatDispersion,"NE",lLinModel)
lLinModel[["NL"]] <- plotMSDPerIntegrationTime(ldatDispersion,"NL",lLinModel)
lLinModel[["LE"]] <- plotMSDPerIntegrationTime(ldatDispersion,"LE",lLinModel)
lLinModel[["LL"]] <- plotMSDPerIntegrationTime(ldatDispersion,"LL",lLinModel)
lLinModel[["DE"]] <- plotMSDPerIntegrationTime(ldatDispersion,"DE",lLinModel)
lLinModel[["DL"]] <- plotMSDPerIntegrationTime(ldatDispersion,"DL",lLinModel)

plotMSDPerTime(lLinModel[["NE"]])
plotMSDPerTime(lLinModel[["NL"]],TRUE)
plotMSDPerTime(lLinModel[["LE"]],TRUE)
plotMSDPerTime(lLinModel[["LL"]] ,TRUE)
plotMSDPerTime(lLinModel[["DE"]],TRUE)
plotMSDPerTime(lLinModel[["DL"]],TRUE)

# 
# lLinModel_NL <- list()
# lLinModel_NL[["4"]] <- plotLogLogMSD(ldatDispersion[["4"]],"NL",FALSE)
# lLinModel_NL[["7"]] <- plotLogLogMSD(ldatDispersion[["7"]],"NL",TRUE)
# lLinModel_NL[["10"]] <- plotLogLogMSD(ldatDispersion[["10"]],"NL",TRUE)
# lLinModel_NL[["20"]] <- plotLogLogMSD(ldatDispersion[["20"]],"NL",TRUE)
# lLinModel_NL[["40"]] <- plotLogLogMSD(ldatDispersion[["40"]],"NL",TRUE)
# 
# legend("topright", 
#            legend=c(paste("Spont μ",format(lLinModel_NE[[1]]$coeff,digits=2)),
#                     paste("Evoked μ",format(lLinModel_NL[[1]]$coeff,digits=2) ) ),
#        col=c(colourDataScheme$NE ,colourDataScheme$NL) ,pch=c(16,16) )
# 
# 
# lLinModel_LE <- list()
# lLinModel_LE[["4"]] <- plotLogLogMSD(ldatDispersion[["4"]],"LE",FALSE)
# lLinModel_LE[["7"]] <- plotLogLogMSD(ldatDispersion[["7"]],"LE",TRUE)
# lLinModel_LE[["20"]] <- plotLogLogMSD(ldatDispersion[["20"]],"LE",TRUE)
# lLinModel_LE[["40"]] <- plotLogLogMSD(ldatDispersion[["40"]],"LE",TRUE)
# 
# lLinModel_LL <- list()
# lLinModel_LL[["4"]] <- plotLogLogMSD(ldatDispersion[["4"]],"LL",FALSE)
# lLinModel_LL[["7"]] <- plotLogLogMSD(ldatDispersion[["7"]],"LL",TRUE)
# lLinModel_LL[["10"]] <- plotLogLogMSD(ldatDispersion[["10"]],"LL",TRUE)
# lLinModel_LL[["20"]] <- plotLogLogMSD(ldatDispersion[["20"]],"LL",TRUE)
# lLinModel_LL[["40"]] <- plotLogLogMSD(ldatDispersion[["40"]],"LL",TRUE)
# 
# 
# legend("topright", 
#            legend=c(paste("Spont μ",format(lLinModel_LE[[1]]$coeff,digits=2)),
#                     paste("Evoked μ",format(lLinModel_LL[[1]]$coeff,digits=2) ) ),
#        col=c(colourDataScheme$LE ,colourDataScheme$LL) ,pch=c(16,16) )
# 
# lLinModel_DE <- list()
# lLinModel_DE[["4"]] <- plotLogLogMSD(ldatDispersion[["4"]],"DE",FALSE)
# lLinModel_DE[["7"]] <- plotLogLogMSD(ldatDispersion[["7"]],"DE",TRUE)
# lLinModel_DE[["20"]] <- plotLogLogMSD(ldatDispersion[["10"]],"DE",TRUE)
# lLinModel_DE[["20"]] <- plotLogLogMSD(ldatDispersion[["20"]],"DE",TRUE)
# lLinModel_DE[["40"]] <- plotLogLogMSD(ldatDispersion[["40"]],"DE",TRUE)
# 
# lLinModel_DL <- list()
# lLinModel_DL[["4"]] <- plotLogLogMSD(ldatDispersion[["4"]],"DL",FALSE)
# lLinModel_DL[["7"]] <- plotLogLogMSD(ldatDispersion[["7"]],"DL",TRUE)
# lLinModel_DL[["10"]] <- plotLogLogMSD(ldatDispersion[["10"]],"DL",TRUE)
# lLinModel_DL[["20"]] <- plotLogLogMSD(ldatDispersion[["20"]],"DL",TRUE)
# lLinModel_DL[["40"]] <- plotLogLogMSD(ldatDispersion[["40"]],"DL",TRUE)
# 
# legend("topright", 
#            legend=c(paste("Spont μ",format(lLinModel_DE[[1]]$coeff,digits=2)),
#                     paste("Evoked μ",format(lLinModel_DL[[1]]$coeff,digits=2) ) ),
#        col=c(colourDataScheme$DE ,colourDataScheme$DL) ,pch=c(16,16) )





```

The mean of the mean squared displacement shows the astonishing result, ** Movement in absence and presence of prey differs between groups in manner that depends on experience **

# Hierarchical clustering model to reveal difference in larval locomotion behaviour
Next we may proceed to construct a hierarchical statistical model to describe the mean group dispersal behaviours in spontaneous and evoked conditions, based on the estimated behaviour of $i=60$ larva from each group $G$.

# Hunt-events and foraging state

Here I will identify the number of hunt events evoked/initiated in each foraging state.
However, it is natural to expect that since hunt events involve slow prey approach behaviour, which gives low dispersion, a higher hunt-rate is expected in the exploitation state. Yet the time window of foraging state classification is 5 sec, while a hunt episodes last for less than 2 sec (~1sec If i remember correctly, check eLife paper fig).
Thus the foraging state is associated with slow/ prey approach motion, as a high rate of hunt initiation would cause low dispersion.  

A list of all tabulated hunt-outcomes 
```{r table-all-huntscores}
## Get Number of Hunt Events In Exploit / Expore
table(convertToScoreLabel(datHuntLabelledEventsSBMerged_fixed$huntScore) )
```

can be compared to the subset of hunt-outcomes that are associated with a dispersion clustered as being in *exploitation* state
and those clustered with larger dispersion, indicative of being in the *exploration* foraging state.
while some hunt-outcomes were not associated with any dispersion measure - missing as trajectory was not long enoughat time of the hunt event

```{r table-Exploration-huntscores,eval=FALSE}
table(convertToScoreLabel(datHEventDispersion[!is.na(datHEventDispersion$Dispersion_norm) & datHEventDispersion$Dispersion_norm <= thres_dispersion_class,]$huntScore) )
```
```{r table-Exploit-huntscores,eval=FALSE}
table(convertToScoreLabel(datHEventDispersion[!is.na(datHEventDispersion$Dispersion_norm) & datHEventDispersion$Dispersion_norm > thres_dispersion_class,]$huntScore) )
```
```{r table-unaccounted-huntscores,eval=FALSE}
## Check number of Events missing dispersion Info
table(convertToScoreLabel(datHEventDispersion[!is.na(datHEventDispersion$Dispersion_norm),]$huntScore) )
```

Just looking at the histogram of normalized dispersion of all hunt events it appears that most of these are not within the lowest of measured dispersion, which could be indicative of exploitation but rather in an exploratory phase!

```{r  hunt-event-all-dispersion histogram Norm, fig.show="hold", out.width="50%", echo=FALSE, cache=TRUE }

hist(datHEventDispersion$Dispersion_norm,main="All group hunt events ",xlab="Dispersion normalized per exp",breaks=100)
hist(datHEventDispersion$Dispersion_larval_norm,main="All group hunt events ",xlab="Dispersion normalized per larva",breaks=100)

```

### Histograms of hunt-event dispersions split conditions
 
These next histograms show how *normalized larval dispersion* is distributed in each rearing group and looking at whether hunting initiation changes between spontaneous and evoked conditions.

  * It appears as if only the NF hunts during an exploitation type of movement.
  * LF spontaneous hunt-events occur over exploration (higher dispersion) 

```{r  hunt-event-group-dispersion histogram Norm, fig.show="hold", out.width="50%", echo=FALSE, cache=TRUE }
## Normalized Dispersion In Hunt Events
nBreaks = 30
## Check LF
hist(datHEventDispersion[datHEventDispersion$groupID=='LL', ]$Dispersion_larval_norm,breaks=nBreaks,main="LF Evoked",xlab="Dispersion Norm.",col=colourDataScheme$LF$Evoked)
hist(datHEventDispersion[datHEventDispersion$groupID=='LE', ]$Dispersion_larval_norm,breaks=nBreaks,main="LF Spont",xlab="Dispersion Norm.",col=colourDataScheme$LF$Spont)

## Check NF
hist(datHEventDispersion[datHEventDispersion$groupID=='NL', ]$Dispersion_larval_norm,breaks=nBreaks,main="NF Evoked",xlab="Dispersion Norm.",col=colourDataScheme$NF$Evoked)
hist(datHEventDispersion[datHEventDispersion$groupID=='NE', ]$Dispersion_larval_norm,breaks=nBreaks,main="NF Spont",xlab="Dispersion Norm.",col=colourDataScheme$NF$Spont)

## Check DF
hist(datHEventDispersion[datHEventDispersion$groupID=='DL', ]$Dispersion_larval_norm,breaks=nBreaks,main="DF Evoked",xlab="Dispersion Norm.",col=colourDataScheme$DF$Evoked)
hist(datHEventDispersion[datHEventDispersion$groupID=='DE', ]$Dispersion_larval_norm,breaks=nBreaks,main="DF Spont",xlab="Dispersion Norm.",col=colourDataScheme$NF$Spont)

BW=0.1
```

### Compare Hunt-event dispersions estimated densities

Next, I estimated smoothed densities using a gaussian kernel so I can visualy compare  dispersion between spontaneous and evoked conditions (BW=`r  BW`)
These suggest that dispersions shift between spont in and evoked conditions differently between groups:

  * prey *does not change* dispersion  in the naive group NF
  * prey *reduces* dispersion in the experienced group LF
  * prey **increases** dispersion in the experienced group LF

Such distinct pattern between group (specifically difference NF-DF) is consistent with previous findings in Lagogiannis et al 2020.

```{r  hunt-event-group-dispersion Norm split conditions, fig.show="hold", out.width="33%", echo=FALSE, cache=TRUE }
 ## plot est, Densities Compare Spont to Evoked
BW=0.1
 ylimUp <- 5
 plot(density(datHEventDispersion[datHEventDispersion$groupID=='NE', ]$Dispersion_larval_norm, kernel="gaussian",na.rm=TRUE, bw=BW), lwd=4, ylim=c(0,ylimUp), col=colourDataScheme$NF$Spont,main="NF Hunt events  ",xlab="Dispersion (norm per larva)",lty=1  )
 lines(density(datHEventDispersion[datHEventDispersion$groupID=='NL', ]$Dispersion_larval_norm,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$NF$Evoked,main=NA,lty=2)
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$NF$Spont,colourDataScheme$NF$Evoked),lwd=3 ) 
 
 
 plot(density(datHEventDispersion[datHEventDispersion$groupID=='LE', ]$Dispersion_larval_norm, kernel="gaussian",na.rm=TRUE,bw=BW), lwd=4, ylim=c(0,ylimUp),col=colourDataScheme$LF$Spont,main="LF  Hunt events",xlab="Dispersion (norm per larva)",lty=1 )
 lines(density(datHEventDispersion[datHEventDispersion$groupID=='LL', ]$Dispersion_larval_norm,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$LF$Evoked,main=NA,lty=2 )
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$LF$Spont,colourDataScheme$LF$Evoked),lwd=3 ) 

 plot(density(datHEventDispersion[datHEventDispersion$groupID=='DE', ]$Dispersion_larval_norm, kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4, ylim=c(0,ylimUp),col=colourDataScheme$DF$Spont,main="DF  Hunt events",xlab="Dispersion (norm per larva)",lty=1 )
 lines(density(datHEventDispersion[datHEventDispersion$groupID=='DL', ]$Dispersion_larval_norm,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$DF$Evoked,main=NA,lty=2 )
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$DF$Spont,colourDataScheme$DF$Evoked),lwd=3 ) 
```

The distributions look similar even if we remove the normalization stage, and look at raw dispersion measures, the low dispersion associated with exploitation phase is rare among hunt-events

```{r  hunt-event-dispersion distribution raw split E-S, fig.show="hold", out.width="33%", echo=FALSE, cache=TRUE }
BW = 1
 ylimUp <- 1
 plot(density(datHEventDispersion[datHEventDispersion$groupID=='NE', ]$Dispersion, kernel="gaussian",na.rm=TRUE, bw=BW), lwd=4, ylim=c(0,ylimUp), col=colourDataScheme$NF$Spont,main="NF Hunt events  ",xlab="Dispersion (mm)",lty=1  )
 lines(density(datHEventDispersion[datHEventDispersion$groupID=='NL', ]$Dispersion,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$NF$Evoked,main=NA,lty=2)
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$NF$Spont,colourDataScheme$NF$Evoked),lwd=3 ) 
 
 
 plot(density(datHEventDispersion[datHEventDispersion$groupID=='LE', ]$Dispersion, kernel="gaussian",na.rm=TRUE,bw=BW), lwd=4, ylim=c(0,ylimUp),col=colourDataScheme$LF$Spont,main="LF  Hunt events",xlab="Dispersion (mm)",lty=1 )
 lines(density(datHEventDispersion[datHEventDispersion$groupID=='LL', ]$Dispersion,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$LF$Evoked,main=NA,lty=2 )
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$LF$Spont,colourDataScheme$LF$Evoked),lwd=3 ) 

 plot(density(datHEventDispersion[datHEventDispersion$groupID=='DE', ]$Dispersion, kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4, ylim=c(0,ylimUp),col=colourDataScheme$DF$Spont,main="DF  Hunt events",xlab="Dispersion (mm)",lty=1 )
 lines(density(datHEventDispersion[datHEventDispersion$groupID=='DL', ]$Dispersion,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$DF$Evoked,main=NA,lty=2 )
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$DF$Spont,colourDataScheme$DF$Evoked),lwd=3 ) 

```

## Hunting initiation probability per *g clustered foraging state*
In the absence of prey both dispersion clusters (small/large), appear to have the same emmission probability for hunting events.
However in the presence of prey (evoked), we find that it is the large dispersal ("explore") mode that has *significantly higher probability of hunting initiation across groups.
*In light of this data, we can longer use explore/exploit*  terminology to characterise the clusters of motion dispersion. If anything the cluster with higher hunting-initiation, at least in evoked conditions, could be described to be the exploitation. 
*Critically, this is in disagreement to Marquez et al. 2019*, where it was found that the small dispersal cluster had higher hunting-initiation probability.


```{r results-NBGlobal-clustered-hunting-probability, fig.show="hold", out.width="33%", echo=FALSE, cache=TRUE }
#oad(file=paste0(strDataExportDir,strOutFilename,'.RData') )
 

lparamsAll <- getMCMCNBGroupEstimatedParams(results.All,"All",1)

lparamsAll$groupID = "NE"
plotGroup<- which(levels(datSubDispersion$groupID)==lparamsAll$groupID)
plotHuntProb(lparamsAll,lparamsAll$clustCol ,plotGroup,6)
lparamsAll$groupID = "LE"
plotGroup<- which(levels(datSubDispersion$groupID)==lparamsAll$groupID)
plotHuntProb(lparamsAll,lparamsAll$clustCol,plotGroup,6)
lparamsAll$groupID = "DE"
plotGroup<- which(levels(datSubDispersion$groupID)==lparamsAll$groupID)
plotHuntProb(lparamsAll,lparamsAll$clustCol,plotGroup,6)

lparamsAll$groupID = "NL"
plotGroup<- which(levels(datSubDispersion$groupID)==lparamsAll$groupID)
plotHuntProb(lparamsAll,lparamsAll$clustCol ,plotGroup,6)
lparamsAll$groupID = "LL"
plotGroup<- which(levels(datSubDispersion$groupID)==lparamsAll$groupID)
plotHuntProb(lparamsAll,lparamsAll$clustCol,plotGroup,6)
lparamsAll$groupID = "DL"
plotGroup<- which(levels(datSubDispersion$groupID)==lparamsAll$groupID)
plotHuntProb(lparamsAll,lparamsAll$clustCol,plotGroup,6)


```

## Relationship of hunt-outcome to *gobal clustered foraging state*

Do distributions of dispersion change depending on hunt-outcome ? 
The histograms below examine how the NB group model mix clustered dispersion, shown here as *normalized larval dispersion*, distributions shift for each group depending on capture outcome being success/fail.
** Note :** results here suggest that the low dispersal cluster, reportedly reflecting an exploitation state, is not associated with more hunt events in the LF group.

We need to evaluate the emission probability of each cluster state in order to establish if hunt-events are more commonly initiated in the exploitation state.It is clear however from the following results, that most hunt events are recorded in the Fast(Explore) cluster, however this is confounded with the duration of each state and thus needs to be evaluated conditionally on foraging state (dispersion cluster).

```{r load-results-NBGlobal-clustered-verify, fig.show="hold", out.width="33%", echo=FALSE, cache=FALSE }
source("DataLabelling/labelHuntEvents_lib.r") ##convertToScoreLabel
nBreaks = seq(0,1,0.1)
ylimUp <- 50


# Colour Coded Histogram of Dispersion Data Showing plit between Exploit[1] / Explore[2]
plotClusteredHuntEventsHist <- function(datHEventDispersion,clustCol)
{
  ## Plot Clustered  Histogram 
  breaksSlots <-  seq(0,11,by=0.5)
  h0 <- hist(datHEventDispersion$Dispersion, breaks=breaksSlots,plot=FALSE) # freq=TRUE,
  h1 <- hist(datHEventDispersion[datHEventDispersion$clustID == 1,"Dispersion" ], breaks=breaksSlots, plot=FALSE) #xlim=c(0,10),ylim=c(0,max(h0$counts))
  h2 <- hist(datHEventDispersion[datHEventDispersion$clustID == 2,"Dispersion" ], breaks=breaksSlots, plot=FALSE)  #xlim=c(0,10),
  if (sum(h1$counts) == 0)
    h1$density <- h1$counts
  if (sum(h2$counts) == 0)
    h2$density <- h2$counts

  barplot(rbind(h1$density,h2$density),beside = FALSE, col = c(clustCol,"white"),names.arg = (h1$breaks[-length(h1$breaks)]),
          main=paste("Dispersal clustered hunt-events", paste( unique(datHEventDispersion$groupID),collapse="," ) ),
          xlab = "Dispersion (mm)")
  
}


# Colour Coded Histogram of Dispersion Data Showing plit between Exploit[1] / Explore[2]
plotClusteredHuntEventsHist_norm <- function(datHEventDispersion,clustCol)
{
  ## Plot Clustered  Histogram 
  breaksSlots <-  seq(0,1.1,by=0.1)
  h0 <- hist(datHEventDispersion$Dispersion_larval_norm, breaks=breaksSlots,plot=FALSE) # freq=TRUE,
  h1 <- hist(datHEventDispersion[!is.na(datHEventDispersion$Dispersion) & datHEventDispersion$clustID == 1,"Dispersion_larval_norm" ], breaks=breaksSlots, plot=FALSE) #xlim=c(0,10),ylim=c(0,max(h0$counts))
  h2 <- hist(datHEventDispersion[!is.na(datHEventDispersion$Dispersion) & datHEventDispersion$clustID == 2,"Dispersion_larval_norm" ], breaks=breaksSlots, plot=FALSE )  #xlim=c(0,10),
  if (sum(h1$counts) == 0)
    h1$density <- h1$counts
  if (sum(h2$counts) == 0)
    h2$density <- h2$counts

  barplot(rbind(h1$density,h2$density),beside = FALSE, col = c(clustCol,"white"),names.arg = (h1$breaks[-length(h1$breaks)]),
          main=paste("Dispersal clustered hunt-events", paste( unique(datHEventDispersion$groupID),collapse="," ) ),
          xlab = "Dispersion normalized per larval range")
  
}

#load(file=paste0(strDataExportDir,'jagsModelTestResults_NBMixGroupclustDispersion_All.RData') )
datHEventDispersion <<- readRDS(file=paste0(strDataExportDir,"/huntEvent_mergedwith_Dispersion",tsec_timeWindow,"sec.rds") )

## Merge sparse Clustered Dispersions Results onto full Dispersion Data
lparamsAll <- getMCMCNBGroupEstimatedParams(results.All,"All",2)
if (!("clustID" %in% names(datSubDispersion)))
  datSubDispersion$clustID <- as.vector(lparamsAll$clustID)
##Merge Cluster ID onto Hunt Events
datHEventDispersion <- merge(datHEventDispersion, cbind.data.frame (frameRow=datSubDispersion$frameRow,
                                                        #expID=datSubDispersion$expID,
                                                        #groupID=datSubDispersion$expID,
                                                        clustID=datSubDispersion$clustID ),
                             by=c("frameRow"),all.x =TRUE,no.dups = FALSE)

# Get the Colour Label Right #
clustCol <- c(colourClusters[1],colourClusters[2])
##Validate Colouring - Fast Cluster - Yellow / Slow Cluster Blue
muC1 <- mean(datHEventDispersion[datHEventDispersion$clustID == 1,"Dispersion"],na.rm = TRUE)
muC2 <- mean(datHEventDispersion[datHEventDispersion$clustID == 2,"Dispersion"],na.rm = TRUE)
if (muC1>muC2)
  clustCol <- rev(clustCol)

## Validation Step That Cluster IDs maintain Meaning - Of low and High Dispersal
muC1_Hunts <- mean(datDispersion[datDispersion$frameRow %in% datHEventDispersion[datHEventDispersion$clustID == 1,"frameRow"],]$Dispersion,na.rm=TRUE)
muC2_Hunts <- mean(datDispersion[datDispersion$frameRow %in% datHEventDispersion[datHEventDispersion$clustID == 2,"frameRow"],]$Dispersion,na.rm=TRUE)

muC1_Sub <- mean(datDispersion[datDispersion$frameRow %in% datSubDispersion[datSubDispersion$clustID == 1,"frameRow"],]$Dispersion,na.rm=TRUE)
muC2_Sub <- mean(datDispersion[datDispersion$frameRow %in% datSubDispersion[datSubDispersion$clustID == 2,"frameRow"],]$Dispersion,na.rm=TRUE)
# ## Inconsistent Cluster labels between Clustered Dispersion Data and Hunt Events
stopifnot( ((muC1_Hunts < muC2_Hunts) & (muC1_Sub < muC2_Sub)) |  ((muC1_Hunts > muC2_Hunts) & (muC1_Sub > muC2_Sub)) )

# Show Count Of Hunt Events Per Cluster Per Exp. Condition
barplot(table(datHEventDispersion$clustID,datHEventDispersion$groupID),
        col=clustCol,
        main="Hunt-events per cluster and cond-group",ylim=c(0,1000) )
legend("topleft",legend=(paste("#",table(datHEventDispersion$clustID) )),fill=clustCol )

## Sanity Check The cluster with Most Hunt Events (Appears to Be )
boxplot(Dispersion ~ clustID*groupID,data=datHEventDispersion,col=clustCol,  main="hunt-event dispersion per cluster",ylab="Dispersion (mm)")
legend("topright",legend=(paste("#",table(datHEventDispersion$clustID) )),fill=clustCol  )

## Sanity Check The cluster with Most Hunt Events (Appears to Be )
boxplot(Dispersion_larval_norm ~ clustID*groupID,data=datHEventDispersion,col=clustCol,ylab="Normalized Dispersion per larva" )
legend("topright",legend=(paste("#",table(datHEventDispersion$clustID) )),fill=clustCol  )
 
```




```{r results-hunt-events dispersion- global clustered, fig.show="hold", out.width="50%", echo=FALSE, cache=FALSE }
 
plotClusteredHuntEventsHist(datHEventDispersion,clustCol)
plotClusteredHuntEventsHist_norm(datHEventDispersion,clustCol)


```
The clustered colour coded histograms suggest that *dispersion state (exploit/explore) does not affect hunt outcome*. 
The differences in dispersion of hunt events noticeable between groups reflects the overal dispersal differences they show in Evoked conditions
These were shown above by clustering the dispersal over the whole trajectory in each experimental condition.

```{r hunt-outcomes-per-globally clustered dispersions-evoked, fig.show="hold", out.width="50%", echo=FALSE, cache=FALSE }
## Check NF
## SUCCESS
 
plotClusteredHuntEventsHist(datHEventDispersion[datHEventDispersion$groupID=='NL' &
                      grepl("Success", as.character(  convertToScoreLabel(datHEventDispersion$huntScore) ) ) ,],
                      clustCol ) 
legend("topright",legend="Success")

plotClusteredHuntEventsHist(datHEventDispersion[datHEventDispersion$groupID=='NL' &
                      grepl("Fail", as.character(  convertToScoreLabel(datHEventDispersion$huntScore) ) ) ,],
                     clustCol ) 
legend("topright",legend="Failed")


## Check LF Successs/Fail Only
plotClusteredHuntEventsHist(datHEventDispersion[datHEventDispersion$groupID=='LL' &
                      grepl("Success", as.character(  convertToScoreLabel(datHEventDispersion$huntScore) ) ) ,],
                      clustCol ) 
legend("topright",legend="Success")


plotClusteredHuntEventsHist(datHEventDispersion[datHEventDispersion$groupID=='LL' &
                      grepl("Fail", as.character(  convertToScoreLabel(datHEventDispersion$huntScore) ) ) ,],
                     clustCol ) 
legend("topright",legend="Failed")

## Check DF Successs/Fail Only in Evoked
plotClusteredHuntEventsHist_norm(datHEventDispersion[datHEventDispersion$groupID=='DL' &
                      grepl("Success", as.character(  convertToScoreLabel(datHEventDispersion$huntScore) ) ) ,],
                      clustCol ) 
legend("topright",legend="Success")

plotClusteredHuntEventsHist_norm(datHEventDispersion[datHEventDispersion$groupID=='DL' &
                      grepl("Fail", as.character(  convertToScoreLabel(datHEventDispersion$huntScore) ) ) ,],
                     clustCol) 
legend("topright",legend="Failed")


```

### Hunt-event clustered dispersions in spontaneous

```{r hunt-outcomes-per-globally clustered dispersions-spontaneous, fig.show="hold", out.width="33%", echo=FALSE, cache=FALSE }

## Check NF
## SUCCESS
plotClusteredHuntEventsHist_norm(datHEventDispersion[datHEventDispersion$groupID=='NE' ,],
                      clustCol ) 
legend("topright",legend="Spontaneous")


## Check LF 
plotClusteredHuntEventsHist_norm(datHEventDispersion[datHEventDispersion$groupID=='LE'  ,],
                      clustCol ) 
legend("topright",legend="Spontaneous")
#DF
plotClusteredHuntEventsHist_norm(datHEventDispersion[datHEventDispersion$groupID=='DE'  ,],
                      clustCol ) 
legend("topright",legend="Spontaneous")


```




### Dispersion densities per outcome 

To visually compare dispersions between huntcomes I estimated smoothed distributions from the dispersion data split between Success and Failed hunt-outcomes.
Interstingly, I find evidence for pattern of distinct behaviours among groups :
  * NF 
  * LF Likely no difference between success/Failed episodes - contradicts Marquez et 2019 findings
  * DF Lower dispersion (exploitation state) linked to success
  
```{r  hunt-event-dispersion per outcome distributions, fig.show="hold", out.width="33%", echo=FALSE, cache=FALSE }
BW = 0.08
ylimUp <- 5
 plot(density(datHEventDispersion[datHEventDispersion$groupID=='NL' & grepl("Success", as.character(  convertToScoreLabel(datHEventDispersion$huntScore) ) ) , ]$Dispersion_larval_norm,
              kernel="gaussian",na.rm=TRUE, bw=BW), lwd=4, ylim=c(0,ylimUp), col=colourDataScheme$NF$Spont,main="NF Hunt Events  ",xlab="Dispersion (mm)",lty=1  )
 
 lines(density(datHEventDispersion[datHEventDispersion$groupID=='NL' & grepl("Fail", as.character(  convertToScoreLabel(datHEventDispersion$huntScore) ) ) , ]$Dispersion_larval_norm,
               kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$NF$Evoked,main=NA,lty=2)
legend("topright",c("Success","Fail"), lty=c(1,2),col=c(colourDataScheme$NF$Spont,colourDataScheme$NF$Evoked),lwd=3 ) 
 
 
 plot(density(datHEventDispersion[datHEventDispersion$groupID=='LL' & grepl("Success", as.character(  convertToScoreLabel(datHEventDispersion$huntScore) ) ) , ]$Dispersion_larval_norm, kernel="gaussian",na.rm=TRUE,bw=BW), lwd=4, ylim=c(0,ylimUp),col=colourDataScheme$LF$Spont,main="LF  Hunt Events",xlab="Dispersion (mm)",lty=1 )
 lines(density(datHEventDispersion[datHEventDispersion$groupID=='LL' & grepl("Fail", as.character(  convertToScoreLabel(datHEventDispersion$huntScore) ) ) , ]$Dispersion_larval_norm,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$LF$Evoked,main=NA,lty=2 )
legend("topright",c("Success","Fail"), lty=c(1,2),col=c(colourDataScheme$LF$Spont,colourDataScheme$LF$Evoked),lwd=3 ) 

 plot(density(datHEventDispersion[datHEventDispersion$groupID=='DL' & grepl("Success", as.character(  convertToScoreLabel(datHEventDispersion$huntScore) ) ) , ]$Dispersion_larval_norm, kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4, ylim=c(0,ylimUp),col=colourDataScheme$DF$Spont,main="DF  Hunt Events",xlab="Dispersion (mm)",lty=1 )
 lines(density(datHEventDispersion[datHEventDispersion$groupID=='DL' & grepl("Fail", as.character(  convertToScoreLabel(datHEventDispersion$huntScore) ) ) , ]$Dispersion_larval_norm,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$DF$Evoked,main=NA,lty=2 )
legend("topright",c("Success","Fail"), lty=c(1,2),col=c(colourDataScheme$DF$Spont,colourDataScheme$DF$Evoked),lwd=3 ) 

```

 (BW=`r  BW`)


## Dispersion as random process

Here I investigate on a different formulation of a stochastic dispersal data generating process. 
To study the statistical properties of dispersal and compare them between groups we model disperal data as a markov chain.
A simple description of such a process is 
\[
D_n = D_{n-1} + p z_n
\]
where $z_n ~ \mathcal{N}(\mu,\sigma)$.
The parameters of which can be inferred from the data of each larval dispersal measurements.
We assume that motion bouts are generated at regular intervals $t\in\{1...n\}$ and each bout motion may either increase the dispersal, measured as the circle encompassing a 5 sec ($k-step$) trajectory, or leave it the same. As as such  disperal lengths are dependent on the sum of a sequence of $k$ bernoulli trials, with $p$ being the probability that dispersion increases by a step size drawn from another distribution (assume Normal), and $q=1-p$ being the probability that the dispersal remains the same - either because a bout did not occur or because bout moved inwards.
In such a model we will need **to ignore any correlations between step outcomes**, as sequence of step that move inwards the dispersion circle, are less likely to lead to an increase in the next step, as the larva may have moved away from the current dispresion boundary. 
These  width of these correlations is increased with dispersion length (ie with the history of prior expansion successes.) 
Thus if we consider the dispersal length to be a sum of Gaussian random variables, then the resulting distribution should be Gaussian (or mixture of, if there is more than one $p$).

Alternativelly, assuming $k$-steps makes each dispersal count, we observe that a certain dispersal length is made up of a sequence of expansion events $e$, where the larva hits the dispersal measuring circle boundary, leaving the rest to of the $n=k-e$ steps to be expansion failures. 
If we assume that each expansion event increases dispersion by some fixed size $d$, then the *Negative binomial (NB)*  could be applicable here to model the distribution of dispersal lengths. The NB is a discrete probability distribution that models the number of failures in a sequence of independent and identically distributed Bernoulli trials before a specified (non-random) number of successes (denoted $r$) occurs.
This model  *generally is appropriate where events have positively correlated* occurrences causing a larger variance than if the occurrences were independent, due to a positive covariance term. Here we may model we may model $r$ as being the number of times dispersion did not change, while failures is bout that increases dispersal occurs.

In any case, looking at the distributions above it appears that, at least for LF, there appears to be at least two step-generating distributions $z_n$, which are required to describe the group's dispersal data. Further, it is also evident that the parameters of these distributions change between spontaneous and evoked conditions, at least in the LF group.
By modelling the data and inferring parameters using Bayesian inference we statistically compare changes in dispersal behaviour between groups and conditions.

Assume that each larva generates a different number of observations, given the difference in the time they are in view. We aim to model the statistics of dispersion of each larva separatelly and then aggregate into a model of the whole group. Difference in the number of observations should be reflected in the uncertainty of parameter estimates.  

However,given the nature of my data this can be problematic. Dispersion records are not continuous monitoring of behaviour, as there may be gaps between events. 
The 1st 5sec at the beginning of each larval record is filled with NA values, and thus we may exclude it.
Alternativelly we may directly model the distribution of $D_n$, rather model the step-generating process $z_n$.
We begin with this more direct approach to model the distribution of Dispersal data for each larva, assuming these can be clustered using a mixture of $c=2$ Normal distributions for each test condition, such that evoked and spontaneous conditions are modelled separatelly. The separate distributions can be seen as a model of the hidden foraging state of the animal, which emit different motion patterns, and thus modify dispersal differently.

This approach could be complemented by active inference / SPM model

### Model implementantion in Stan

To implement the normal mixture model outlined in the previous section in Stan, the discrete parameters can be summed out of the model.
If Y is a mixture of K normal distributions with locations μk and scales σk with mixing proportions λ in the unit K-simplex, then 
\[p_Y\left(y \mid \lambda, \mu, \sigma \right) = \sum_{k=1}^K \lambda_k \, \textsf{normal}\left(y \mid \mu_k, \sigma_k\right).\]
I will defer using Stan for this and go for my familiar Jags model implementation.



# Full figure List of trajectories per experiment

The following figures show the tracked trajectories per experiment of each group.
Trajectory segments are colour coded according to whether these can be classified as exploration or exploitation based on ta theshold on the normalized dispersion. This threshold is set here to `r thres_dispersion_class ` .
Red signiifies segments of exploitation, blue is for exploration. 
The column on the right shows the dispersion measurement along recording time. Note the x-axis is not real time, it is the total time of  concatenated recording events. The horizontal line represents where the exploit/explore dispersal threshold sits for each larva, given its normalized disperal measurements.
The triangles at the bottom denote hunt-event initiations in relation to dispersal.

  - Observing dispersals and trajectories it becomes clear that during a 10 min recording a larva could be in exploitation phase all the way, and thus the range of dispersals that this larva can produce is most likely not observed. see : 
   - NL 309/NE 302
    


## Trajectories clustered on Global NB Mix Model  

Note that dispersion is normalized based on the trajectories from Spontaneous and Evoked conditions *combined* for each larva.
Here it should be noted that in Marquez et al 2019 "To facilitate comparison across animals, the dispersal distance was normalized to the range of each animal."
That means this is not a division by the maximum dispersal of each animal, but it also makes use of the minimum.

#### LF - Evoked /Spontaneous Trajectories
```{r  NBMixClustered-trajectories-LL, fig.show="hold", out.width="50%", echo=FALSE, results='hide' , cache=TRUE, autodep=TRUE,eval=FALSE,warning=FALSE}

loaddatAllFrames()
loadDispersionData()

  plotNBMixGClusteredDispersionTrajectories(c('LL','LE'),datAllFrames, datDispersion ,datHEventDispersion,datExpPairs,  thres_dispersion_class )

```

#### NF - Evoked/Spontaneous Trajectories 
```{r larva_norm-trajectories-NL, fig.show="hold", out.width="50%", echo=FALSE, results='hide',cache=TRUE, autodep=TRUE,eval=FALSE,warning=FALSE}
plotLarvaNormDispersionTrajectories(c('NL','NE'),datAllFrames, datDispersion ,datHEventDispersion,datExpPairs, thres_dispersion_class )

```
  
#### DF - Evoked/Spontaneous Trajectories 
```{r larva_norm-trajectories-DL, fig.show="hold", out.width="50%", echo=FALSE, results='hide', cache=TRUE, autodep=TRUE,eval=FALSE,warning=FALSE}

plotLarvaNormDispersionTrajectories(c('DL','DE'),datAllFrames, datDispersion , datHEventDispersion, datExpPairs, thres_dispersion_class)


```

## Classifying exploitation/exploration phases based on **global threshold**
The dispersion of each experiment is normalized globally and thus classification threhsold for exploitation identifies trajectory segments of spatially restricted motion relative to all larvae across groups

### Evoked conditions
Trajectories of 10min recordings in the presence of prey. Note, in contrast to Marquez et al. 2019, our recodings exclude motion at the boundary of petridish.

#### LF - Evoked+Sponτaneous larval trajectories
Eploitation state is shown in *red* and *orange* in evoked and spontaneous test conditions respectivelly, with hunt events shown as squares.
Exploration state is *blue* and *green* in evoked and spontaneous test conditions respectivelly, , with hunt events shown as triangles.

```{r  global_norm-trajectories-LL, fig.show="hold", out.width="50%", echo=FALSE, results='hide', cache=TRUE, autodep=TRUE,eval=FALSE }
loaddatAllFrames()
loadDispersionData()
plotGlobalNormDispersionTrajectories(c('LL','LE'), datAllFrames, datDispersion, datHEventDispersion, datExpPairs,   thres_dispersion_class )

```

#### NF - Evoked+Spont Trajectories 
```{r global_norm-trajectories-NL, fig.show="hold", out.width="50%", echo=FALSE, results='hide', cache=TRUE, autodep=TRUE,eval=FALSE}

plotGlobalNormDispersionTrajectories(c('NL','NE'),datAllFrames,datDispersion,datHEventDispersion,datExpPairs, thres_dispersion_class )

```

#### DF - Evoked Trajectories 
```{r global_norm-trajectories-DL, fig.show="hold", out.width="50%", echo=FALSE, results='hide', cache=TRUE, autodep=TRUE,eval=FALSE}

plotGlobalNormDispersionTrajectories(c('DL','DE'),datAllFrames,datDispersion,datHEventDispersion,datExpPairs, thres_dispersion_class)

```


## Classify based on normalizated experiment trajectory dispersion

Note that Spontaneous and Evoked conditions of each larva are considered individually

#### LF - Evoked /Spontaneous Trajectories
```{r  exp_norm-trajectories-LL, fig.show="hold", out.width="50%", echo=FALSE, results='hide' , cache=TRUE, autodep=TRUE,eval=FALSE}
loaddatAllFrames()
loadDispersionData()
plotExpNormDispersionTrajectories(c('LL','LE'),datAllFrames,datDispersion ,datHEventDispersion,datExpPairs,  thres_dispersion_class )

```

#### NF - Evoked/Spontaneous Trajectories 
```{r exp_norm-trajectories-NL, fig.show="hold", out.width="50%", echo=FALSE, results='hide',cache=TRUE, autodep=TRUE,eval=FALSE}

plotExpNormDispersionTrajectories(c('NL','NE'),datAllFrames,datDispersion ,datHEventDispersion,datExpPairs, thres_dispersion_class )

```

#### DF - Evoked/Spontaneous Trajectories 
```{r exp_norm-trajectories-DL, fig.show="hold", out.width="50%", echo=FALSE, results='hide', cache=TRUE, autodep=TRUE,eval=FALSE}


plotExpNormDispersionTrajectories(c('DL','DE'),datAllFrames,datDispersion ,datHEventDispersion,datExpPairs, thres_dispersion_class)

```


# END

```{r spare-code-notes,eval=FALSE, include=FALSE}
## Retrieve Dispersion of each Hunt Event
start.time <- Sys.time()
i <- 0
for (i in 1:NROW(datHuntLabelledEventsSBMerged_fixed) )
{

   datHEvent_disp <- datDispersion[datDispersion$expID == datHuntLabelledEventsSBMerged_fixed[i,]$expID &
                              datDispersion$eventID == datHuntLabelledEventsSBMerged_fixed[i,]$eventID &
                              datDispersion$frameN == datHuntLabelledEventsSBMerged_fixed[i,]$startFrame ,] #
   #message(datHEvent_disp$expID)

   if (NROW(datHEvent_disp) == 0 )
   {
     warning("Tracking dispersion data not found for huntevent ",i, "at startframe ",datHuntLabelledEventsSBMerged_fixed[i,]$startFrame )
     ##Try Again without the start frame - Slower
     datHEvent_disp <- datDispersion[datDispersion$expID == datHuntLabelledEventsSBMerged_fixed[i,]$expID &
                              datDispersion$eventID == datHuntLabelledEventsSBMerged_fixed[i,]$eventID  ,] #
   }

   if (NROW(datHEvent_disp) == 0 )
     warning("Attaching dispersion data for huntevent ",i, " Failed")

   # Check if Rec Exists
   if (NROW(datHEvent_disp) == 1 )
   {

     vHuntEventDispersion[i] <- datHEvent_disp$Dispersion
     vHuntEventDispersion_norm[i] <-  datHEvent_disp$Dispersion_norm
     message(i," Disp:",vHuntEventDispersion[i])

   }else {

     ## Multiple rows returned
     ## FInd Tracking (Dispersion dat) frame that is closest to hunt-event initiation (start frame)
     idx <- NA
     with(datHuntLabelledEventsSBMerged_fixed[i,],
          {
                idx <- which(abs(datHEvent_disp$frameN - startFrame) == min(abs(datHEvent_disp$frameN - startFrame) ) )

                vHuntEventDispersion_norm[i] <- datHEvent_disp[idx,"Dispersion_norm"]
                vHuntEventDispersion[i] <- datHEvent_disp[idx,"Dispersion"]
               ##This Maybe NA since there are no Dispersion Data In some Occassions
               ##stopifnot(!is.na(vHuntEventDispersion[i]))
               message("Found idx ",idx, " Disp ",vHuntEventDispersion[i])
          })

   }

    #Find Dispersion At start Frame of Hunt Event
    #
    print(i)


    #stopifnot(i <11)
}

   end.time <- Sys.time()
   time.taken <- end.time - start.time
   print(time.taken)

 
```



