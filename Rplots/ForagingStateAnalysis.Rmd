---
title: 'Notebook: Identifying the role of experience on foraging and exploration movement patterns'
output:
  html_document:
    df_print: paged
    params: 
    output_dir: "/media/kostasl/D445GB_ext4/kostasl/Dropbox/Calculations/zebrafishtrackerData/foragingAnalysis"

  html_notebook: default
  pdf_document: default
  bibliography: ForagingStateAnalysis.bib
---

Animals forage in a changing environment, and they must adjust their foraging to these changes. Learning and memory play a key role in making these adjustments.

My current aim to extend my previous work on the experience driven ontogeny of hunting skill [now published in eLife](https://elifesciences.org/articles/55119/figures) to examine the effect of experience on foraging. 

This notebook, initially aimed at analysing zebrafish tracking data for foraging state as indicated by Marquez et al 2019.
According to Marquez et al  2020, Zebrafish appear to spontaneously switch between an exploratory and exploitation phase that grossly defines their behavioural mode.  
The state can be read out be measuring trajectory dispersal over a fixed period of time (5 sec), 
Measures of dispersal should appear bimodal, with short dispersals indicating exploitation phase.

Given our behavioural recordings are not continuous, and exclude periods when the larva are swimming around the boundary, it is not certain whether we would be able to detect exploratory phases. These tend to be circling around the border of the petri-dish, as the fish attempts to swim forward. Nevertheless as we are interested in the mode-state under which hunt-events are executed, then we expect that some of these events should be executed during exploratory behaviour and this should be detectable - (dispersal, movement rates etc).
In essense the internal state and the its neural correlates as reported by Marquez et al 2019 can combined with my results on the learned aspects of efficient hunting to study if this foraging state swithcing is also influenced by experience and  whether differences in hunting kinematics correlate with internal state.

  Hypothesis being tested :
  - Does experience modify the dispersal  and so the exploit/explore state of each group?
  - Are foraging intervals modified based on priors built by experience and can these be modelled based on active inference ?(co-op with Rosalyn & Berk)
  - Could expansion of foraging interval explain the higher evoked hunt-rate of the LF group?
  - Does the execution of the kinematic adaptations of capture efficiency, found in the experience larvae,  depend on foraging state ?
  
Establishing a correlation of hunting state with the kinematics of efficient hunting can point us to the underlying circuits, because the circuits that correlate with foraging state, but also with capture-success,  have already been examined by Marquez et al 2019. So it would be posssible to use those to guide our search for the circuits that bring about the kinematics adaptations of success. 

In a new twist of this work *I discover structure in the larval trajectories that indicates a random search process*. 
Indeed although at the micro-scale larval do not move randomly, but have a rythm, it may well be the case (E.Raposo et al. 2009 ):
>Therefore, the foraging dynamics that defines the final outcomes of biological encounters becomes in essence a stochastic process (e.g. searches in landscapes
with low density of food sites).


The *Levy foraging hypothesis* predicts a Levy distribution of move-steps during foraging when prey is scarce, but an exponential distribution when prey is abundant and searching is not required.
In the absence of prey, the environment signals that prey is scarce, and in such conditions the optimal search strategy would be a Levy walk instead of brownian (#viswanathan1999optimizing).
*My recordings allow for the examination on whether search strategies are modified in the presence and absence of prey, and how experience of prey may modify these behaviours.*
I find that prey scarcity can modify larval general motion patterns in an adaptive manner such that larger areas are searched, yet prior experience of prey can strongly affect this behaviour.

The concept of a characteristic scale is used extensively in statistical physics for describing macroscopic behavior of physical systems. 
In Levy walks/flights the step lengths (ie straight path lengths) are said tp have no characteristic scale, because they are power-law distributed.


In (#humphries2010environmental) it shown that searching animals adaptivelly adjust their optimal patterns of movement to different environmental resource distributions. 
It remains unknown, however, whether the motions patterns arose as due to adaptive behaviour or whether observed patterns were an emergent property of the spatial distribution of prey (#sims2008scaling) 

>What is the most efficient strategy to adopt while searching for randomly placed sites whose
locations are not apriori known for situations when the searcher has information only about
its close vicinity? (see  E P Raposo et al 2009)

  - Are these larvae executing Levy walks?

>From an evolutionary perspective, it is certainly pertinent to ask if efficient encounter rates are driven from selective pressures that systematically force organism adaption toward some optimal (or sub-optimal) solution.

However (#reynolds2018passive) shows that Levy like walks can arise simply through flowing in a turbulent environemnt and he generally argues that as movement patterns they can be easy and ubiquitous to obtain, and argues that that these are not about evolving optiml searches (#reynolds2015liberating).


Here use prior prey experience can alter the foraging search patterns in the scarcity and abundance of prey, to test wether changes in search patterns can be are adaptive, and not simply a result of interacting with dense prey environments. Thus if prior expectations on abandunce of prey  can modify motion, then changes in search patterns can be shown to be adaptive.
Thus we explore whether animals evolved to exploit experience in their search patterns, and whether they can use optimal search strategies such as Levy flights/walks when prey is scarce.

 I need to understand what changes in these walks, in terms of step length -
 Generally the LF group shows a bimodal distribution of path length  and an increase in the overall path length. which could be indicative of increased number of re-orientations. There is also a decrease in path-length between spontaneous and evoked conditions (most evident in LF )

*Main Findings so far :*

  1. LF larvae are quicker to disperse (as seen in 20 sec path duration) and larval normalized dispersion (see Marquez et al. 2019) 
  2. Path lengths over 5sec are bimodal, like dispersions; clearly for LF. LF show longer pathlengths in 5sec to controls in both conditions (Low occupancy in small path mode). 
  3. Bimodal path length distribution in Evoked is modified towards longer paths and closing of bimodal gap, and extending path range 
  4. Evoked Hunt events occur over the shorter movement sub-range/mode of the overall distribution
  5. Path lengths are longer in Evoked for the same dispersion size , more clearly so for LF (see also pathL/Dispersion Ratio).
  6. Invariance of Mean-Path Length when crossing bounded domain r -across groups- is evidence of stochastic process.
  7. Mean *residence time* within domain clearly Shorter for LF, and most for LE.
  8. Path length distributions drop as power-law like after $l> 2 \times r$ (check exponent).
  9. Distribution Of Path Length Shows Power law drop-off for lengths exceeding the $2*r$ of the domain (chord distrib. seen in [ref].)
  10. With increasing domain $r$, Spontaneous conditions (all groups), but also LL, show *scale-invariance in the fraction of boundary crossings* against $r$, *but NL,DL prefers <6mm domains*
  11. *LF disperse faster* than controls, with *LE dispersing the fastest*.
  12. *LF move faster*, making longer path lengths over time but also leavin the ROI earlier;
  13. There are almost no paths with more than 40sec duration in LE, but this increases to 130sec for LL. *Probability of path duration clearly drops faster for increasing durations for LE*, than controls
  14. MSD over path duration clearly higher for LE, with max overshooting within 10sec,rather than 100 as in controls.
  15. Evidence of super-diffusion as MSD grows supra linearly to path-length (Within some range < 21mm), *MSD growth distinct for LE*
  16. MSD vs Dispersion are linearly related, with a drop-off in Evoked conditions over large dispersions.
  17. -Clustering And Bimodality results-.
  18. Spontaneous Hunt events associated with higher dispersions than Evoked, only for LF. NF, look the same, DF, do the opposite to LF.
  19. Hunt-outcome is not associated to Dispersion, but only in  LL do all successful events belong to fast-cluster 
  20. Hunting probability is higher in the large dispersion cluster for all groups.
  21. **Bout Structure**:

      - LF has Lower number of bouts per free-path
      - LF has Longer distance traveled per bout - *longer bouts*
      - Bout duration and distances decrease for LF,NF in evoked conditions, but not for DF.
      - Lower number of bouts between turns (maybe).
      - Inter-Bout intervals *show fat-tails for DF and NF* LF does not do long-pause/ Waits, in contrast to DF, NF.
      - Lower mean number of turns when crossing Domain 10mm for DE, and then LL,DL, and then LE- NE has highest
      - Increasing turn Modes around 40-50 deg, in spontaneous conditions, across groups. (Surprise as these turn modes are associated with Successful hunts)
      - *Bout Speed increases in absence of prey*, with LF having the fastest bouts on average and DF the slowest.
    
    
  
  
  
# Analysis of larval trajectories 

## Examine dispersion to reveal foraging state as in Marquez et al. 2019

5s window measure radius encompassing trajectory

```{r setup, message=FALSE, cache=FALSE, results='hide', echo=FALSE, warning=FALSE}
## Init  Code 
library(rjags)
library(runjags)
library('coda')
message("Jags version: ",jags.version())
message(" For info in runjags check out:doi: 10.18637/jss.v071.i09")

setwd("/home/kostasl/workspace/zebrafishtrack/Rplots") ##sOME bUG REQUIRES THAT THIS IS RUN ON CONSOLE MANUALLY 
#setwd(here())
source("config_lib.R")
source("TrajectoryAnalysis.r")
source("HuntingEventAnalysis_lib.r")

setEnvFileLocations("HOME") #HOME,OFFICE,#LAPTOP
## To compile to different destination run:
# rmarkdown::render("ForagingStateAnalysis.Rmd",output_dir = paste0(strDataExportDir,'../foragingAnalysis') )

MIN_PATH_LENGTH <- 0.5
tsec_timeWindow <- 0 
thres_dispersion_class <- 0.2
##Clustering
Nclust <- 2
nsubsampleInterval <- G_APPROXFPS/2
vGroups <- c("LL","LE","NL","NE","DL","DE")
## Load datAllFrames
loaddatAllFrames <- function(forceReload = FALSE)
{
  if (!exists("datAllFrames") | forceReload)
  {
    attach(paste(strDatDir,"datAllFramesFix1_Ds-5-19.RData",sep="/"))
    attach(paste(strDatDir,"groupsrcdatListPerDataSet_Ds-5-19.RData",sep="/"))
  }
}


#Original Dispersion Record per frame
#datDispersion = readRDS(file=paste0(strDataExportDir,"/foragingState_Dispersion",tsec_timeWindow,"sec.rds") )
## Extended Dispersion Merged With maxDispersion Data
# Param tsec_timeWindow=0 default value loads pathstat calculated over the full event length - Not Confined to moving Time Window of X sec
loadDispersionData <- function(forceReload = FALSE,tsec_timeWindow=0)
{
  try(
    ##Check If Already Loaded
    if (!exists("datDispersion") | forceReload)
      datDispersion <<- readRDS(file=paste0(strDataStore,"/foragingState_Dispersion",tsec_timeWindow,"sec.rds") ) 
  )
  
  if (!exists("datDispersion"))
  {
    message("Calculate Trajectory Dispersions")
    loaddatAllFrames()
    datDispersion <<- calcTrajectoryDispersions(datAllFrames,tsec_timeWindow)
  }
  AllRange <<- range(datDispersion$Dispersion,na.rm=TRUE)
  tsec_timeWindow <<- tsec_timeWindow ##Change Global Ref to Last Call
  return(datDispersion)
}

## PathStat Data Merged onto Hunt Event based on initiation frame
loadHuntEventMergedWithPathStat <- function(tsec_timeWindow)
{
  
  datHEventDispersion <- data.frame()
  strFile <- paste0(strDataStore,"/huntEvent_mergedwith_Dispersion",tsec_timeWindow,"sec.rds")
  
  if (file.exists(strFile))
  {
    message("Loading from :",strFile )
  try(
    datHEventDispersion <- readRDS(file=strFile )
    )
  }else
  {
    message("Merged Data not generated yet ",strFile )
  }
  
## If we have not merged these records before, make them now
  if (!exists("datHEventDispersion") | !file.exists(strFile))
  { 
    loaddatAllFrames()
    datDispersion <- loadDispersionData_norm(tsec_timeWindow)
    datHuntLabelledEventsSBMerged_fixed <- getLabelledHuntEventsSet() # readRDS(file=paste(strDatDir,"/LabelledSet/",strProcDataFileName,".rds",sep="" ))
    datHEventDispersion <- mergeDispersionOntoHuntEvents(datDispersion,datAllFrames,datHuntLabelledEventsSBMerged_fixed)
  }
  
  return(datHEventDispersion)
}

## Check list of foragingStateDispersion files and return vector with the processed and available path-dispersion-msd Analysis timewindows 
getAvailablePathTimewindows <- function()
{
  
  # Check List of Available Calculated PathMeasure files  (Dispersion etc)
  # helper function : Convert WildCard to RegExp : glob2rx("foragingState_Dispersion???sec.rds", trim.head = FALSE, trim.tail = TRUE)
  lAvailableDispersionFiles <- dir(strDataStore, pattern = "foragingState_Dispersion[0-9]{1,3}sec.rds", full.names = FALSE, ignore.case = TRUE)
  vAvailabletimeWindows <- lapply( lAvailableDispersionFiles,FUN = function(s){  gsub(pattern = "[^0-9]", replacement = "", x = s)  }  )
  #Order them and Converr to Number
  vtimeWindows <- as.integer(unlist(vAvailabletimeWindows[order(as.integer(unlist(vAvailabletimeWindows)))] ) )
  message("Available timewindows:",paste(vAvailabletimeWindows,collapse=","))

  return (vtimeWindows)
}

getAvailablePathDomainsSizes <- function()
{
  #lBoundedTrajectoryFiles <- dir(strDataExportDir, pattern = "stat_boundedPathsB_R[0-9]{1,3}mm.rds", full.names = FALSE, ignore.case = TRUE)
  lBoundedTrajectoryFiles <- dir(strDataExportDir, pattern = "stat_boundedPathsB_R[[:digit:]]+\\.*[[:digit:]]*mm.rds", full.names = FALSE, ignore.case = TRUE)
  vAvailableDomainRadius <- lapply( lBoundedTrajectoryFiles,FUN = function(s){  gsub(pattern = ".rds", replacement = "", x = s)  }  )
  vAvailableDomainRadius <- lapply( vAvailableDomainRadius,FUN = function(s){  gsub(pattern = "[^0-9,.]", replacement = "", x = s)  }  )
  
  vAvailableDomainRadius <- as.numeric(unlist(vAvailableDomainRadius[order(as.numeric(unlist(vAvailableDomainRadius)))] ) )
  
  return(vAvailableDomainRadius)
}

##Re Run All Path Calculation 
generate_DispersionFiles <- function()
{
  ##Generate Files From Start 
  loaddatAllFrames()
  for (tt in seq(2,6,2) )
    calcTrajectoryDispersions(datAllFrames,tsec_timeWindow)
}


## iNvariance Principle Theoretical Mean Path Length
theoreticalMeanLength <- function(D,propFactor=1.0)
{
  A <- pi*( (D)^2)
  C <- 2*pi*(D)
  return(round(100*(propFactor* pi*A/C)) /100 )
}

```



```{r merge max larval-dispersion onto dispersion data events, echo=FALSE,cache=FALSE,results=FALSE,warning=FALSE}
## Attaches the max Dispersion found between both evoked and spontaneous trajectories of each larva
## This is used so we can combine S/E larval recordings to detect both exploration/ exploitation state - and normalize appropriatelly to the joined trajectrories between tests as if they were ## one 20min recording  
mergeRangeOfLarvalDispersionPerLarvaOntoDispersion <- function(datDispersion,datExpPairs,tsec_timeWindow)
{
    ## Merge Max Dispersion per larva Onto Dispersion data (so we can normalize on a per larva basis instead of experiment basis)
  ## Calc Normalization to Max Dispersion by combining both Spont And Exoked cond per larva
  ## Find Max Dispersion Per Experiement
  datDispersionMax <- data.frame(tapply(datDispersion$Dispersion,datDispersion$expID,max,na.rm = TRUE))
  datDispersionMin <- data.frame(tapply(datDispersion$Dispersion,datDispersion$expID,min,na.rm = TRUE))
  
  ## pair each experiemnt with its max dispersion between Spontaneous and Evoked conditions of a larva
  ## We use this struct to merge with Dispersion data of each frame / So as to normalize approprietelly
  datDispesionRange_Pairs <-  rbind.data.frame(
                                           cbind.data.frame(
                                             expID = as.character(datExpPairs$expID.S) ,
                                             groupID = as.character(datExpPairs$groupID.S),
                                              max_exp_Disp = datDispersionMax[as.character(datExpPairs$expID.S),],
                                              max_exp_Disp.C = datDispersionMax[as.character(datExpPairs$expID.E),],
                                              min_exp_Disp = datDispersionMin[as.character(datExpPairs$expID.S),],
                                              min_exp_Disp.C = datDispersionMin[as.character(datExpPairs$expID.E),]),
                                           cbind.data.frame(
                                                expID = as.character(datExpPairs$expID.E) ,
                                                groupID = as.character(datExpPairs$groupID.E),
                                                max_exp_Disp = datDispersionMax[as.character(datExpPairs$expID.E),],
                                                max_exp_Disp.C = datDispersionMax[as.character(datExpPairs$expID.S),],
                                                min_exp_Disp = datDispersionMin[as.character(datExpPairs$expID.E),],
                                                min_exp_Disp.C = datDispersionMin[as.character(datExpPairs$expID.S),])
                                            )
                                      
                                          
  ## Add col for Max/min Dispersion across Spont and Evoked conditions
  datDispesionRange_Pairs$max <- as.numeric(apply(datDispesionRange_Pairs[,3:4], 1, max,na.rm=TRUE)) 
  datDispesionRange_Pairs$min <- as.numeric(apply(datDispesionRange_Pairs[,5:6], 1, min,na.rm=TRUE)) 
  
  ##Make Simple frame for merging with dispersion data
  datMaxDispersionPerLarva <- cbind.data.frame(expID=as.character(datDispesionRange_Pairs$expID),
                                               groupID=as.character(datDispesionRange_Pairs$groupID),
                                               max_larval_Dispersion=(datDispesionRange_Pairs$max),
                                               min_larval_Dispersion=(datDispesionRange_Pairs$min),
                                               max_exp_Dispersion=(datDispesionRange_Pairs$max_exp_Disp), # Add The max Disp Recorded for this larva
                                               min_exp_Dispersion=(datDispesionRange_Pairs$min_exp_Disp) # Add The max Disp Recorded for this larva
                                               )
  datDispersionM <- merge(datDispersion,datMaxDispersionPerLarva,all.x = TRUE,by=c("expID","groupID"),no.dups=FALSE)

  #Calculate Range Normalized dispersion per larva - to match Marquez et al 2019
  ## Save  dispersion data normalized across Spont and evoked condition for each larva (saves time in future plotting)
  datDispersionM <- cbind.data.frame(datDispersionM,
                                     Dispersion_larval_norm=(datDispersionM$Dispersion-datDispersionM$min_larval_Dispersion) / (datDispersionM$max_larval_Dispersion-datDispersionM$min_larval_Dispersion) )

  ## Now Merge onto Dispersion Data 
  saveRDS(datDispersionM,file=paste0(strDataExportDir,"/foragingState_Dispersion_merged_rangeperLarva_",tsec_timeWindow,"sec.rds") )
  saveRDS(datMaxDispersionPerLarva,file=paste0(strDataExportDir,"/foragingState_max_Dispersion_perLarva_",tsec_timeWindow,"sec.rds") )
  message("Saved to:",paste0(strDataExportDir,"/foragingState_Dispersion_merged_rangeperLarva_",tsec_timeWindow,"sec.rds") )
  message("Saved to:",paste0(strDataExportDir,"/foragingState_max_Dispersion_perLarva_",tsec_timeWindow,"sec.rds") )

  return(datDispersionM)
}
```



```{r  merge hunt-events with dispersion data, fig.show="hold", out.width="50%", echo=FALSE, cache=FALSE,results=FALSE,message=FALSE,warning=FALSE }
source("DataLabelling/labelHuntEvents_lib.r")
source("HuntingEventAnalysis_lib.r")

#loadDispersionData(forceReload = TRUE,tsec_timeWindow = 0)
##Load Dispersion Data, check if data.frame has been extended with larva ranges, and merge if need to  have been added - 
loadDispersionData_norm <- function(tsec_timeWindow)
{
  
  try(rm("datDispersion"),silent=TRUE);
  strFile <- paste0(strDataExportDir,"foragingState_Dispersion_merged_rangeperLarva_",tsec_timeWindow,"sec.rds")
  if (file.exists(strFile))
  {
  try( {
      message("Loading ",strFile);
      datDispersion <<- readRDS(file=strFile ) ;
    }
    )
  }else
    message("No Dispersion data file found: ", strFile,"Attempting to generate now ...")
  ##If the Merged Version is not found then Make one
  if (!exists("datDispersion") | !file.exists(strFile))
  {
    datDispersion <- loadDispersionData(forceReload = TRUE,tsec_timeWindow)
  }
    ## Merge Max Dispersion on there - If it is not already there then Calculate and save 
  if (!any(grepl("max_larval_Dispersion",names(datDispersion)) ) | 
      !any(grepl("min_larval_Dispersion",names(datDispersion)) ) |
      !any(grepl("Dispersion_larval_norm", names(datDispersion)) )  )
    datDispersion <<- mergeRangeOfLarvalDispersionPerLarvaOntoDispersion(datDispersion,datExpPairs,tsec_timeWindow)
  
  return(datDispersion)
}

#load(file=paste(strDatDir,"/LabelledSet/",strProcDataFileName,".RData",sep="" )) ##Save With Dataset Idx Identifier
datHuntLabelledEventsSBMerged_fixed <- getLabelledHuntEventsSet() # readRDS(file=paste(strDatDir,"/LabelledSet/",strProcDataFileName,".rds",sep="" ))

##Clear Warningss : assign("last.warning", NULL, envir = baseenv()
## Link Evoked and Spontaneous Trajectories
datHuntStat <- makeHuntStat(datHuntLabelledEventsSBMerged_fixed)
datExpPairs <- getSpontaneousEvokedExperimentPairs(datHuntStat)
datHEventDispersion <<- loadHuntEventMergedWithPathStat(5)


loadDispersionData_norm(tsec_timeWindow)
## Check for max Calc Error
#datDispersion[datDispersion$Dispersion > datDispersion$max_Dispersion,]
```


```{r plot-trajectories-figures-function, fig.show="hold", out.width="50%", echo=FALSE ,results=FALSE,ref.label='setup',warning=FALSE}
#Function to plot trajectories for each larva coloured based on dispersion
pairedTrajPalette <- col2hex(col2rgb(brewer.pal(12,"Paired"),alpha = 1))

#
# Function Plot Individual Trajectories for a group, split between exploration and exploitation
# given a *global* normalized dispersion measures threshold 
#
plotGlobalNormDispersionTrajectories <- function(groupID, datAllFrames, datDispersion, datHEventDispersion,datExpPairs,TH_DISP = 0.2)
{
  
  datGroupExploreTraj <- datAllFrames[datDispersion[datDispersion$groupID %in% groupID & datDispersion$Dispersion/AllRange[2] >= TH_DISP,"frameRow"],]
  datGroupExploitTraj <- datAllFrames[datDispersion[datDispersion$groupID %in% groupID & datDispersion$Dispersion/AllRange[2] < TH_DISP ,"frameRow"],]
  
  ## ind Exploration Hunt Events 
  datExplorationHuntEvents <- datHEventDispersion[datHEventDispersion$Dispersion/AllRange[2] >= TH_DISP, ]
  ## ind Exploration Hunt Events 
  datExploitationHuntEvents <- datHEventDispersion[datHEventDispersion$Dispersion/AllRange[2] < TH_DISP, ]
  
  
  plotExploreExploitTrajectories(groupID,datGroupExploreTraj,datGroupExploitTraj, datExplorationHuntEvents, 
                                 datExploitationHuntEvents,datDispersion,
                                 datExpPairs[datExpPairs$groupID.E %in%  groupID | datExpPairs$groupID.S %in%  groupID, ]) ##Subset to Targeted groups
  
} ## end of plot Function
 
##
# Function Plot Individual Trajectories for a group, split between exploration and exploitation
# given a *local* normalized dispersion measures threshold / the classification is relative to the mobility measure of each larvae in each condition 
##
plotExpNormDispersionTrajectories <- function(groupID, datAllFrames, datDispersion,datHEventDispersion, datExpPairs,TH_DISP = 0.2)
{

  datGroupExploreTraj <- datAllFrames[datDispersion[datDispersion$groupID %in% groupID & datDispersion$Dispersion_norm >= TH_DISP,"frameRow"],]
  datGroupExploitTraj <- datAllFrames[datDispersion[datDispersion$groupID %in% groupID & datDispersion$Dispersion_norm <  TH_DISP,"frameRow"],]
   
  ## \TODO: Norm per larva in both spont and Evoked
  ## ind Exploration Hunt Events 
  datExplorationHuntEvents <- datHEventDispersion[datHEventDispersion$Dispersion_norm >= TH_DISP, ]
  
  ## ind Exploration Hunt Events 
  datExploitationHuntEvents <- datHEventDispersion[datHEventDispersion$Dispersion_norm < TH_DISP, ]
  
  ## Call Plot Function - Both Spont And Evoked plo tted on same figure
  plotExploreExploitTrajectories(groupID,datGroupExploreTraj,datGroupExploitTraj, datExplorationHuntEvents, 
                                 datExploitationHuntEvents,datDispersion,
                                 datExpPairs[datExpPairs$groupID.E %in%  groupID | datExpPairs$groupID.S %in%  groupID, ]) ##Subset to Targeted groups
  
} ## end of plot Functon


## TODO: plot NB Mix clustered traj
# Function Plot Individual Trajectories for a group, split between exploration and exploitation
# given based on threshold placed on the normalized dispersion of the trajectories from combined spont and evoked conditions of each larva .
##
plotNBMixGClusteredDispersionTrajectories <- function(groupID, datAllFrames, datDispersion, datHEventDispersion,datExpPairs,TH_DISP = 0.2)
{ 
  #load(file=paste0(strDataExportDir,'jagsModelTestResults_NBMixGroupclustDispersion_All.RData') )
  #datHEventDispersion <<- readRDS(file=paste0(strDataExportDir,"/huntEvent_mergedwith_Dispersion",tsec_timeWindow,"sec.rds") )
  datHEventDispersion <<- loadHuntEventMergedWithPathStat(5)
  ## Merge sparse Clustered Dispersions Results onto full Dispersion Data
  lparamsAll <- getMCMCNBGroupEstimatedParams(results.All,"All",2)
  if (!("clustID" %in% names(datSubDispersion)))
    datSubDispersion$clustID <- as.vector(lparamsAll$clustID)
  
  ##Add Clust ID on all Dispersion Data - interpolating the sparse   datSubDispersion
  datDispersion$clustID <- NA
  datDispersion[datSubDispersion$frameRow,"clustID"] <- datSubDispersion$clustID
  ##Fill in the gaps with the last value
  lastClustID <- NA
  idxA <- 1:NROW(datDispersion)
  for (i in 1:nsubsampleInterval )
  {
      datDispersion[idxA+i,"clustID"] <- datDispersion[idxA,"clustID"]
  }
    
  ##Merge Cluster ID onto Hunt Events
  datHEventDispersion <- merge(datHEventDispersion, cbind.data.frame (frameRow=datSubDispersion$frameRow,
                                                          #expID=datSubDispersion$expID,
                                                          #groupID=datSubDispersion$expID,
                                                          clustID=as.numeric(datSubDispersion$clustID) ),
                               by=c("frameRow"),all.x =TRUE,no.dups = FALSE)

  
  
  datGroupExploreTraj <- datAllFrames[datDispersion[datSubDispersion$groupID %in% groupID & datDispersion$clustID == 1,"frameRow"],]
  datGroupExploitTraj <- datAllFrames[datDispersion[datSubDispersion$groupID %in% groupID & datDispersion$clustID == 2,"frameRow"],]
  
  ## ind Exploration Hunt Events 
  datExplorationHuntEvents <- datHEventDispersion[datHEventDispersion$clustID == 1, ]
  ## ind Exploration Hunt Events 
  datExploitationHuntEvents <- datHEventDispersion[datHEventDispersion$clustID ==2, ]
  
  
  plotExploreExploitTrajectories(groupID,datGroupExploreTraj,datGroupExploitTraj, datExplorationHuntEvents, 
                                 datExploitationHuntEvents,datDispersion,
                                 datExpPairs[datExpPairs$groupID.E %in%  groupID | datExpPairs$groupID.S %in%  groupID, ],thin=5) ##Subset to Targeted groups
  
} ##

##
# Function Plot Individual Trajectories for a group, split between exploration and exploitation
# given based on threshold placed on the normalized dispersion of the trajectories from combined spont and evoked conditions of each larva .
##
plotLarvaNormDispersionTrajectories <- function(groupID, datAllFrames, datDispersion, datHEventDispersion,datExpPairs,TH_DISP = 0.2)
{ 
  datGroupExploreTraj <- datAllFrames[datDispersion[datDispersion$groupID %in% groupID & datDispersion$Dispersion_larval_norm >= TH_DISP,"frameRow"],]
  datGroupExploitTraj <- datAllFrames[datDispersion[datDispersion$groupID %in% groupID & datDispersion$Dispersion_larval_norm < TH_DISP,"frameRow"],]
  
  ## ind Exploration Hunt Events 
  datExplorationHuntEvents <- datHEventDispersion[datHEventDispersion$Dispersion_larval_norm >= TH_DISP, ]
  ## ind Exploration Hunt Events 
  datExploitationHuntEvents <- datHEventDispersion[datHEventDispersion$Dispersion_larval_norm < TH_DISP, ]
  
  
  plotExploreExploitTrajectories(groupID,datGroupExploreTraj,datGroupExploitTraj, datExplorationHuntEvents, 
                                 datExploitationHuntEvents,datDispersion,
                                 datExpPairs[datExpPairs$groupID.E %in%  groupID | datExpPairs$groupID.S %in%  groupID, ]) ##Subset to Targeted groups
  
} ##


## Plot function for scatter plot of colour coded larval trajectories, separated into explore and exploit vectors
## with Both Spont And Evoked plotted on same figure
###  datExpPairs - expID for Spont and Evoked for each larva
plotExploreExploitTrajectories <- function(groupID,datGroupExploreTraj,datGroupExploitTraj, datExplorationHuntEvents, datExploitationHuntEvents, datDispersion, datExpPairs, thin=3,TH_DISP = 0.2)
{
  
  #vexpID <-  unique(datGroupExploitTraj$exp) 
  #par(mfrow=c(2,NROW(vexpID))) ##MultiPlot Page
  #par(mar=c(1,1,1,1))
  #layout(matrix(seq(1,NROW(vexpID)), 2,NROW(vexpID) , byrow = TRUE))
  i <- 0
  for (j in 1:nrow(datExpPairs) )
  {
      e <- datExpPairs[j,]
      if (is.na(e$expID.E))
        next()
      x1  <- seq(0, 640 )
      y1  <- seq(0, 550 )

      #print(e)
      plot(0,0,ylim=range(y1),xlim=range(x1), type="l", col="red", main=paste(groupID[1],e$expID.E,"/",groupID[2],e$expID.S) )
      ## Evoked Exploration
      datTraj <- datGroupExploreTraj[datGroupExploreTraj$expID == as.character(e$expID.E) & !is.na(datGroupExploreTraj$posX),]
      if (NROW(datTraj))
      {
        idxplot <- seq(1,NROW(datTraj),thin)
        points(datTraj[idxplot,]$posX,datTraj[idxplot,]$posY,type="p", col=pairedTrajPalette[1], cex=0.1);
      }
      ## Add Hunt Events on Map
      # Evoked Exploration
      datSpotHunts.E.Explore <- datExplorationHuntEvents[datExplorationHuntEvents$expID == as.character(e$expID.E)  & !is.na(datExplorationHuntEvents$expID), ] 
      points(datSpotHunts.E.Explore$posX, datSpotHunts.E.Explore$posY, col=pairedTrajPalette[2], cex=1.2, pch=17) ## Triangle Explore
  
      ## Spontaneous Explore
      datTraj <- datGroupExploreTraj[datGroupExploreTraj$expID == as.character(e$expID.S) & !is.na(datGroupExploreTraj$posX),]
      if (NROW(datTraj))
      {
        idxplot <- seq(1,NROW(datTraj),thin)
        points(datTraj[idxplot,]$posX,datTraj[idxplot,]$posY,type="p", col=pairedTrajPalette[3], cex=0.1);
      }
      ## Spont Exploration
      datSpotHunts.S.Explore <- datExplorationHuntEvents[datExplorationHuntEvents$expID == as.character(e$expID.S)  & !is.na(datExplorationHuntEvents$expID), ] 
      points(datSpotHunts.S.Explore$posX, datSpotHunts.S.Explore$posY, col=pairedTrajPalette[4], cex=1.2, pch=17) ##  Triangle Explore
  
      
      ## Evoked Exploit
      datTraj <- datGroupExploitTraj[datGroupExploitTraj$expID == as.character(e$expID.E) & !is.na(datGroupExploitTraj$posX),]
      if (NROW(datTraj))
      {      
        idxplot <- seq(1,NROW(datTraj),thin)
        points(datTraj[idxplot,]$posX,datTraj[idxplot,]$posY,type="p",col=pairedTrajPalette[5], cex=0.1)
      }
      ## Evoked Exploitation
      datSpotHunts.E.Exploit <- datExploitationHuntEvents[datExploitationHuntEvents$expID == as.character(e$expID.E)  & !is.na(datExploitationHuntEvents$expID), ] 
      points(datSpotHunts.E.Exploit$posX, datSpotHunts.E.Exploit$posY,col=pairedTrajPalette[6], cex=1.2,pch=15) ## Square Evoked


      ## Spontaneous Exploit
      datTraj <- datGroupExploitTraj[datGroupExploitTraj$expID == as.character(e$expID.S) & !is.na(datGroupExploitTraj$posX),]
      if (NROW(datTraj))
      { 
        idxplot <- seq(1,NROW(datTraj),thin)
        points(datTraj[idxplot,]$posX,datTraj[idxplot,]$posY,type="p",col=pairedTrajPalette[7], cex=0.1)
      }
      ## Hunt Episodes Spont Exploitation
      datSpotHunts.S.Exploit <- datExploitationHuntEvents[datExploitationHuntEvents$expID == as.character(e$expID.S)  & !is.na(datExploitationHuntEvents$expID), ] 
      points(datSpotHunts.S.Exploit$posX, datSpotHunts.S.Exploit$posY,col=pairedTrajPalette[8], cex=1.2,pch=15) ## Square Evoked
  
      
      badd <- TRUE
      ## Add dispersion Time Line + Hunt Events + Norm threshold Threshold
      datDisp.S <- datDispersion[datDispersion$expID == as.character(e$expID.S) ,]
      datDisp.E <- datDispersion[datDispersion$expID == as.character(e$expID.E) ,]
      ## Sort by frameRo
      datDisp.S <- datDisp.S[order( as.numeric(datDisp.S$frameRow) ), ]
      datDisp.E <- datDisp.E[order( as.numeric(datDisp.E$frameRow) ), ]
            
      idxplot.S <- seq(min(1,NROW(datDisp.S)),max(1,NROW(datDisp.S)),thin)
      idxplot.E <- seq(min(1,NROW(datDisp.S)),max(1,NROW(datDisp.E)) ,thin)
      datDisp.S.frame <- as.numeric(datDisp.S[idxplot.S,]$frameRow)- min((as.numeric(datDisp.S[idxplot.S,]$frameRow) ),na.rm = TRUE ) #datAllFrames[datDisp.S[idxplot.S,]$frameRow,"frameN" ]
      datDisp.E.frame <- max(datDisp.S.frame,na.rm=TRUE) +  as.numeric(datDisp.E[idxplot.E,]$frameRow)-min(c(as.numeric(datDisp.E[idxplot.E,]$frameRow) ),na.rm = TRUE ) 
      
      ##frameN restarts to 0 for each event so best use frameRow
      plot(datDisp.S.frame/G_APPROXFPS ,datDisp.S[idxplot.S,]$Dispersion,type="l" ,ylim=c(0,10),xlim=c(0,max(c(0,datDisp.E.frame),na.rm =TRUE)/G_APPROXFPS ),xlab="(sec)",
           ylab="Dispersal (mm)", col=colourDataScheme[[ as.character(e$groupID.S)  ]] )
      lines(datDisp.E.frame/G_APPROXFPS, datDisp.E[idxplot.E,]$Dispersion,type="l", col=colourDataScheme[[ as.character(e$groupID.E)  ]] )
      
      ##All Hunt larva hunt events together
      datSpotHunts.S <- rbind(datSpotHunts.S.Exploit,datSpotHunts.S.Explore)
      datSpotHunts.E <- rbind(datSpotHunts.E.Exploit,datSpotHunts.E.Explore)  
      
      ##Add Hunt Event ##datDisp.S[datDisp.S$frameRow == datSpotHunts.S$frameRow,]$Dispersion <- fails cause Disp data may be missing at hunt event frame
      ## Use FrameRow As timepoint sequence - reset to 0 using min(frameRow) for event, and attach Evoked to the back of spontaneous
      points( (as.numeric(datSpotHunts.S$frameRow)-min(as.numeric(datDisp.S[idxplot.S,]$frameRow),na.rm=TRUE ) )/G_APPROXFPS, rep(-0.1,times=NROW(datSpotHunts.S$frameN)), cex=1, pch=17)
      points( (max(idxplot.S) +  as.numeric(datSpotHunts.E$frameRow)-min(as.numeric(datSpotHunts.E$frameRow)))/G_APPROXFPS, rep(-0.1,times=NROW(datSpotHunts.E$frameN)) ,cex=1,pch=17)
      ##Show Larval Norm Threshold - Draw line
      thres_Dispersion_mm <- min((datDisp.E[datDisp.E$Dispersion_larval_norm >= TH_DISP, ] $Dispersion),na.rm=TRUE )
      segments(0,thres_Dispersion_mm, max(datDisp.E.frame,na.rm=TRUE)/G_APPROXFPS,
               thres_Dispersion_mm,lty=3)
      
      
      #stopifnot(i < 5)
      i <- i+1
  } ## For Each Event
    
}## End of Function 


```



## Detect Exploration -Exploitation via dispersion
 
 In Marquez et al. 2019 Ext Fig 3a, the dispersion of each larva is normalized against its own range before the overall (bimodal) distribution is shown.
 The normalized dispersion distributions  of each larva are used to detect the threshold that separates the exploitation and exploration state.  
 They report (Extended Data Fig. 3a), substantially higher dispersal in the exploration state (9.6 ± 2.5 mm, mean ± s.d., n = 36 animals) than in the exploitation state (2.3 ± 1.3 mm, n = 36 animals).

 Using my tracking data I calculated the dispersion at each tracked video frame and plot the distribution to examine if they are bimodal (here using the `r tsec_timeWindow` seconds window).
However, my tracking of each larva is limited to 10 min, and includes only the centre of the arena, but in Marquez et al. 2019 each larva is recorded *for 50-80 min*, while the mean duration of each state is reported to be on average, the *exploitation state persists for 7.1 ± 3.9 min*, and *exploration state persists for 5.5 ± 6.2 min*
(mean ± s.d., n = 36 animals). The duration of each state follows an exponential distribution (λ = 0.17 min−1
for exploitation, λ = 0.22 min−1 for exploration, pooled distribution of n = 36 animals) see (raw data shown on Ext. Fig 7a).

Unfortunatelly with my 10 min recordings for each larvae, it is most likely that I will not observe their behaviour in both states, but likely only observe them in on of these states. This is added ontop the fact that I do not record around the edges of the arena, as they do to see them run around.
Therefore, normalizing and setting a threshold on a per larva basis may not be a good idea.
Perhaps it is best I combine the trajectories of spontaneous and evoked activity for each larva so as to obtain 20min of observation time. 

 Without normalizing the distribution is shown on the left, and a version normalized per max dispersion measured in each experiment is on the right :
 
```{r dispersion histograms across groups, fig.show="hold", out.width="33%", echo=FALSE, results='hide'  }
loadDispersionData()

hist(datDispersion$Dispersion,breaks=50,main="(All groups): Dispersion lengths per experiment ",xlab="Dispersion (mm)")
hist(datDispersion$Dispersion_norm,breaks=50,main="(All groups): Dispersion normalized",xlab="Dispersion (exp. norm)")
hist(datDispersion$Dispersion_larval_norm ,breaks=50,main="(All groups): Dispersion normalized per larva",xlab="Dispersion (larva norm)")


```
We look at each rearing group separatelly, while combining their evoked and spontaneous conditions

```{r dispersion histograms per group across conditions, fig.show="hold", out.width="33%", echo=FALSE, results='hide'  }
hist(datDispersion[datDispersion$groupID %in% c('LE','LL'), ]$Dispersion,breaks=50,main="LF Evoked+Spont.",xlab="Dispersion (mm)",col=colourDataScheme$LF$Evoked)
hist(datDispersion[datDispersion$groupID %in% c('NE','NL'), ]$Dispersion,breaks=50,main="NF Evoked+Spont.",xlab="Dispersion (mm)",col=colourDataScheme$NF$Evoked)
hist(datDispersion[datDispersion$groupID %in% c('DE','DL'), ]$Dispersion,breaks=50,main="DF Evoked+Spont.",xlab="Dispersion (mm)",col=colourDataScheme$DF$Evoked)

```


We then plot each experimental group individually, also examining the dispersion in evoked (in the presence of prey) and spontaneous (no prey) conditions separatellly.
Next we plot these for each experimental condition individually (non-Normalized):
```{r dispersion histograms per group per condition, fig.show="hold", out.width="33%", echo=FALSE, results='hide'  }
# 
# ## Normed over all Recorded Dispersions
 hist(datDispersion[datDispersion$groupID == 'LE', ]$Dispersion,breaks=100,main="LF Spontaneous",xlab="Dispersion (mm)",col=colourDataScheme$LF$Spont)
 hist(datDispersion[datDispersion$groupID == 'NE', ]$Dispersion,breaks=100,main="NF Spontaneous",xlab="Dispersion (mm)",col=colourDataScheme$NF$Spont)
 hist(datDispersion[datDispersion$groupID == 'DE', ]$Dispersion,breaks=100,main="DF Spontaneous",xlab="Dispersion (mm)",col=colourDataScheme$DF$Spont)

 hist(datDispersion[datDispersion$groupID == 'LL', ]$Dispersion,breaks=100,main="LF Evoked",xlab="Dispersion (mm)",col=colourDataScheme$LF$Evoked)
 hist(datDispersion[datDispersion$groupID == 'NL', ]$Dispersion,breaks=100,main="NF Evoked",xlab="Dispersion (mm)",col=colourDataScheme$NF$Evoked)
 hist(datDispersion[datDispersion$groupID == 'DL', ]$Dispersion,breaks=100,main="DF Evoked",xlab="Dispersion (mm)",col=colourDataScheme$DF$Evoked)
```
 
Smooth estimates using a gaussian kernel show a shift towards exploitation for the pooled *LF* trajectories, measured across the whole event duration (at 1sec intervals):

```{r dispersion densities WholePath per larva-Split E-S, fig.show="hold", out.width="33%", echo=FALSE, results='hide' }
loadDispersionData(TRUE, tsec_timeWindow = 0)
 ## plot est, Densities Compare Spont to Evoked
 BW=0.2
 plot(density(datDispersion[datDispersion$groupID == 'NE', ]$Dispersion, kernel="gaussian",na.rm=TRUE, bw=BW), lwd=4, ylim=c(0,0.7), col=colourDataScheme$NF$Spont,main="NF  ",xlab="Full path Dispersion (mm)",lty=1  )
 lines(density(datDispersion[datDispersion$groupID == 'NL', ]$Dispersion,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$NF$Evoked,main=NA,lty=2)
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$NF$Spont,colourDataScheme$NF$Evoked),lwd=3 ) 
 
  plot(density(datDispersion[datDispersion$groupID == 'LE', ]$Dispersion, kernel="gaussian",na.rm=TRUE,bw=BW), lwd=4, ylim=c(0,0.7),col=colourDataScheme$LF$Spont,main="LF  ",xlab="Full path dispersion (mm)",lty=1 )
 lines(density(datDispersion[datDispersion$groupID == 'LL', ]$Dispersion,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$LF$Evoked,main=NA,lty=2 )
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$LF$Spont,colourDataScheme$LF$Evoked),lwd=3 ) 

 plot(density(datDispersion[datDispersion$groupID == 'DE', ]$Dispersion, kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4, ylim=c(0,0.7),col=colourDataScheme$DF$Spont,main="DF  ",xlab="Full path dispersion (mm)",lty=1 )
 lines(density(datDispersion[datDispersion$groupID == 'DL', ]$Dispersion,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$DF$Evoked,main=NA,lty=2 )
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$DF$Spont,colourDataScheme$DF$Evoked),lwd=3 ) 

```
These look rather uniform across all groups. But if we examine the dispersion generated over a particular duration time-window, here 20 sec :


```{r dispersion densities 20sec Path per larva-Split E-S, fig.show="hold", out.width="33%", echo=FALSE, results='hide' }
loadDispersionData(TRUE, tsec_timeWindow = 20)
 ## plot est, Densities Compare Spont to Evoked
 BW=0.2
 plot(density(datDispersion[datDispersion$groupID == 'NE', ]$Dispersion, kernel="gaussian",na.rm=TRUE, bw=BW), lwd=4, ylim=c(0,0.7), col=colourDataScheme$NF$Spont,main="NF  ",xlab="20sec path dispersion (mm)",lty=1  )
 lines(density(datDispersion[datDispersion$groupID == 'NL', ]$Dispersion,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$NF$Evoked,main=NA,lty=2)
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$NF$Spont,colourDataScheme$NF$Evoked),lwd=3 ) 
 
  plot(density(datDispersion[datDispersion$groupID == 'LE', ]$Dispersion, kernel="gaussian",na.rm=TRUE,bw=BW), lwd=4, ylim=c(0,0.7),col=colourDataScheme$LF$Spont,main="LF  ",xlab="20sec path dispersion (mm)",lty=1 )
 lines(density(datDispersion[datDispersion$groupID == 'LL', ]$Dispersion,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$LF$Evoked,main=NA,lty=2 )
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$LF$Spont,colourDataScheme$LF$Evoked),lwd=3 ) 

 plot(density(datDispersion[datDispersion$groupID == 'DE', ]$Dispersion, kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4, ylim=c(0,0.7),col=colourDataScheme$DF$Spont,main="DF  ",xlab="20sec path dispersion (mm)",lty=1 )
 lines(density(datDispersion[datDispersion$groupID == 'DL', ]$Dispersion,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$DF$Evoked,main=NA,lty=2 )
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$DF$Spont,colourDataScheme$DF$Evoked),lwd=3 ) 

```
<!-- For completness, the following dispersions have been normalized to maximum trajectory dispersion found across all experiments (*global normalization*): -->
```{r plot globally normalized dispersion distributions, fig.show="hold", out.width="33%", echo=FALSE, results='hide',include=FALSE,eval=FALSE  }

# ## Normed over all Recorded Dispersions
 hist(datDispersion[datDispersion$groupID == 'LE', ]$Dispersion/AllRange[2],breaks=100,main="LF Spontaneous",xlab="Dispersion (global norm. )")
 hist(datDispersion[datDispersion$groupID == 'NE', ]$Dispersion/AllRange[2],breaks=100,main="NF Spontaneous",xlab="Dispersion (global norm. )")
 hist(datDispersion[datDispersion$groupID == 'DE', ]$Dispersion/AllRange[2],breaks=100,main="DF Spontaneous",xlab="Dispersion (global norm. )")

 hist(datDispersion[datDispersion$groupID == 'LL', ]$Dispersion/AllRange[2],breaks=100,main="LF Evoked",xlab="Dispersion (global norm. .)")
 hist(datDispersion[datDispersion$groupID == 'NL', ]$Dispersion/AllRange[2],breaks=100,main="NF Evoked",xlab="Dispersion (global norm. )")
 hist(datDispersion[datDispersion$groupID == 'DL', ]$Dispersion/AllRange[2],breaks=100,main="DF Evoked",xlab="Dispersion (global norm. )")
 
```

Here differences in LF having larger dispersion within the 20sec time-frame are evident, combined with the results of theprevious figures on dispersion over the whole path being uniform, these results imply **LF do not explore the ROI with higher dispersal, but they are quicker to disperse**.
*In the absence of prey, dispersions grow faster in LF and DF*.

### Normalized dispersion per experiment

Next, we examine the same dispesions normalized against the maximum dispersion calculated in the trajectory length of the respective experiment.
Each measured dispersion is divided by the max dispersion trajectory experiment,
(ie for each larva  this can be different in evoked or spontaneous conditions).

```{r plot normalized dispersion distributions, fig.show="hold", out.width="33%", echo=FALSE, results='hide' }
### Normed Per Larva
tsec_timeWindow <- 20
datDispersion <- loadDispersionData_norm(tsec_timeWindow)
strXLab <- paste(tsec_timeWindow,"sec Dispersion  (norm per exp.)")
hist(datDispersion[datDispersion$groupID == 'LE', ]$Dispersion_norm,breaks=50,main="LF Spontaneous",xlab=strXLab, col=colourDataScheme$LF$Spont)
hist(datDispersion[datDispersion$groupID == 'NE', ]$Dispersion_norm,breaks=50,main="NF Spontaneous",xlab=strXLab, col=colourDataScheme$NF$Spont)
hist(datDispersion[datDispersion$groupID == 'DE', ]$Dispersion_norm,breaks=50,main="DF Spontaneous",xlab=strXLab, col=colourDataScheme$DF$Spont)

hist(datDispersion[datDispersion$groupID == 'LL', ]$Dispersion_norm,breaks=50,main="LF Evoked",xlab=strXLab,col=colourDataScheme$LF$Evoked)
hist(datDispersion[datDispersion$groupID == 'NL', ]$Dispersion_norm,breaks=50,main="NF Evoked",xlab=strXLab,col=colourDataScheme$NF$Evoked)
hist(datDispersion[datDispersion$groupID == 'DL', ]$Dispersion_norm,breaks=50,main="DF Evoked",xlab=strXLab,col=colourDataScheme$DF$Evoked)

```

### Normalized dispersion per larva combined test conditions

Because each larva is recorded in two conditions, and as Marquez et al 2019 report that the foraging state switching can be seen intact both in the presence and in the absence of prey , we may then combine our spontaneous and evoked condition recordings and treat them as a single unit,  thus allowing us to  normalize each larvas trajectories to the max dispersion found across both its test conditions.  In this manner each larva's dispersion is examined across a 20min recording session.

```{r dispersion histogram normalized per larva, fig.show="hold", out.width="33%", echo=FALSE, results='hide' }
### Dispesions distributions Normalized on Per Larva basis - 
datDispersion <- loadDispersionData_norm(tsec_timeWindow)
hist(datDispersion[datDispersion$groupID %in% c('LE','LL'), ]$Dispersion_larval_norm, breaks=100,main="LF S+E ",xlab="Dispersion  (norm per larva)")
hist(datDispersion[datDispersion$groupID %in% c('NE','NL'), ]$Dispersion_larval_norm, breaks=100,main="NF S+E",xlab="Dispersion  (norm per larva)")
hist(datDispersion[datDispersion$groupID %in% c('DE','DL'), ]$Dispersion_larval_norm, breaks=100,main="DF S+E",xlab="Dispersion  (norm per larva)")

```

#### Histograms of normalized dispersion per larva, split S-E conditions 


Separating Spontaneous from Evoked Conditions we see a potential shift toward lower dispersion in the presence of prey:

```{r dispersion histogram normalized per larva-Split E-S, fig.show="hold", out.width="50%", echo=FALSE, results='hide' }
### Dispesions distributions Normalized on Per Larva basis - 

hist(datDispersion[datDispersion$groupID %in% c('LE'), ]$Dispersion_larval_norm, breaks=100,main="LF Spont ", xlab="Dispersion  (norm per larva)",col=colourDataScheme$LF$Spont)
hist(datDispersion[datDispersion$groupID %in% c('LL'), ]$Dispersion_larval_norm, breaks=100,main="LF Evoked ",xlab="Dispersion  (norm per larva)",col=colourDataScheme$LF$Evoked)

hist(datDispersion[datDispersion$groupID %in% c('NE'), ]$Dispersion_larval_norm, breaks=100,main="NF Spont ", xlab="Dispersion  (norm per larva)",col=colourDataScheme$NF$Spont)
hist(datDispersion[datDispersion$groupID %in% c('NL'), ]$Dispersion_larval_norm, breaks=100,main="NF Evoked ",xlab="Dispersion  (norm per larva)", col=colourDataScheme$NF$Evoked)

hist(datDispersion[datDispersion$groupID %in% c('DE'), ]$Dispersion_larval_norm, breaks=100,main="DF Spont ", xlab="Dispersion  (norm per larva)",col=colourDataScheme$DF$Spont)
hist(datDispersion[datDispersion$groupID %in% c('DL'), ]$Dispersion_larval_norm, breaks=100,main="DF Evoked ",xlab="Dispersion  (norm per larva)",col=colourDataScheme$DF$Evoked)
```



#### Density estimation normalized dispersion per larva - compare Evoked to Spontaneous

Next I estimated densities using a gaussian kernel, allowing direct comparison between test conditions shows LF dispersions are modified by the presence of prey.

```{r dispersion densities normalized per larva-Split E-S, fig.show="hold", out.width="33%", echo=FALSE, results='hide' }
 ## plot est, Densities Compare Spont to Evoked
 BW=0.01
 ylimUp <- 5
 plot(density(datDispersion[datDispersion$groupID == 'NE', ]$Dispersion_larval_norm, kernel="gaussian",na.rm=TRUE, bw=BW), lwd=4, ylim=c(0,ylimUp), col=colourDataScheme$NF$Spont,main="NF  ",xlab="Dispersion (norm. per larva)",lty=1  )
 lines(density(datDispersion[datDispersion$groupID == 'NL', ]$Dispersion_larval_norm,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$NF$Evoked,main=NA,lty=2)
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$NF$Spont,colourDataScheme$NF$Evoked),lwd=3 ) 
 
 plot(density(datDispersion[datDispersion$groupID == 'LE', ]$Dispersion_larval_norm, kernel="gaussian",na.rm=TRUE,bw=BW), lwd=4, ylim=c(0,ylimUp),col=colourDataScheme$LF$Spont,main="LF  ",xlab="Dispersion (norm. per larva)",lty=1 )
 lines(density(datDispersion[datDispersion$groupID == 'LL', ]$Dispersion_larval_norm,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$LF$Evoked,main=NA,lty=2 )
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$LF$Spont,colourDataScheme$LF$Evoked),lwd=3 ) 

 plot(density(datDispersion[datDispersion$groupID == 'DE', ]$Dispersion_larval_norm, kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4, ylim=c(0,ylimUp),col=colourDataScheme$DF$Spont,main="DF  ",xlab="Dispersion (norm. per larva)",lty=1 )
 lines(density(datDispersion[datDispersion$groupID == 'DL', ]$Dispersion_larval_norm,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$DF$Evoked,main=NA,lty=2 )
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$DF$Spont,colourDataScheme$DF$Evoked),lwd=3 ) 
```

#### Maximum dispersion per larva
Then examining the maximum larval dispersions over the full event path, we find they look similar between groups :
I will use these max values to normalize dispersions for each larva (as in Marquez et al 2019).

#### Compare distribution of max dispersion per larva

Full Path:
```{r Max-dispersion histogram plots, fig.show="hold", out.width="50%", echo=FALSE, results='hide',fig.cap="Histograms of max dispersion per larva using  the full event trajectories - No time sliding time window,  and 20sec duration paths" }

##### Maximum Dispersions Per Larva- 
hist_MaxDispersionPerLarva <- function(tsec_timeWindow)
{
  XLIM <- c(0,15)
  strFileName <- paste0(strDataExportDir,"/foragingState_max_Dispersion_perLarva_",tsec_timeWindow,"sec.rds")
  message("Loaded max disp precalc :",strFileName)
  datMaxDispersionPerLarva <- readRDS(file=strFileName )
  nBreaks=seq(0,13,1)
  ylimUp <- 35
  
  ## Max reported is across NE/NL - so checking either condition would suffice to get the max for each larva
  datMaxDispersionPerLarva.LF <- datMaxDispersionPerLarva[datMaxDispersionPerLarva$expID %in% datExpPairs[datExpPairs$groupID.S == 'LE' ,]$expID.S, ]$max_larval_Dispersion
  datMaxDispersionPerLarva.NF <- datMaxDispersionPerLarva[datMaxDispersionPerLarva$expID %in% datExpPairs[datExpPairs$groupID.S == 'NE' ,]$expID.S, ]$max_larval_Dispersion
  datMaxDispersionPerLarva.DF <- datMaxDispersionPerLarva[datMaxDispersionPerLarva$expID %in% datExpPairs[datExpPairs$groupID.S == 'DE' ,]$expID.S, ]$max_larval_Dispersion 
  
  # plot histograms
  datMaxDispersionPerLarva.NF_hist <- hist((datMaxDispersionPerLarva.NF),breaks=nBreaks, plot=FALSE)
  datMaxDispersionPerLarva.LF_hist <- hist((datMaxDispersionPerLarva.LF) ,breaks=nBreaks, plot=FALSE)
  datMaxDispersionPerLarva.DF_hist <- hist((datMaxDispersionPerLarva.DF) ,breaks=nBreaks, plot=FALSE)
  
  plot(datMaxDispersionPerLarva.NF_hist$mids,datMaxDispersionPerLarva.NF_hist$counts,
        main=paste("Histogram of max-dispersal per larva ",tsec_timeWindow,"sec"),
                                       xlab="Max. dispersion  per larva (mm)", xlim=XLIM,
                                       ylab="Number of larvae",
                                      pch=pointTypeScheme$NL, lty=lineTypeL.NF,
                                      col=colourDataScheme$NF$Evoked, ylim=c(0,ylimUp),type="b")
  
  points(datMaxDispersionPerLarva.NF_hist$mids,datMaxDispersionPerLarva.LF_hist$counts, 
                                        xlim=XLIM, pch=pointTypeScheme$LL,  col=colourDataScheme$LF$Evoked,lty=lineTypeL.LF, ylim=c(0,ylimUp),type="b")
  
  points(datMaxDispersionPerLarva.DF_hist$mids,datMaxDispersionPerLarva.DF_hist$counts, lty=lineTypeL.DF,
                                       xlim=XLIM,pch=pointTypeScheme$DL,
                                      col=colourDataScheme$DF$Evoked, ylim=c(0,ylimUp),type="b")
  
  legend("topleft",c("NF","LF","DF"),pch=c(pointTypeScheme$NL,pointTypeScheme$LL,pointTypeScheme$DL) , lty=c(lineTypeL.NF,lineTypeL.LF,lineTypeL.DF),col=c(colourDataScheme$NF$Evoked,colourDataScheme$LF$Evoked,colourDataScheme$DF$Evoked),lwd=3 ) 
  
  return(datMaxDispersionPerLarva)
}


datMaxDispersionPerLarva_All <- hist_MaxDispersionPerLarva(0)
datMaxDispersionPerLarva_20sec <-hist_MaxDispersionPerLarva(20)
```


```{r  max-dispersion densities compare groups, fig.show="hold", out.width="50%", echo=FALSE, cache=TRUE,eval=FALSE }
 ## plot est, Densities Compare Spont to Evoked
 pBW <- 0.3
 ylimUp <- 1
 plot(density(datMaxDispersionPerLarva.NF, kernel="gaussian",na.rm=TRUE, bw=pBW), lwd=4, ylim=c(0,ylimUp), col=colourDataScheme$NF$Evoked,main="Maximum Dispersion Per Larva  ",xlab="Dispersion (mm)",lty=lineTypeL.NF  )
lines(density((datMaxDispersionPerLarva.LF), kernel="gaussian",na.rm=TRUE,bw=pBW), lwd=4, ylim=c(0,ylimUp),col=colourDataScheme$LF$Evoked,main=NA,xlab=NA,lty=lineTypeL.LF )
lines(density((datMaxDispersionPerLarva.DF), kernel="gaussian",na.rm=TRUE,bw=pBW),lwd=4, ylim=c(0,ylimUp),col=colourDataScheme$DF$Evoked,main=NA,xlab=NA,lty=lineTypeL.DF )


```

##### Compare max dispersion distributions between conditions 

It appears that the max dispersions do not differ much between spontaneous and evoked conditions for the DF group, 
while there seems to be some evidence that  LF Larvae explore more in the absence of prey and perhaps,suprisingly, NF larvae explore less in the absence of prey.
Maybe these could make sense under an expected reward paradigm, given experience.


```{r max-dispersion per larva densities split conditions, fig.show="hold", out.width="33%", echo=FALSE, cache=FALSE }
 ## plot est, Densities Compare Spont to Evoked

datMaxDispersionPerLarva <- datMaxDispersionPerLarva_20sec
  # # extract Evoked to Spont max disp data
   datMaxDispersionPerExp.NF.Spont <- datMaxDispersionPerLarva[datMaxDispersionPerLarva$expID %in% datExpPairs[datExpPairs$groupID.S == 'NE' ,]$expID.S, ]$max_exp_Dispersion
   datMaxDispersionPerExp.NF.Evoked <- datMaxDispersionPerLarva[datMaxDispersionPerLarva$expID %in% datExpPairs[datExpPairs$groupID.E == 'NL' ,]$expID.E, ]$max_exp_Dispersion
   datMaxDispersionPerExp.LF.Spont <- datMaxDispersionPerLarva[datMaxDispersionPerLarva$expID %in% datExpPairs[datExpPairs$groupID.S == 'LE' ,]$expID.S, ]$max_exp_Dispersion 
   datMaxDispersionPerExp.LF.Evoked <- datMaxDispersionPerLarva[datMaxDispersionPerLarva$expID %in% datExpPairs[datExpPairs$groupID.E == 'LL' ,]$expID.E, ]$max_exp_Dispersion
   datMaxDispersionPerExp.DF.Spont <- datMaxDispersionPerLarva[datMaxDispersionPerLarva$expID %in% datExpPairs[datExpPairs$groupID.S == 'DE' ,]$expID.S, ]$max_exp_Dispersion
   datMaxDispersionPerExp.DF.Evoked <- datMaxDispersionPerLarva[datMaxDispersionPerLarva$expID %in% datExpPairs[datExpPairs$groupID.E == 'DL' ,]$expID.E, ]$max_exp_Dispersion
   

 ylimUp <- 0.5
  pBW <- 1
 plot(density(datMaxDispersionPerExp.NF.Spont, kernel="gaussian",na.rm=TRUE, bw=pBW), lwd=4, ylim=c(0,ylimUp), col=colourDataScheme$NF$Spont,main="NF Trajectories  ",xlab="Max Dispersion (mm)",lty=1  )
 lines(density(datMaxDispersionPerExp.NF.Evoked,kernel="gaussian",na.rm=TRUE,bw=pBW),lwd=4,col=colourDataScheme$NF$Evoked,main=NA,lty=2)
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$NF$Spont,colourDataScheme$NF$Evoked),lwd=3 ) 
 
 
 plot(density(datMaxDispersionPerExp.LF.Spont, kernel="gaussian",na.rm=TRUE,bw=pBW), lwd=4, ylim=c(0,ylimUp),col=colourDataScheme$LF$Spont,main="LF  Trajectories",xlab="Max Dispersion (mm)",lty=1 )
 lines(density(datMaxDispersionPerExp.LF.Evoked,kernel="gaussian",na.rm=TRUE,bw=pBW),lwd=4,col=colourDataScheme$LF$Evoked,main=NA,lty=2 )
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$LF$Spont,colourDataScheme$LF$Evoked),lwd=3 ) 

 plot(density(datMaxDispersionPerExp.DF.Spont, kernel="gaussian",na.rm=TRUE,bw=pBW),lwd=4, ylim=c(0,ylimUp),col=colourDataScheme$DF$Spont,main="DF  Trajectories",xlab="max Dispersion (mm)",lty=1 )
 lines(density(datMaxDispersionPerExp.DF.Evoked,kernel="gaussian",na.rm=TRUE,bw=pBW),lwd=4,col=colourDataScheme$DF$Evoked,main=NA,lty=2 )
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$DF$Spont,colourDataScheme$DF$Evoked),lwd=3 ) 
```

## Path length and dispersion ratio distributions 

Within Low dispersions hides a locomotive behaviour of pause, where the larva is not actually moving. We want to explore how experience modifies their locomotion strategy and thus this is best done by examining dispersion in relation to the distance travelled. Particularly I will look into a a state of locomotion pause, when the larva stop moving. 

Thus, similar to the measure of dispersion, we plot the 5sec recent trajectory lengths over all movement and over hunt event initiations, side by side:
### Distributions of path length


```{r length histograms per group across conditions, fig.show="hold", out.width="50%", echo=FALSE, results='hide'  }
tsec_timeWindow <- 5
datDispersion <- loadDispersionData(F,tsec_timeWindow)
xbreaks <-seq(0,max(datDispersion$Length,na.rm=TRUE)+2,2)
datHEventDispersion <- loadHuntEventMergedWithPathStat(tsec_timeWindow)

h_Length_NE <- hist(datDispersion[datDispersion$groupID %in% c('NE'), ]$Length,breaks=xbreaks,main="NF Spont.",xlab="Length (mm)",col=colourDataScheme$NF$Spont)
h_Length_NL <- hist(datDispersion[datDispersion$groupID %in% c('NL'), ]$Length,breaks=xbreaks,main="NF Evoked.",xlab="Length (mm)",col=colourDataScheme$NF$Evoked)
h_Length_LE <- hist(datDispersion[datDispersion$groupID %in% c('LE'), ]$Length,breaks=xbreaks,main="LF Spont.",xlab="Length (mm)",col=colourDataScheme$LF$Spont)
h_Length_LL <- hist(datDispersion[datDispersion$groupID %in% c('LL'), ]$Length,breaks=xbreaks,main="LF Evoked.",xlab="Length (mm)",col=colourDataScheme$LF$Evoked)
h_Length_DE <- hist(datDispersion[datDispersion$groupID %in% c('DE'), ]$Length,breaks=xbreaks,main="DF Spont.",xlab="Length (mm)",col=colourDataScheme$DF$Spont)
h_Length_DL <- hist(datDispersion[datDispersion$groupID %in% c('DL'), ]$Length,breaks=xbreaks,main="DF Evoked.",xlab="Length (mm)",col=colourDataScheme$DF$Evoked)

hist(datHEventDispersion[datHEventDispersion$groupID=='NE', ]$Length,breaks=xbreaks,main="NF Spont Hunt-events",xlab="Length",col=colourDataScheme$NF$Spont)
hist(datHEventDispersion[datHEventDispersion$groupID=='NL', ]$Length,breaks=xbreaks,main="NF Evoked Hunt-events",xlab="Length",col=colourDataScheme$NF$Evoked)
hist(datHEventDispersion[datHEventDispersion$groupID=='LE', ]$Length,breaks=xbreaks,main="LF Spont Hunt-events",xlab="Length ",col=colourDataScheme$LF$Spont)
hist(datHEventDispersion[datHEventDispersion$groupID=='LL', ]$Length,breaks=xbreaks,main="LF Evoked Hunt-events",xlab="Length ",col=colourDataScheme$LF$Evoked)
hist(datHEventDispersion[datHEventDispersion$groupID=='DE', ]$Length,breaks=xbreaks,main="DF Spont Hunt-events",xlab="Length",col=colourDataScheme$DF$Spont)
hist(datHEventDispersion[datHEventDispersion$groupID=='DL', ]$Length,breaks=xbreaks,main="DF Evoked Hunt-events",xlab="Length",col=colourDataScheme$DF$Evoked)

```

Comparing between general and hunt-event lengths it appears:

  - path lengths can be bimodal, like dispersions, in spontaneous conditions
  - LF Show higher motility to controls in both conditions
  - LF Spont. Shows overal higher motility to controls- Low occupancy in small movement mode
  - Locomotion in Evoked conditions  shows higher motility, and motion range, than Spontaneous. 
  - Evoked Hunt events occur over the shorter movement sub-range/mode of the overall distribution

To better examine tendencies to move towards dispersing trajectories we need to account for the effect of general motion, ie the length of a trajectory.
Here I examine recent dispersion as a ratio of recent trajectory length (5 sec window). A ration of 0.5 means larva moved in a straight line, as dispersal is the *radius* not the diameter of the  circle encompassing the recent trajectory

I next plot on logarithmic scale the percentage of each Path length and try to see if a power law like regime exists in the distribution, but also if the presence of prey changes the linear - drop off regime of the distribution. This is inspired by Fig 3 from Viswanathan et al 1999

```{r length log distributions conditions, fig.show="hold", out.width="33%", echo=FALSE, results='hide' ,warning=FALSE }

#,log="xy" 
lLinModel_NE <- getLogPowerSlope(h_Length_NE,10)
lLinModel_NL <- getLogPowerSlope(h_Length_NL,10)
plot(log10(h_Length_NE$mids),log10(100*h_Length_NE$counts/sum(h_Length_NE$counts) ),main=paste("NF Log-Log percentage of lengths " ),xlab="log Length (mm)",col=colourDataScheme$NF$Spont,pch=16,xlim=c(0,2.5),ylim=c(-4,3), ylab="log N(l) %")
points(log10(h_Length_NL$mids),log10(100*h_Length_NL$counts/sum(h_Length_NL$counts) ),
       #main=paste("NF Evoked. mu:",getLogPowerSlope(h_Length_NL)), 
       xlab="Length (mm)",col=colourDataScheme$NF$Evoked,pch=16)
lines(lLinModel_NE$ptx_line,lLinModel_NE$pty_line,lwd=3,col=colourDataScheme$NF$Spont)

lines(lLinModel_NL$ptx_line,lLinModel_NL$pty_line,lwd=3,col=colourDataScheme$NF$Evoked)
legend("topright",legend=c(paste("Spont μ",format(lLinModel_NE$coeff,digits=2)),paste("Evoked μ",format(lLinModel_NL$coeff,digits=2) ) ),col=c(colourDataScheme$NF$Spont,colourDataScheme$NF$Evoked) ,pch=c(16,16) )


#,log="xy" 
lLinModel_LE <- getLogPowerSlope(h_Length_LE,14)
lLinModel_LL <- getLogPowerSlope(h_Length_LL,14)
plot(log10(h_Length_LE$mids),log10(100*h_Length_LE$counts/sum(h_Length_LE$counts) ),main=paste("LF Log-Log percentage of lengths " ),xlab="log Length (mm)",col=colourDataScheme$LF$Spont,pch=16,xlim=c(0,2.5),ylim=c(-4,3), ylab="log N(l) %")
points(log10(h_Length_LL$mids),log10(100*h_Length_LL$counts/sum(h_Length_LL$counts) ),
       #main=paste("NF Evoked. mu:",getLogPowerSlope(h_Length_NL)), 
       xlab="Length (mm)",col=colourDataScheme$LF$Evoked,pch=16)
lines(lLinModel_LE$ptx_line,lLinModel_LE$pty_line,lwd=3,col=colourDataScheme$LF$Spont)
lines(lLinModel_LL$ptx_line,lLinModel_LL$pty_line,lwd=3,col=colourDataScheme$LF$Evoked)
legend("topright",legend=c(paste("Spont μ",format(lLinModel_LE$coeff,digits=2)), paste("Evoked μ",format(lLinModel_LL$coeff,digits=2) ) ),col=c(colourDataScheme$LF$Spont,colourDataScheme$LF$Evoked) ,pch=c(16,16) )



lLinModel_DE <- getLogPowerSlope(h_Length_DE,10)
lLinModel_DL <- getLogPowerSlope(h_Length_DL,10)
plot(log10(h_Length_DE$mids),log10(100*h_Length_DE$counts/sum(h_Length_DE$counts) ),main=paste("DF Log-Log percentage of lengths " ),xlab="log Length (mm)",col=colourDataScheme$DF$Spont,pch=16,xlim=c(0,2.5),ylim=c(-4,3), ylab="log N(l) %")
points(log10(h_Length_DL$mids),log10(100*h_Length_DL$counts/sum(h_Length_DL$counts) ),
       #main=paste("NF Evoked. mu:",getLogPowerSlope(h_Length_NL)), 
       xlab="Length (mm)",col=colourDataScheme$DF$Evoked,pch=16)
lines(lLinModel_DE$ptx_line,lLinModel_DE$pty_line,lwd=3,col=colourDataScheme$DF$Spont)
lines(lLinModel_DL$ptx_line,lLinModel_DL$pty_line,lwd=3,col=colourDataScheme$DF$Evoked)

legend("topright",legend=c(paste("Spont μ",format(lLinModel_DE$coeff,digits=2)), paste("Evoked μ",format(lLinModel_DL$coeff,digits=2) ) ),col=c(colourDataScheme$DF$Spont,colourDataScheme$DF$Evoked) ,pch=c(16,16) )

```

I have fitted a standard linear model on the log-log relationship at the drop off, where power-law like relationship appears on the data. 

(Edited After being corrected for measuring full event path-length -over the fixed ROI boundary- from entering ROI to leaving, where event recording stops) 
We find that the presence of prey changes the exponent, similarly to the foraging examples reported in Viswanathan et al. 1999.
Longer paths exist in the absence of prey, as larva spend time hunting within the ROI.
**In the absence of prey the exponent appears to be near the reportedly "optimal" 2 for NF and LF, but not for DF! **
<!--No Differences between test conditions can be seen for NF, and generally the linear/ power law like exponent of drop-off is very similar between conditions, unlike the foraging examples reported in Viswanathan et al. 1999.
This is not over a fixed radius boundary however, but over all paths. I will  look at this question for specific dispersion sizes in future section, first I look at the 
ratio of dispersion to path-lenth ratio, and find evidence of structure and difference between spont. and evoked events. -->


## Path-lenth to dispersion ratios

```{r  hunt-event-length-dispersion ratios histograms , fig.show="hold", out.width="50%", echo=FALSE, cache=TRUE }
## Normalized Dispersion In Hunt Events
nBreaks <-seq(0,0.5,0.02)
xbreaks <-seq(0,0.5,0.02)

## Check NF
hist(datDispersion[datDispersion$groupID %in% c('NE'), ]$Dispersion/ datDispersion[datDispersion$groupID %in% c('NE'), ]$Length,
     breaks=xbreaks,main="NF Spont.",xlab="Dispersion/Length ",col=colourDataScheme$NF$Spont)

hist(datHEventDispersion[datHEventDispersion$groupID=='NE', ]$Dispersion/datHEventDispersion[datHEventDispersion$groupID=='NE', ]$Length,
     breaks=nBreaks,main="NF Spont Hunt-events",xlab="Length",col=colourDataScheme$NF$Spont)

hist(datDispersion[datDispersion$groupID %in% c('NL'), ]$Dispersion/ datDispersion[datDispersion$groupID %in% c('NL'), ]$Length,
     breaks=xbreaks,main="NF Evoked",xlab="Dispersion/Length ",col=colourDataScheme$NF$Evoked)

hist(datHEventDispersion[datHEventDispersion$groupID=='NL', ]$Dispersion/datHEventDispersion[datHEventDispersion$groupID=='NL', ]$Length,
     breaks=nBreaks,main="NF Evoked Hunt-events",xlab="Length",col=colourDataScheme$NF$Evoked)


## Check LF
#'Spont
hist(datDispersion[datDispersion$groupID %in% c('LE'), ]$Dispersion/ datDispersion[datDispersion$groupID %in% c('LE'), ]$Length,
     breaks=xbreaks,main="LF Spont.",xlab="Dispersion/Length ",col=colourDataScheme$LF$Spont)

hist(datHEventDispersion[datHEventDispersion$groupID=='LE', ]$Dispersion/datHEventDispersion[datHEventDispersion$groupID=='LE', ]$Length,
     breaks=nBreaks,main="LF Spont Hunt-events",xlab="Length ",col=colourDataScheme$LF$Spont)

## Evoked
hist(datDispersion[datDispersion$groupID %in% c('LL'), ]$Dispersion/ datDispersion[datDispersion$groupID %in% c('LL'), ]$Length,
     breaks=xbreaks,main="LF Evoked.",xlab="Dispersion/Length ",col=colourDataScheme$LF$Evoked)

hist(datHEventDispersion[datHEventDispersion$groupID=='LL', ]$Dispersion/datHEventDispersion[datHEventDispersion$groupID=='LL', ]$Length,
     breaks=nBreaks,main="LF Evoked Hunt-events",xlab="Length ",col=colourDataScheme$LF$Evoked)


## Check DF
hist(datDispersion[datDispersion$groupID %in% c('DE'), ]$Dispersion/ datDispersion[datDispersion$groupID %in% c('DE'), ]$Length,
     breaks=xbreaks,main="DF Spont.",xlab="Dispersion/Length ",col=colourDataScheme$DF$Spont)

hist(datHEventDispersion[datHEventDispersion$groupID=='DE', ]$Dispersion / datHEventDispersion[datHEventDispersion$groupID=='DE', ]$Length,
     breaks=nBreaks,main="DF Spont Hunt-events",xlab="Length",col=colourDataScheme$DF$Spont)

hist(datDispersion[datDispersion$groupID %in% c('DL'), ]$Dispersion/ datDispersion[datDispersion$groupID %in% c('DL'), ]$Length,
     breaks=xbreaks,main="DF Evoked",xlab="Dispersion/Length ",col=colourDataScheme$DF$Evoked)

hist(datHEventDispersion[datHEventDispersion$groupID=='DL', ]$Dispersion/datHEventDispersion[datHEventDispersion$groupID=='DL', ]$Length,breaks=nBreaks,main="DF Evoked Hunt-events",xlab="Length",col=colourDataScheme$DF$Evoked)


BW=0.1
```

These distribution are interesting as they show some well defined structure, especially in spontaneous conditions. They could underly some general well known movement/exploration strategy, which I need to look for.

Generally, lower ratios are indicative of turtuous paths of low dispersion, ie where the larva moves but is generally constrained to the same region.

  - In all trajectories the higherst ratio - indicating straight motion- has the higher occupancy
  - Across groups, evoked conditions augment the frequency of low ratios, ie low dispersion movement
  - Ratios over hunt-event initiation suggest that low-dispersal frequencies are relativelly over represented compared to general motility in evoked conditions, but not in spontaneous conditions, ie spontaneous events occur randomly across general motion, in evoked conditions low dispersion motion appears favouroble to hunt-event initiation. 


## Path length per dispersion size (Examine Invariance principle)

Take a random walk until it hits a circle of radius r times the step length. The average number of steps it performs is $r^2$.[citation needed] 
This fact is the discrete version of the fact that a Wiener process walk is a fractal of Hausdorff dimension 2.[citation needed]

Usually the mean length of the trajectories inside a domain depends both on the geometry of the system and on the characteristic of the random walk. 
However, for a diffusive random walk, one that has exponentially distributed straight paths between two successive scattering evens, it has been established *that mean lengths of the trajectories is independent of the random walk characteristics* and is given by a simple formula (#mazzolo2009invariance). 
For random walks, the mean length $<s>$ does not depend on the characteristic mean free path ℓ, but only on the ratio between the surface A and the perimeter C—that is $<s>=\pi A/C$
Thus the corresponding mean values are constrained by the sole free surface to perimeter ratio (see
[1](https://science.sciencemag.org/content/358/6364/765/tab-figures-data) [2](https://www.nature.com/articles/s41467-019-10455-y) ).
Therefore *it may be possible to use this principle to detect for diffusive walks*, instead of relying on fitting the statistics of step lenghts to power-laws or exponentials. This can then avoid having to set arbitrary threshold on what is considered straight or a turn/change of direction.
However, (#mazzolo2009invariance) prove that for any homogeneous stochastic processes the mean length of trajectories is still given by the Cauchy formula, as long as the random walker enters the domain with distributions that are simply related to that of the random walk. 

Normally the mean path-length for the entry and exit from a circle of size $r$ is measured.
Here I have path-lengths whose 2-most distal points  fall on the Dispersal circle-boundary.
I will first examine the mean total path-length contained in the dispersion domain, and then the path length between the 2 points that define the dispersion domain.

### Mean Path length scales linearly with dispersion

Plot for X sec duration paths finds that indeed a linear relationship similar to (this)[https://iopscience.iop.org/article/10.1209/epl/i2003-00208-x/meta], while the mean path length defining the limits (radius $r$) of the dispersion domain is proportional to the Area/Circumfarence ratio. 
Yet, this relationship is *not invariant*, as looking at increasing path-integration time windows $X$sec reveals increasing slope of mean-path lengths. 
Thus suggesting mean path length is not invariant to the particular variations in the timescale at which the animal disperses withing a circle $r$.

The plots below examine both, the total mean path length contained with each dispersion $r$, and the cutting path length - the path between the two points that touch the circles boundary:

```{r path-length-2sec duration- per dispersion, fig.show="hold", out.width="50%", echo=FALSE, cache=TRUE,fig.cap="Mean path length per dispersion size for path-durations 20sec" }

## Plot mean path length for each boundary dispersion size 
# This is to examine the similarity to the random walk invariance principle by which the mean pathlength within a circle of radius r is proportional to pi*A/C
# ie legth to hit the boundary of the observation circle, is only proportional to the circle (in 2D), volume in 3D- 
plot_meanCrossingPathLengthPerDispersion <- function(datDispersion, strGroupID, addPlot=FALSE, propFactor=1.0)
{
  datGroupDispersion <- datDispersion[datDispersion$groupID %in% strGroupID,]
  dispBreaks <- seq(1,13,1)
  upLIM <- 50
  datGroupDispersion$dispRange <- cut(datGroupDispersion[datGroupDispersion$groupID %in% strGroupID ,"Dispersion" ],breaks=dispBreaks)
  ##The Path Connecting the two points that define the Dispersion Circle
  vmeanPathLengthPerDispersion <- tapply(datGroupDispersion$DispersionPathLength,datGroupDispersion$dispRange,mean,na.rm=TRUE)*DIM_MMPERPX
  
  if (!addPlot)
  {
    plot(seq(1,10.5,length.out = NROW(vmeanPathLengthPerDispersion)),
         vmeanPathLengthPerDispersion,xlab="Circle radius / Dispersion (mm)",ylab="Chord mean path length <l>",
         ylim=c(0,upLIM),xlim=c(0,11),col=colourDataScheme[[strGroupID]],pch=pointTypeScheme[[strGroupID]],cex=0.8 )
        lines(seq(1,10.5,length.out = NROW(vmeanPathLengthPerDispersion)),
         vmeanPathLengthPerDispersion,lwd=1,lty=lineTypeScheme[[strGroupID]])

  }else
  {
    points(seq(1,10.5,length.out = NROW(vmeanPathLengthPerDispersion)),
         vmeanPathLengthPerDispersion,xlab="Circle radius / Dispersion (mm)",
         col=colourDataScheme[[strGroupID]],pch=pointTypeScheme[[strGroupID]],cex=0.8 )
    
    lines(seq(1,10.5,length.out = NROW(vmeanPathLengthPerDispersion)),
         vmeanPathLengthPerDispersion,lwd=1,lty=lineTypeScheme[[strGroupID]])
  }
  
  if (!addPlot)
  {
    rpoints <- seq(0.5,10.5, length.out = NROW(vmeanPathLengthPerDispersion) )
    points(rpoints,theoreticalMeanLength(rpoints,propFactor ),pch=2,cex=0.8 ) #Low Lim
    points(seq(2,12,1),theoreticalMeanLength(seq(2,12,1),propFactor ),pch=2,cex=0.5 ) #Up Lim
    points(seq(1,11,1),theoreticalMeanLength(seq(1,11,1),propFactor ),pch=2,cex=0.5 ) #Up Lim
   # legend("topleft",pch=c(16,2),legend=c("Data","Theory"),col=c(colourDataScheme[[strGroupID]],"black") )
  }
  
  #boxplot(datGroupDispersion$Length~datGroupDispersion$dispRange,main=strTitle,col=colourDataScheme[[strGroupID]],ylim=c(0,35))
}

# The mean  Path Length Contained Within each Size of Dispersion
plot_meanPathLengthPerDispersion <- function(datDispersion, strGroupID, addPlot=FALSE, propFactor=1.0)
{
  datGroupDispersion <- datDispersion[datDispersion$groupID %in% strGroupID,]
  dispBreaks <- seq(1,13,1)
  upLIM <- 50
  datGroupDispersion$dispRange <- cut(datGroupDispersion[datGroupDispersion$groupID %in% strGroupID ,"Dispersion" ],breaks=dispBreaks)
  ##The Path Connecting the two points that define the Dispersion Circle
  vmeanPathLengthPerDispersion <- tapply(datGroupDispersion$Length,datGroupDispersion$dispRange,mean,na.rm=TRUE)
  
  if (!addPlot)
  {
    plot(seq(1,10.5,length.out = NROW(vmeanPathLengthPerDispersion)),
         vmeanPathLengthPerDispersion,xlab="Circle radius / Dispersion (mm)",ylab="Total contained mean path length <l>",
         ylim=c(0,upLIM),xlim=c(0,11),col=colourDataScheme[[strGroupID]],pch=pointTypeScheme[[strGroupID]],cex=0.8 )
        lines(seq(1,10.5,length.out = NROW(vmeanPathLengthPerDispersion)),
         vmeanPathLengthPerDispersion,lwd=1,lty=lineTypeScheme[[strGroupID]])

  }else
  {
    points(seq(1,10.5,length.out = NROW(vmeanPathLengthPerDispersion)),
         vmeanPathLengthPerDispersion,xlab="Circle radius / Dispersion (mm)",
         col=colourDataScheme[[strGroupID]],pch=pointTypeScheme[[strGroupID]],cex=0.8 )
    
    lines(seq(1,10.5,length.out = NROW(vmeanPathLengthPerDispersion)),
         vmeanPathLengthPerDispersion,lwd=1,lty=lineTypeScheme[[strGroupID]])
  }
  
  if (!addPlot)
  {
    rpoints <- seq(0.5,10.5, length.out = NROW(vmeanPathLengthPerDispersion) )
    points(rpoints,theoreticalMeanLength(rpoints,propFactor ),pch=2,cex=0.8 ) #Low Lim
    points(seq(2,12,1),theoreticalMeanLength(seq(2,12,1),propFactor ),pch=2,cex=0.5 ) #Up Lim
    points(seq(1,11,1),theoreticalMeanLength(seq(1,11,1),propFactor ),pch=2,cex=0.5 ) #Up Lim
   # legend("topleft",pch=c(16,2),legend=c("Data","Theory"),col=c(colourDataScheme[[strGroupID]],"black") )
  }
  
  #boxplot(datGroupDispersion$Length~datGroupDispersion$dispRange,main=strTitle,col=colourDataScheme[[strGroupID]],ylim=c(0,35))
}

tsec_timeWindow <- 2
datDispersion <- loadDispersionData(forceReload=T ,tsec_timeWindow)
strTitle <- paste(tsec_timeWindow,"sec duration paths ")

## Take Group 
propFactor <- 1.0
plot_meanPathLengthPerDispersion(datDispersion,'NE',addPlot = FALSE, propFactor)
plot_meanPathLengthPerDispersion(datDispersion,'NL',addPlot = TRUE,propFactor)
plot_meanPathLengthPerDispersion(datDispersion,'LE',addPlot = TRUE,propFactor)
plot_meanPathLengthPerDispersion(datDispersion,'LL',addPlot = TRUE,propFactor)
plot_meanPathLengthPerDispersion(datDispersion,'DE',addPlot = TRUE,propFactor)
plot_meanPathLengthPerDispersion(datDispersion,'DL',addPlot = TRUE,propFactor)
title(strTitle)

## Take Group 
propFactor <- 1.0
plot_meanCrossingPathLengthPerDispersion(datDispersion,'NE',addPlot = FALSE, propFactor)
plot_meanCrossingPathLengthPerDispersion(datDispersion,'NL',addPlot = TRUE,propFactor)
plot_meanCrossingPathLengthPerDispersion(datDispersion,'LE',addPlot = TRUE,propFactor)
plot_meanCrossingPathLengthPerDispersion(datDispersion,'LL',addPlot = TRUE,propFactor)
plot_meanCrossingPathLengthPerDispersion(datDispersion,'DE',addPlot = TRUE,propFactor)
plot_meanCrossingPathLengthPerDispersion(datDispersion,'DL',addPlot = TRUE,propFactor)
title(paste(strTitle," crossing chord " ) ) 



tsec_timeWindow <- 10
datDispersion <- loadDispersionData(forceReload = T,tsec_timeWindow)
strTitle <- paste(tsec_timeWindow,"sec duration paths ")

## Take Group 
propFactor <- 1.0
plot_meanPathLengthPerDispersion(datDispersion,'NE',addPlot = FALSE, propFactor)
plot_meanPathLengthPerDispersion(datDispersion,'NL',addPlot = TRUE,propFactor)
plot_meanPathLengthPerDispersion(datDispersion,'LE',addPlot = TRUE,propFactor)
plot_meanPathLengthPerDispersion(datDispersion,'LL',addPlot = TRUE,propFactor)
plot_meanPathLengthPerDispersion(datDispersion,'DE',addPlot = TRUE,propFactor)
plot_meanPathLengthPerDispersion(datDispersion,'DL',addPlot = TRUE,propFactor)
title(strTitle)
## Take Group 
propFactor <- 1.0
plot_meanCrossingPathLengthPerDispersion(datDispersion,'NE',addPlot = FALSE, propFactor)
plot_meanCrossingPathLengthPerDispersion(datDispersion,'NL',addPlot = TRUE,propFactor)
plot_meanCrossingPathLengthPerDispersion(datDispersion,'LE',addPlot = TRUE,propFactor)
plot_meanCrossingPathLengthPerDispersion(datDispersion,'LL',addPlot = TRUE,propFactor)
plot_meanCrossingPathLengthPerDispersion(datDispersion,'DE',addPlot = TRUE,propFactor)
plot_meanCrossingPathLengthPerDispersion(datDispersion,'DL',addPlot = TRUE,propFactor)
title(paste(strTitle," crossing chord " ) ) 


# 
# tsec_timeWindow <- 50
# datDispersion <- loadDispersionData(forceReload = T,tsec_timeWindow)
# strTitle <- paste(tsec_timeWindow,"sec duration paths ")
# 
# ## Take Group 
# propFactor <- 1.0
# plot_meanPathLengthPerDispersion(datDispersion,'NE',addPlot = FALSE, propFactor)
# plot_meanPathLengthPerDispersion(datDispersion,'NL',addPlot = TRUE,propFactor)
# plot_meanPathLengthPerDispersion(datDispersion,'LE',addPlot = TRUE,propFactor)
# plot_meanPathLengthPerDispersion(datDispersion,'LL',addPlot = TRUE,propFactor)
# plot_meanPathLengthPerDispersion(datDispersion,'DE',addPlot = TRUE,propFactor)
# plot_meanPathLengthPerDispersion(datDispersion,'DL',addPlot = TRUE,propFactor)
# title(strTitle)
# 
# ## Take Group 
# propFactor <- 1.0
# plot_meanCrossingPathLengthPerDispersion(datDispersion,'NE',addPlot = FALSE, propFactor)
# plot_meanCrossingPathLengthPerDispersion(datDispersion,'NL',addPlot = TRUE,propFactor)
# plot_meanCrossingPathLengthPerDispersion(datDispersion,'LE',addPlot = TRUE,propFactor)
# plot_meanCrossingPathLengthPerDispersion(datDispersion,'LL',addPlot = TRUE,propFactor)
# plot_meanCrossingPathLengthPerDispersion(datDispersion,'DE',addPlot = TRUE,propFactor)
# plot_meanCrossingPathLengthPerDispersion(datDispersion,'DL',addPlot = TRUE,propFactor)
# title(paste(strTitle," crossing chord " ) ) 


#smoothScatter(datDispersion[datDispersion$groupID == "LE",]$DispersionPathLength,datDispersion[datDispersion$groupID == "LE",]$Dispersion)

```

When looking at short path-durations (2sec) indeed our data shows some agreement with the theoretical mean-path lengths by a factor of 1.5, while the linear relationship holds all groups in the same way.
The length of every path contained in a dispersion circle with radius $r$ increases linearly with $r$, specifically the relationship appears to be :
\[
<s> = \frac{3\pi}{2}  \frac{\pi r^2}{2 \pi r}
\]

When these same dispersion ranges are examined over 50sec path durations we find that a linear relationship still holds, but this slope deviates further from theoretical with increasing mean path lengths. This can be explained as the development of the same dispersions now is much slower, this is apparently partly explained by increasingly tortuous paths from entry to exit of the same $r$ Dispersion circle domains.
*Thus the linear relationship is not invariant to the path time-scale*

but why? some invariance seems to hold when it comes to the chords defining the dispersion domain, (similar to  #blanco2003invariance), at least clearly so in the absence of prey.

When looking at the overall contained path-length, I find that in the presence of prey increases path-lengths (for > 10sec durations) - most likely as a result of hunting events and prey tracking. 
But note, that this way of looking at such path-data is new.
Usually mean free paths are measured, as the path between two changes in direction, or the time of entry and exit from a circle bound area.
 
it is known that the number of steps scales as the $<s> \approx  r^2$, and here we find that path-length scales with $r$, which here is the dispersion radius containing the path.
The Chord-cutting path-length, which defines the dispersion size,  follow the invariance linear rule more strictly, and that is clear over longer path durations.

Nevertheless we find that the addition of prey *LF increase the path-lengths even among paths with the same Dispersion*, as their response to prey/ prey detection makes paths more turtuous (check 10sec paths). Over 50sec paths this increase in path length in evoked conditions is evident across groups.

I next look at the Log-Log distribution of path-lengths for a specified dispersion boundary. 

```{r  path-length-All duration- per dispersion, fig.show="hold", out.width="100%", echo=FALSE, cache=FALSE,fig.cap="Mean path length per dispersion size for full event path-lengths " }

tsec_timeWindow <- 0
datDispersion <- loadDispersionData_norm(tsec_timeWindow)
strTitle <- paste("Whole path ")

## Take Group 
plot_meanPathLengthPerDispersion(datDispersion,'NE')
plot_meanPathLengthPerDispersion(datDispersion,'NL',addPlot = TRUE)
plot_meanPathLengthPerDispersion(datDispersion,'LE',addPlot = TRUE)
plot_meanPathLengthPerDispersion(datDispersion,'LL',addPlot = TRUE)
plot_meanPathLengthPerDispersion(datDispersion,'DE',addPlot = TRUE)
plot_meanPathLengthPerDispersion(datDispersion,'DL',addPlot = TRUE)
title(strTitle)

```

##  Path-length Log-Log distribution per *specific dispersion*

```{r  path-length for dispersion log-log distribution , fig.show="hold", out.width="33%", echo=FALSE, cache=TRUE }
#,log="xy" 

plotLogLogPathLengthForFixedDispersion  <- function(datDispersion,strGroupID,dispRange = 10)
{
    datGroupDispersion <- datDispersion[datDispersion$groupID %in% strGroupID,]
    dispBreaks <- seq(1,11,0.3)
    datGroupDispersion$dispRange <- cut(datGroupDispersion[datGroupDispersion$groupID %in% strGroupID ,"Dispersion" ],breaks=dispBreaks)
    strTitle <- paste("Path length per dispersion", strGroupID,"#",NROW(datGroupDispersion$dispRange))

    xbreaks <-seq(0,max(datDispersion$Length,na.rm=TRUE)+1,2)
    strDispRange <-levels(datGroupDispersion$dispRange)[dispRange]
    #print(strDispRange) 
    h_Length_GE <- hist(datGroupDispersion[datGroupDispersion$groupID == strGroupID[1] & datGroupDispersion$dispRange %in% levels(datGroupDispersion$dispRange)[dispRange] , ]$Length,breaks=xbreaks,plot=FALSE)
    h_Length_GL <- hist(datGroupDispersion[datGroupDispersion$groupID == strGroupID[2] & 
                                               datGroupDispersion$dispRange %in% levels(datGroupDispersion$dispRange)[dispRange] , ]$Length,breaks=xbreaks,plot=FALSE)

    lLinModel_GE <- getLogPowerSlope(h_Length_GE,10)
    lLinModel_GL <- getLogPowerSlope(h_Length_GL,10)
    
    plot(log10(h_Length_GE$mids),log10(100*h_Length_GE$counts/sum(h_Length_GE$counts) ),
         main=paste(" Log-Log percentage of lengths for disp:",strDispRange ),
         xlab="log Length (mm)", col=colourDataScheme[strGroupID[1]][[1]], pch=16,xlim=c(0,2.0),ylim=c(-4,3), ylab="log N(l) %")
    
    points(log10(h_Length_GL$mids),log10(100*h_Length_GL$counts/sum(h_Length_GL$counts) ),
           xlab="Length (mm)",col=colourDataScheme[strGroupID[2]][[1]], pch=16)
    lines(lLinModel_GE$ptx_line,lLinModel_GE$pty_line,lwd=3,col=colourDataScheme[strGroupID[1]][[1]])
    
    lines(lLinModel_GL$ptx_line,lLinModel_GL$pty_line,lwd=3,col=colourDataScheme[strGroupID[2]][[1]])
    legend("topright", 
           legend=c(paste("Spont μ",format(lLinModel_GE$coeff,digits=2)),paste("Evoked μ",format(lLinModel_GL$coeff,digits=2) ) ),col=c(colourDataScheme[strGroupID[2]][[1]] ,colourDataScheme[strGroupID[2]][[1]]) ,pch=c(16,16) )

}
##Low Dispersal - Larval Size - 4.3mm
plotLogLogPathLengthForFixedDispersion(datDispersion,c("NE","NL"),dispRange = 12)
plotLogLogPathLengthForFixedDispersion(datDispersion,c("LE","LL"),dispRange = 12)
plotLogLogPathLengthForFixedDispersion(datDispersion,c("DE","DL"),dispRange = 12)
## 5.2mm
plotLogLogPathLengthForFixedDispersion(datDispersion,c("NE","NL"),dispRange = 15)
plotLogLogPathLengthForFixedDispersion(datDispersion,c("LE","LL"),dispRange = 15)
plotLogLogPathLengthForFixedDispersion(datDispersion,c("DE","DL"),dispRange = 15)
##High Range 7.3
plotLogLogPathLengthForFixedDispersion(datDispersion,c("NE","NL"),dispRange = 22)
plotLogLogPathLengthForFixedDispersion(datDispersion,c("LE","LL"),dispRange = 22)
plotLogLogPathLengthForFixedDispersion(datDispersion,c("DE","DL"),dispRange = 22)



```

When looking at small dispersion circles $(3.7,4]$ we find here is that the path-lengths increase between spontaneous and evoked conditions, across groups. 
For larger dispersions cicles $(5.2,5.5]$ we find an effect specific to LF, whereby the food and non food (evoked, spontaneous) conditions differ in a manner shown as in (Viswanathan et al. 2009)!

The way the data is looked at here is different, and exponent $\mu$, shown as the linear power law within the log-log, would not match the investigations from (Viswanathan et al. 2009)

##  Path-length to dispersion ratios fixed dispersion range

```{r  path-length to dispersion ratio distribution , fig.show="hold", out.width="33%", echo=FALSE, cache=TRUE }

hist_pathLengthPerDispersion <- function(datDispersion,strGroupID)
{
  datGroupDispersion <- datDispersion[datDispersion$groupID %in% strGroupID,]
  ##get Dispersion Levels, as discrete circles with thing 1mm boundary
  dispLevel <- cut(datGroupDispersion[,"Dispersion" ],breaks=seq(1,11,1))
  y <- datGroupDispersion[!is.na(dispLevel) & dispLevel == '(3,4]',"Length"]
  strTitle <- paste( strGroupID,"#",NROW(y),"D=3-4mm l",theoreticalMeanLength(3),"-", theoreticalMeanLength(4), "<s>=",mean(y,na.rm=TRUE) )

  #x <- datDispersion[!is.na(dispLevel) & dispLevel == '(3,4]',"Dispersion"]
  hist(y,breaks=seq(0,max(47,y)+1,2),
  main=strTitle,
  col=colourDataScheme[[strGroupID]]  )
  
  ##get Dispersion Levels, as discrete circles with thing 1mm boundary
  y <- datGroupDispersion[!is.na(dispLevel) & dispLevel == '(4,5]',"Length"]
  strTitle <- paste( strGroupID,"#",NROW(y),"D=4-5mm l~",theoreticalMeanLength(4),"-", theoreticalMeanLength(5), "<s>=",mean(y,na.rm=TRUE) )
  #x <- datDispersion[!is.na(dispLevel) & dispLevel == '(3,4]',"Dispersion"]
  hist(y,breaks=seq(0,max(47,y)+1,2),main=strTitle,
       col=colourDataScheme[[strGroupID]]  )
  
  y <- datGroupDispersion[!is.na(dispLevel) & dispLevel == '(5,6]',"Length"]
  strTitle <- paste( strGroupID,"#",NROW(y),"D=5-6mm l~",theoreticalMeanLength(5),"-", theoreticalMeanLength(6), "<s>=",mean(y,na.rm=TRUE) )
  #x <- datDispersion[!is.na(dispLevel) & dispLevel == '(3,4]',"Dispersion"]
  hist(y,breaks=seq(0,max(47,y)+2,2),
       main=strTitle , col=colourDataScheme[[strGroupID]]  )
}

## Take Group 
hist_pathLengthPerDispersion(datDispersion,'NE')
hist_pathLengthPerDispersion(datDispersion,'NL')

hist_pathLengthPerDispersion(datDispersion,'LE')
hist_pathLengthPerDispersion(datDispersion,'LL')

hist_pathLengthPerDispersion(datDispersion,'DE')
hist_pathLengthPerDispersion(datDispersion,'DL')




```

In summary, over fixed path durations, the*mean path length depends on size of the observation area $\pi A/C$*.
It is not clear to me if this is evidence towards the larval trajectories appearing  as a stochastic diffussive process, because random straigh line chords would also scale linearly with the spatial domain they cross.
In general the above data suggest that the characteristics  **dynamics governing foraging motion  may  modified by experience **


# Invariance-revisited - Path lengths crossing bounded areas

I need to investigate the invariance principle further, and whether it amounts to paths being diffusion/random walks or Levy processes.
As up to now I was not looking something that is equivalent entry and exit times, or time to hit boundary as in the Levy type investigations, because here all paths chosen have produced a specific dispersal - ie these paths are defined by having the longest distance within the circular domain (which could explain the icreased slope upwards).  and thus are not equivalent to looking at a isotropic entry, as for example  looking at the escape from random starting point within the cycle, or the mean escape time upon entering an area nor the mean time to hit two target sites (food items) as in FIG 3 (Viswanathan et al. 2009).

```{r path-length-within-domain calculations , fig.show="hold", out.width="50%", echo=FALSE, cache=TRUE, fig.cap="Mean path length and duration from paths crossing a circulare domain of radius R, boundary entry to exit. " }


library (plyr) #Split list, apply function #Thanks to https://stackoverflow.com/questions/4227223/convert-a-list-to-a-data-frame

#datDispersion<-loadDispersionData(10)
loaddatAllFrames()
  
  
  vgroupID <- vGroups[2]
  
calcPathLengthsInDomain <- function(datAllFrames,vgroupID,DomainRadius)
  {
    DIM_BOUNDARY_HWIDTH <- 0.3
    CONSECUTIVE_FRAME_THRES <- 2
    datGroupTraj <- datAllFrames[datAllFrames$groupID == vgroupID & datAllFrames$posX > 0,]
    ## Calc Dist from Center of domain
    pDomainCentre <- c(320,260) #c(mean(datGroupTraj$posX),mean(datGroupTraj$posY))
    rDomainRadius <- DomainRadius/DIM_MMPERPX
    
    datGroupTraj$distToDomainCentre   <- sqrt((datGroupTraj$posX-pDomainCentre[1])^2 + (datGroupTraj$posY-pDomainCentre[2])^2)*DIM_MMPERPX
    
    datDomainTrajectories <- datGroupTraj[datGroupTraj$distToDomainCentre <= (rDomainRadius*DIM_MMPERPX+DIM_BOUNDARY_HWIDTH),]
    datDomainTrajectories$distToDomainBoundary <- rDomainRadius*DIM_MMPERPX - datDomainTrajectories$distToDomainCentre
      #hist(datGroupTraj$distToDomainCentre,main=vgroupID)
    #hist(datDomainTrajectories$distToDomainCentre,main=vgroupID)
      #smoothScatter(datGroupTraj$posX,datGroupTraj$posY,xlim=c(0,640),ylim=c(0,480))
    #smoothScatter(datDomainTrajectories$posX,datDomainTrajectories$posY,xlim=c(0,640),ylim=c(0,480))
    
    Dframe <- diff(datDomainTrajectories$frameN)
    Dexp <- diff(as.integer(datDomainTrajectories$expID) )
    DeventID <- diff(as.integer(datDomainTrajectories$eventID) )
    datDomainTrajectories$DnextFrame <- NA
    datDomainTrajectories$DeventID <- NA
    datDomainTrajectories$Dexp <- NA
    ## Just so I can make sure no tracklets Between Different Events Are accidentaly joined - as a coincindence of frame numbers
    datDomainTrajectories[1:NROW(Dframe),]$DnextFrame <- Dframe
    datDomainTrajectories[1:NROW(Dexp),]$Dexp <- Dexp
    datDomainTrajectories[1:NROW(DeventID),]$DeventID <- DeventID
    datDomainTrajectories$TrackletUID <- NA
    
    
    # Assign a UID to each contigious tracklet (This is to avoid any track re-entry after exit being counted as the same path)
    # Label Consecutive Groups when their frame are less than CONSECUTIVE_FRAME_THRES (15) apart - Change of Event And Experiment added 
    continuousTrackletsFrames <- split(datDomainTrajectories$frameN, 
                                       ##Sum Increments When the following Indicators Of Changing Class Become TRUE (I added Track Splitters when Exp or Event Change)
                                 cumsum(c(1, abs(datDomainTrajectories$DnextFrame > CONSECUTIVE_FRAME_THRES)  | datDomainTrajectories$DeventID != 0 | datDomainTrajectories$Dexp != 0 ) ) # 
                                  ) 

    dfcontinuousTrackletsFrames <- ldply (continuousTrackletsFrames, data.frame)
    datDomainTrajectories$TrackletUID <- (unlist(dfcontinuousTrackletsFrames[1]))
    
    ##Debug - Export Tracklets
    # pal <- colorRamp(c("red", "blue"))
    # colT <- pal(seq(0, 1, len = NROW(continuousTrackletsFrames) ))
    #plot(datGroupTraj[datGroupTraj$expID == "320" & datGroupTraj$eventID == "18",]$posX,datGroupTraj[datGroupTraj$expID == "320" & datGroupTraj$eventID == "18",]$posY,cex=0.3,pch=20,xlim=c(0,580),ylim=c(0,480))
    # for (Tuid in names(continuousTrackletsFrames))
    # {
    #   pdf(file= paste(strPlotExportPath,"/foraging/AAATracklet",Tuid,".pdf",sep=""))
    #   datTracklet <- datDomainTrajectories[datDomainTrajectories$TrackletUID == Tuid, ]
    #   plot(datTracklet$posX,datTracklet$posY,col="black", type="b",cex=0.3,pch=20,xlim=c(0,580),ylim=c(0,480)) #colT[as.integer(unlist(datTracklet$TrackletUID) )]
    #   dev.off()    
    # }

    ## Select The frames that Are on the Domain Boundary and Have no Interruption to the next frame - Ie Part of Consecutive Path
    datBoundaryDomainTrajectories <- datDomainTrajectories[abs(datDomainTrajectories$DnextFrame) <= CONSECUTIVE_FRAME_THRES & 
                                                             abs(datDomainTrajectories$distToDomainBoundary) < DIM_BOUNDARY_HWIDTH,] #Can be -ve dist to domain as we consider a wide band centered on boundary

    ##Find Mean Path Duration From Entry to Exit Of the domain - Group By Exp, Event and Tracklet UID (not the tracker Assigned TrackID)
    entryFramePerLarvaEvent <- tapply(datBoundaryDomainTrajectories$frameN,
                                      paste(datBoundaryDomainTrajectories$expID,datBoundaryDomainTrajectories$eventID,datBoundaryDomainTrajectories$TrackletUID,sep="-" ),min )
    exitFramePerLarvaEvent <- tapply(datBoundaryDomainTrajectories$frameN,
                                     paste(datBoundaryDomainTrajectories$expID,datBoundaryDomainTrajectories$eventID,datBoundaryDomainTrajectories$TrackletUID,sep="-"),max )
    
    pathDurations <- (exitFramePerLarvaEvent - entryFramePerLarvaEvent)
    pathDurations <- pathDurations[!is.na(pathDurations)]
    
    
    lTrackletInfo <- list()
    
    ##Calc Path Length for Each Tracklet Identified
    for (strTrackID in names(pathDurations) )
    {
          
          vTrackID <- strsplit(strTrackID,"-")
          
          TrackletInfo <- list(expID = vTrackID[[1]][1],EventID=vTrackID[[1]][2],TrackletUID=vTrackID[[1]][3],sectionID=vTrackID[[1]][4], DomainRadius = rDomainRadius*DIM_MMPERPX)
          TrackletInfo$startFrame <- entryFramePerLarvaEvent[[strTrackID]]
          TrackletInfo$endFrame  <-  exitFramePerLarvaEvent[[strTrackID]]
  
          
          if (pathDurations[[strTrackID]]  < 1)
          { message("Duration is zero :",strTrackID)
            next()
          }
            
          datBoundedTracklet <- datDomainTrajectories[datDomainTrajectories$expID == TrackletInfo$expID &
                                                              datDomainTrajectories$eventID == TrackletInfo$EventID &
                                                              datDomainTrajectories$TrackletUID == TrackletInfo$TrackletUID &
                                                              datDomainTrajectories$frameN >= TrackletInfo$startFrame &
                                                              datDomainTrajectories$frameN <= TrackletInfo$endFrame,
                                                              ]

          
          
          ## Measure Path Length - Can Skip Some Frames To Speed Up Calculation
          fps <- unique(datBoundedTracklet$fps)
          TrackletInfo$duration <- pathDurations[[strTrackID]]/fps
          
          nSpace <- round(as.integer(fps) / 4)
          if (pathDurations[[strTrackID]] < nSpace  )
            nSpace <- max(1,round(pathDurations[[strTrackID]] / 10) )
            
          vIdx <- seq(from=min(pathDurations[[strTrackID]],1),by=nSpace,to=pathDurations[[strTrackID]]) ##Last nfrm
          
          vX <- datBoundedTracklet[vIdx,"posX"]
          vY <- datBoundedTracklet[vIdx,"posY"]
          mat_posDX <- outer(vX,vX,'-')
          mat_posDY <- outer(vY,vY,'-') #and Y 
          
          # Combine to Find Distances DX DY between all point of trajectory
          mat_ptDist <- sqrt(mat_posDX^2 + mat_posDY^2)
          
          TrackletInfo$pathLength           <- sum(mat_ptDist[row(mat_ptDist) == (col(mat_ptDist) - 1)],na.rm = T)*DIM_MMPERPX
          TrackletInfo$meanDistanceToCentre <- mean(datBoundedTracklet$distToDomainCentre)
          TrackletInfo$SqDisplacement       <- ((DIM_MMPERPX*mat_ptDist[1,ncol(mat_ptDist)])^2)
          
          lTrackletInfo[[strTrackID]] <- TrackletInfo
          
          message("Path length for:",strTrackID, " = ", format(TrackletInfo$pathLength,digits = 3), "mm Displacement:",format(sqrt(TrackletInfo$SqDisplacement),digits = 3), " in T:",format(TrackletInfo$duration,digits=3), "sec"  )
    } ##For Each Tracklet
    
  return(data.frame(do.call(rbind,lTrackletInfo) ) )
}##END oF FUNCTION
  
# Uncomment to Run Analysis - Warning *Very Slow* It takes hours for each domain size- -
# This is look Is commented Out After DomainPath Data Is processed - 
#   lBoundedTrackInfo <- list()
#    for (DomainRadius in c(9) ) #mm
#    {
#     for(g in vGroups)
#     {
#       message("Group:",g)
#       lBoundedTrackInfo[[g]] <- calcPathLengthsInDomain(datAllFrames, g, DomainRadius)
#     }
#     saveRDS(lBoundedTrackInfo,file=paste0(strDataExportDir,"/stat_boundedPathsB_R",DomainRadius,"mm.rds") )
#    }
  
  #### Plot Mean Path Length Per Domain Radius ###
  #lBoundedTrajectoryFiles <- dir(strDataExportDir, pattern = "stat_boundedPathsB_R[0-9]{1,3}mm.rds", full.names = FALSE, ignore.case = TRUE)
  #lBoundedTrajectoryFiles <- dir(strDataExportDir, pattern = "stat_boundedPathsB_R[[:digit:]]+\\.*[[:digit:]]*mm.rds", full.names = FALSE, ignore.case = TRUE)
  #vAvailableDomainRadius <- lapply( lBoundedTrajectoryFiles,FUN = function(s){  gsub(pattern = ".rds", replacement = "", x = s)  }  )
  #vAvailableDomainRadius <- lapply( vAvailableDomainRadius,FUN = function(s){  gsub(pattern = "[^0-9,.]", replacement = "", x = s)  }  )
  
  vAvailableDomainRadius <- getAvailablePathDomainsSizes()
  #Order them and Converr to Number
  
  message("Available Domain sizes:",paste(vAvailableDomainRadius,collapse=","))
  
  lMeanPathLengthAll <- list()
  for (DomainRadius in vAvailableDomainRadius)
  {#TODO Replace with A list returned from vAvailableDomainRadius
      lBoundedTrackInfo <- readRDS(file=paste0(strDataExportDir,"/stat_boundedPathsB_R",DomainRadius,"mm.rds") )
      for (strGroup in names(lBoundedTrackInfo) )
      {
          datBoundedTrackInfo <- data.frame(lBoundedTrackInfo[[strGroup]])
          datBoundedTrackInfo <- datBoundedTrackInfo[datBoundedTrackInfo$pathLength > MIN_PATH_LENGTH,] ##Remove Empty , or tiny noisy Paths
          
          lMeanPathLengthAll[[paste0(strGroup,DomainRadius)]] <- list(muPathLength=mean(unlist(datBoundedTrackInfo$pathLength) ),
                                   sdPathLength=sd(unlist(datBoundedTrackInfo$pathLength) ),
                                   muPathDuration=mean(unlist(datBoundedTrackInfo$duration) ),
                                   sdPathDuration=mean(unlist( datBoundedTrackInfo$pathLength) ),
                                   count=(NROW(datBoundedTrackInfo) ),
                                   groupID=strGroup,
                                   DomainRadius=DomainRadius)

      }
      
  }
  datMeanPathLengthAll <- do.call(rbind.data.frame,lMeanPathLengthAll)
  saveRDS(datMeanPathLengthAll,file=paste0(strDataExportDir,"/stat_boundedPathsB_RAllmm.rds") )
  
  datMeanPathLengthAll<-readRDS(file=paste0(strDataExportDir,"/stat_boundedPathsB_RAllmm.rds"))
  ## ***Join 10+11 mm Radius Results ###
  # datMeanPathLengthAll[datMeanPathLengthAll$DomainRadius == 10,]$muPathLength <- (datMeanPathLengthAll[datMeanPathLengthAll$DomainRadius == 10,]$muPathLength)+(datMeanPathLengthAll[datMeanPathLengthAll$DomainRadius == 11,]$muPathLength)
  # datMeanPathLengthAll[datMeanPathLengthAll$DomainRadius == 10,]$count <- (datMeanPathLengthAll[datMeanPathLengthAll$DomainRadius == 10,]$count)+(datMeanPathLengthAll[datMeanPathLengthAll$DomainRadius == 11,]$count)
  # datMeanPathLengthAll[datMeanPathLengthAll$DomainRadius == 10,]$muPathDuration <- (datMeanPathLengthAll[datMeanPathLengthAll$DomainRadius == 10,]$muPathDuration)+(datMeanPathLengthAll[datMeanPathLengthAll$DomainRadius == 11,]$muPathDuration)
  ## Make PLot All groups, Add theoretical Bound  
  plot(datMeanPathLengthAll$DomainRadius,datMeanPathLengthAll$muPathLength,ylim=c(0,28),xlim=c(0,12),
       col=unlist(colourDataScheme[ as.character(datMeanPathLengthAll$groupID) ]),
       pch=unlist(pointTypeScheme[ as.character(datMeanPathLengthAll$groupID) ]),ylab="Mean path length (mm)", xlab="Domain radius (mm)",main="Path length ")

  propFactor <- 1 #0.70
  rpoints <- seq(1,12, 1 )
  points(rpoints,theoreticalMeanLength(rpoints,propFactor ),pch=2,cex=0.8 ) #Low Lim
  
  # Gives Close agreement to Theoretical , May be underestimating because of aliasing, due to removal of points to speed up sum of path distance
  ### END PLOT OF MEAN PATH LENTH
  
  ## Make PLot All groups, Add theoretical Bound  
  plot(datMeanPathLengthAll$DomainRadius,datMeanPathLengthAll$muPathDuration,ylim=c(0,28),xlim=c(0,12),
       col=unlist(colourDataScheme[ as.character(datMeanPathLengthAll$groupID) ]),
       pch=unlist(pointTypeScheme[ as.character(datMeanPathLengthAll$groupID) ]),ylab="Mean residence time (sec)",xlab="Domain radius (mm)",main="Residence time ")

  propFactor <- 1 #0.70
  rpoints <- seq(1,10, 1 )
  points(rpoints,theoreticalMeanLength(rpoints,propFactor ),pch=2,cex=0.8 ) #Low Lim
  
```
  
The *invariance principle holds, within a restricted region <9mm *, with the mean path length being simply linearly related to the geometrical size of the domain:
the average value of L is independent of both the mean free path and single-scattering phase function field (as in bacteria see #frangipane2019invariance).
Well, I believe this verifies that these trajectories are reminiscinent of a stochastic process, likely diffusive (approximates Brownian motion) when the linearity is preserved .
> Then, the mean length of the trajectories in the domain is independent of the random walk characteristics. 
Valid for all stochastic processes with finite jumps (thus including a very large variety of physical processes), this exact relation is a strong constraint that links short and long trajectories in confined geometries.

Invariance principles allow:
>. It is the essence of convenience, for example, to be able to say that the intrinsic behaviour of an appropriate random function is that of Brownian motion. 

Although *all groups show the same exact agreement to invariance principle *, this is not true for the time they spent within the domain. 
Yet *LF move faster through the domains*, in agreement with earlier results on mean path-length per duration.

Residence time may be reflecting patch exploitation strategy (see Stephens2008):
>Foraging theory’s models ofpatch exploitation address the balance between cream skimming and thorough exploitation directly.
Let s be the mean travel time, that is the time it takes our forager to move from one patch to the next. Let t be the patch residence time. The variable t is the variable of interest here because a small t corresponds with *a cream skimming strategy* while a large t implies thorough exploitation.



Note that tracker ROI is `r format(260*DIM_MMPERPX,digits=3)` mm in diameter, and its circular boundary is approximatelly `r format((DIM_PXDIAMETER-260*2)*DIM_MMPERPX/2,digits=3)` mm away from the dish's wall. Yet, already from a 10mm domain radius (ie ~7mm away from boundary), we find the mean path length falls below the theoretical, indicating that the distribution of path lengths has been modified towards shorter paths, *especially so for the LE group, this is evident from R=7mm onwards.*
The 11mm radius is near the boundary, falling short by 0.5mm, and it is the biggest area we can analyse

The distribution of path lengths (excluding the < `r MIN_PATH_LENGTH` ) per domain radius is as follows:





```{r plot-loglog-distribution of domain path lengths,fig.show="hold", out.width="50%", echo=FALSE, cache=TRUE}  
  
## A Histogram in Log Scale Of MSD scale
plotLogLogDistribution_PathLength <- function(datBoundedTrack,strG,addPlot=FALSE)
{
   
    strTitle <- paste("R=",unique(datBoundedTrack$DomainRadius),",<l>=",format(mean(datBoundedTrack$pathLength),digits=3 ) )
    mxbreaks <- seq(0,200,5)
    hist_D <- hist(datBoundedTrack$pathLength,breaks=mxbreaks, plot=FALSE )  
    XLIM <- c( min(log10(hist_D$mids),na.rm=TRUE), max(log10(hist_D$mids), na.rm=TRUE)*1.01)
    if (!addPlot) 
    {
      plot(log10(hist_D$mids),log10( (100*hist_D$counts)/sum(hist_D$counts) ) , 
         main=strTitle,
         xlab="path length (mm)", col=colourDataScheme[strG][[1]], pch=pointTypeScheme[strG][[1]],
         xlim=XLIM,
         ylim=c(-1,2),
         ylab="log N(l) %",xaxt="n" ,type="b")
      
        
        axis(side=1, at=log10(axisTicks(XLIM,log=TRUE)), labels =  as.character(axisTicks(XLIM,log=TRUE)))
       #text(x=lLinModel_GE$xtick[seq(0,length(lLinModel_GE$xtick),3)],  par("usr")[3], labels = (10^xtick[seq(0,9,3)]), srt = 45, pos = 1, xpd = TRUE)
    }else {
      
        points(log10(hist_D$mids),log10( (100*hist_D$counts)/sum(hist_D$counts)),
         main=paste(" Distribution of bounded path length " ),type="b",
         xlab="log_10 path length (mm)", col=colourDataScheme[strG][[1]],pch=pointTypeScheme[strG][[1]], ylab="log N(l) %" )
    }
    
    # Plot Linear Model
    #lines(lLinModel_GE$ptx_line,lLinModel_GE$pty_line,lwd=3,col=colourDataScheme[strG][[1]])
  
    #return(lLinModel_GE)
}
  
  
  
  #plot(datBoundaryDomainTrajectories$posX,datBoundaryDomainTrajectories$posY)
 #max(unlist(lBoundedTrackInfo[["LL"]]$pathLength) )
  ## Distributions Should be Resembling the Chort Length Distribution   (see #frangipane2019invariance)


vAvailableDomainRadius <- getAvailablePathDomainsSizes()
for (R in vAvailableDomainRadius)
{
  
  DomainRadius <- R
  lBoundedTrackInfo <- readRDS(file=paste0(strDataExportDir,"/stat_boundedPathsB_R",DomainRadius,"mm.rds") )
  bAddPlot <- FALSE
  
  for (strGrp in names(lBoundedTrackInfo) )
  {
      lBoundedTrackInfo[[strGrp]] <- lBoundedTrackInfo[[strGrp]][lBoundedTrackInfo[[strGrp]]$pathLength > MIN_PATH_LENGTH,]
      
      datBoundedTrack <- lapply(lBoundedTrackInfo[[strGrp]],unlist) ##Remove Lists from Columns / Convert to vectors
      plotLogLogDistribution_PathLength(datBoundedTrack,strGrp,addPlot = bAddPlot)
      bAddPlot <- TRUE
  }
  
}

#plot(lBoundedTrackInfo[["LL"]]$pathLength, lBoundedTrackInfo[["LL"]]$duration,ylim=c(0,10),col=colourDataScheme[["LL"]])
#points(lBoundedTrackInfo[["LE"]]$pathLength, lBoundedTrackInfo[["LE"]]$duration,ylim=c(0,10),pch=2,col=colourDataScheme[["LE"]])
#points(lBoundedTrackInfo[["NL"]]$pathLength, lBoundedTrackInfo[["NL"]]$duration,ylim=c(0,10),pch=2,col=colourDataScheme[["NL"]])
#points(lBoundedTrackInfo[["NE"]]$pathLength, lBoundedTrackInfo[["NE"]]$duration,ylim=c(0,10),pch=2,col=colourDataScheme[["NE"]])
#plot(datDomainTrajectories$posX,datDomainTrajectories$posY,xlim=c(0,640),ylim=c(0,480),type="l")
```

## Counting sightings/Paths within regions increasing in size

The falling mean paths lengths, as seen in 11mm, could be a result of failing to detect path entries - into the ROI. This could an artefact of the recording, as the domain reaches the boundary limits where tracker initiates recording/tracking;  the issue being that some trajectories are being missed as the boundary entry zone is too thin to catch all entries into the ROI (in which case I should recalculate with entry zone being a percentage of the domain radius.
Maybe this is no surprise:
    - Recorded begins once those external most boundaries, which coincide with the recording ROI,  are crossed.
    - once in the ROI, Larvae make many more crossings of smaller central regions than the larger one, as a result of long straight paths being more rare.
    
In the following, the *boundaries at 10 and 11 mm* have been concatenated:
    

```{r distribution of number of paths per domain sizes,fig.show="hold", out.width="100%", echo=FALSE, cache=TRUE,fig.cap="Distribution of number of domain crossings, with increasing domain radius shows effect of prey is to constraint movement within smaller central regions, as revealed by the breaking down of the linear invariant regime in evoked conditions. (*Note regions 10+11mm have been concatenated*)"}  
datMeanPathLengthAll <- readRDS(file=paste0(strDataExportDir,"/stat_boundedPathsB_RAllmm.rds") )

bAddPlot<-FALSE
for (strG in as.character(unique(datMeanPathLengthAll$groupID) ) )
{
  datGroupMeanPathLength <- datMeanPathLengthAll[datMeanPathLengthAll$groupID == strG,]
  ## I Added the counts for the  10+11mm boundary to compensate for ROI edge effects /compensate for Detection Errors
  #datGroupMeanPathLength[datGroupMeanPathLength$DomainRadius == 10,]$count <- sum(datGroupMeanPathLength[datGroupMeanPathLength$DomainRadius %in% c(10,11),]$count)
  #datGroupMeanPathLength <- datGroupMeanPathLength[datGroupMeanPathLength$DomainRadius < 11,]
  if (!bAddPlot)
  {
    plot(datGroupMeanPathLength$DomainRadius,datGroupMeanPathLength$count/sum(datGroupMeanPathLength$count),ylim=c(0,0.2),xlim=c(0,11),
       xlab="Domain radius (mm)",ylab="fraction of domain crossings",
       col=colourDataScheme[strG][[1]], pch=pointTypeScheme[strG][[1]],type="b")
  }else
  {
    lines(datGroupMeanPathLength$DomainRadius,datGroupMeanPathLength$count/sum(datGroupMeanPathLength$count),
          col=colourDataScheme[strG][[1]], pch=pointTypeScheme[strG][[1]],type="b")
  }

  bAddPlot <- TRUE
}


```

It follows from a simple geometrical argument that domain boudary-crossings would increase as the circumfernce of the domain increases. 
Interestingly we see that the effect of prey is to constraint the increase in crossings domains larger than ~6 mm, and this is most evident in the NL conditions. 
*Over all crossings over larger domains become more rare in evoked conditions* for all groups, indicating that longer range travels are supressed, probably reflecting changes in turn-rate that constraint larvae to move within the smaller domains.
The *LL* somewhat maintain their longer-range paths, which cross larger boundaries.













```{r stat-Path-calculations, echo=FALSE, fig.show="hold", warning=FALSE, cache=TRUE, out.width="50%"}

#strG <- 'DE'
#hist(ldatDispersion[["40"]][ldatDispersion[["40"]]$groupID == strG,"DisplacementSq"],main=paste(strG,mean(ldatDispersion[["40"]][ldatDispersion[["40"]]$groupID == strG,"DisplacementSq"],na.rm=TRUE) ),xlim=c(0,210))
#hist(ldatDispersion[["20"]][ldatDispersion[["20"]]$groupID == strG,"DisplacementSq"],main=paste(strG,mean(ldatDispersion[["20"]][ldatDispersion[["20"]]$groupID == strG,"DisplacementSq"],na.rm=TRUE) ),xlim=c(0,210))
calcBasicPathStatisticsPerDuration <-function(datDispersion,strG,addPlot=FALSE,powerLawRange = 100)
{
       datGroupDispersion <- datDispersion[datDispersion$groupID %in% strG &
                                          !is.na(datDispersion$DisplacementSq),]
    #dispBreaks <- seq(1,max(datDispersion$DisplacementSq,na.rm=TRUE)+1,15)
    #datGroupDispersion$dispRange <- cut(datGroupDispersion[,"Dispersion" ],breaks=dispBreaks)
    strTitle <- paste("MSD length ", strG,"#",NROW(datGroupDispersion))

    #max(datDispersion$DisplacementSq,na.rm=TRUE)+15
    xbreaks_MSD        <- seq(0,530,15)
    xbreaks_Dispersion <- seq(0,13,0.5)
    xbreaks_Length     <- seq(0,390,10)
    
    #strDispRange <-levels(datGroupDispersion$dispRange)[dispRange]
    #print(strDispRange) 
    if (NROW(datGroupDispersion[ ,"DisplacementSq"]) == 0)
    {
      warning(paste("No rows for MSD ", strG) )
      
      lret<-list(meanPooledMSD=NA,groupID=strG,coeff=NA,ptx_line=NA,pty_line=NA)
      return(lret )
    }
    
    h_MSD_GE <- hist(datGroupDispersion[ ,"DisplacementSq"], breaks=xbreaks_MSD,plot=FALSE)
    h_Dispersion_GE <- hist(datGroupDispersion[ ,"Dispersion"], breaks=xbreaks_Dispersion,plot=FALSE)
    h_Length_GE <- hist(datGroupDispersion[ ,"Length"], breaks=xbreaks_Length,plot=FALSE)
    
    xtick_MSD<-log10(h_MSD_GE$mids)
    xtick_Dispersion<-log10(h_Dispersion_GE$mids)
    xtick_Length<-log10(h_Length_GE$mids)
    
    ##MSD Stat
    lLinModel_GE <- getLogPowerSlope(h_MSD_GE,powerLawRange)
    ## Use Returned list object to add more Data 
    lLinModel_GE$groupID <- strG
    lLinModel_GE$xtickMSD <-xtick_MSD
    lLinModel_GE$logPMFMSD <-log10(100*h_MSD_GE$counts/sum(h_MSD_GE$counts) )
    ## Get MSD per Larva
    lLinModel_GE$meanMSDPerLarva <- tapply(datGroupDispersion[ ,"DisplacementSq"],datGroupDispersion[ ,"expID"],mean)
    lLinModel_GE$sdMSDPerLarva <- tapply(datGroupDispersion[ ,"DisplacementSq"],datGroupDispersion[ ,"expID"],sd)
    lLinModel_GE$countMSDPerLarva <- tapply(datGroupDispersion[ ,"DisplacementSq"],datGroupDispersion[ ,"expID"],NROW)
    # Average over means per larva
    lLinModel_GE$meanGroupMSD <- mean(lLinModel_GE$meanMSDPerLarva,na.rm=T)
    
    lLinModel_GE$meanPooledMSD <- mean(datGroupDispersion[ ,"DisplacementSq"],na.rm=TRUE) ##Add Mean MSD for timeWindow
    lLinModel_GE$sdPooledMSD <- sd(datGroupDispersion[ ,"DisplacementSq"],na.rm=TRUE) ##Add Mean MSD for timeWindow
    lLinModel_GE$countPooledMSD <- NROW(datGroupDispersion[!is.na(datGroupDispersion$DisplacementSq),]) ##Add Mean MSD for timeWindow
    
    ## Path Length
    ##Dispersion Stat - For Each Larva, And As Group
    lLinModel_GE$xtickPathLength <-xtick_Length
    lLinModel_GE$logPMFPathLength <-log10(100*h_Length_GE$counts/sum(h_Length_GE$counts) )
    lLinModel_GE$meanPathLengthPerLarva <- tapply(datGroupDispersion[ ,"Length"],datGroupDispersion[ ,"expID"],mean)
    lLinModel_GE$sdPathLengthPerLarva <- tapply(datGroupDispersion[ ,"Length"],datGroupDispersion[ ,"expID"],sd)
    lLinModel_GE$countPathLengthPerLarva <- tapply(datGroupDispersion[ ,"Length"],datGroupDispersion[ ,"expID"],NROW)

    lLinModel_GE$meanPooledPathLength <- mean(datGroupDispersion[ ,"Length"],na.rm=TRUE) ##Add Mean MSD for timeWindow
    lLinModel_GE$sdPooledPathLength <- sd(datGroupDispersion[ ,"Length"],na.rm=TRUE) ##Add Mean MSD for timeWindow
    lLinModel_GE$countPooledPathLength <- NROW(datGroupDispersion[!is.na(datGroupDispersion$Length),]) ##Add Mean MSD for timeWindow
    
    ##Dispersion Stat - For Each Larva, And As Group
    lLinModel_GE$xtickDispersion <- xtick_Dispersion
    lLinModel_GE$logPMFDispersion <- log10(100*h_Dispersion_GE$counts/sum(h_Dispersion_GE$counts) )
    lLinModel_GE$meanDispersionPerLarva <- tapply(datGroupDispersion[ ,"Dispersion"],datGroupDispersion[ ,"expID"],mean)
    lLinModel_GE$sdDispersionPerLarva <- tapply(datGroupDispersion[ ,"Dispersion"],datGroupDispersion[ ,"expID"],sd)
    lLinModel_GE$countDispersionPerLarva <- tapply(datGroupDispersion[ ,"Dispersion"],datGroupDispersion[ ,"expID"],NROW)

    lLinModel_GE$meanPooledDispersion <- mean(datGroupDispersion[ ,"Dispersion"],na.rm=TRUE) ##Add Mean MSD for timeWindow
    lLinModel_GE$sdPooledDispersion   <- sd(datGroupDispersion[ ,"Dispersion"],na.rm=TRUE) ##Add Mean MSD for timeWindow
    lLinModel_GE$countPooledDispersion <- NROW(datGroupDispersion[!is.na(datGroupDispersion$Dispersion),]) ##Add Mean MSD for timeWindow
    
    return(lLinModel_GE)
}

## A Histogram in Log Scale Of MSD scale
plotLogLogDistribution_MSD <- function(lLinModel_GE,tInter,addPlot=FALSE)
{
    strG <-lLinModel_GE$groupID
    if (!addPlot) 
    {
      plot(lLinModel_GE$xtickMSD,lLinModel_GE$logPMFMSD,
         main=paste(" Log-Log distribution of MSD "),
         xlab="log_10 Mean Squared Displacent (mm)", col=colourDataScheme[strG][[1]], pch=16,
         xlim=c(min(lLinModel_GE$xtickMSD),max(lLinModel_GE$xtickMSD)*1.01),
         ylim=c(-4,3),
         ylab="log N(l) %",xaxt="n" )
        axis(side=1, at=lLinModel_GE$xtickMSD, labels =  as.character(10^lLinModel_GE$xtickMSD))
       #text(x=lLinModel_GE$xtick[seq(0,length(lLinModel_GE$xtick),3)],  par("usr")[3], labels = (10^xtick[seq(0,9,3)]), srt = 45, pos = 1, xpd = TRUE)
    }else
    {
        points(lLinModel_GE$xtickMSD,lLinModel_GE$logPMFMSD,
         main=paste(" Log-Log percentage of MSD " ),
         col=colourDataScheme[strG][[1]], pch=16, ylab="log N(l) %")
    }
    ##Plot Linear Model
    lines(lLinModel_GE$ptx_line,lLinModel_GE$pty_line,lwd=3,col=colourDataScheme[strG][[1]])
  
    ##Distinctivelly show the Distribution Over All Full duration Paths
    if (tInter=="0")
      lines(lLinModel_GE$xtickMSD,lLinModel_GE$logPMFMSD,lwd=3,col="black",lty=2)
      
    return(lLinModel_GE)
}

##Calc the mean pooled MSD from each integration Window and show mean diffusion
plotMSDPerTime <- function(lModelwithMSD,addPlot=FALSE,bUsePooledMean=TRUE,bLogLog=T)
{
  vMSD <- vector()
  vTimeWindow <- vector()
  for (i in 1:NROW(lModelwithMSD))
  {
    if (!is.null(lModelwithMSD[[i]]$meanPooledMSD)) ##If MSD values exist at this point
    {
      if (bUsePooledMean)
        vMSD[i] <- lModelwithMSD[[i]]$meanPooledMSD
      else ##Use Group Mean
        vMSD[i] <- mean(lModelwithMSD[[i]]$meanMSDPerLarva,na.rm=T) ##Same As groupMean
      
      vTimeWindow[i] <- as.numeric( names(lModelwithMSD[i]) )
    }
   # return(0)
  }
  idxOrder <- order(vTimeWindow)
  xLim <- c(1,max(vTimeWindow ) *1.10 )
  #xLim <- c(2,110 *1.10 ) ##Zero covers -The overall Path Duration
  if (!addPlot)
  {
    if(!bLogLog)
          plot(vTimeWindow[idxOrder],vMSD[idxOrder],xlim=xLim,ylim=c(0.1,200),
         col=colourDataScheme[[lModelwithMSD[[1]]$groupID]],
         pch=pointTypeScheme[[lModelwithMSD[[1]]$groupID]],
         xlab="Path duration (sec)", ylab="Mean squared displacement (mm)")
    else
        plot(vTimeWindow[idxOrder],vMSD[idxOrder],xlim=xLim,ylim=c(0.1,200),log="xy",
         col=colourDataScheme[[lModelwithMSD[[1]]$groupID]],
         pch=pointTypeScheme[[lModelwithMSD[[1]]$groupID]],
         xlab="Path duration (sec)", ylab="Mean squared displacement (mm)")
  }else
    points(vTimeWindow[idxOrder],vMSD[idxOrder],
           col=colourDataScheme[[lModelwithMSD[[1]]$groupID]],
           pch=pointTypeScheme[[lModelwithMSD[[1]]$groupID]])
  
  lines(vTimeWindow[idxOrder],vMSD[idxOrder], col=colourDataScheme[[lModelwithMSD[[1]]$groupID]],
        pch=pointTypeScheme[[lModelwithMSD[[1]]$groupID]])

  vHurst <- 0.5*log(vMSD[idxOrder])/log(vTimeWindow[idxOrder])
  message("mean Hurst Exponent:",mean(vHurst[2:length(vHurst)]))
  return(cbind.data.frame(time=vTimeWindow[idxOrder][vTimeWindow > 0],MSD=vMSD[idxOrder][vTimeWindow > 0]) )
}

##Scan Though all Time Integrations in Data and plot histogram and get MSD mean values
processMSDPerIntegrationTime <- function(ldatDispersion,strG,lMSDSummaryData,bAddPlot = FALSE)
{

  for (tt in names(ldatDispersion))
  {
    message("Processing MSD for ",strG," T:",tt)
    lMSDSummaryData[[strG]][[as.character(tt)]] <- calcBasicPathStatisticsPerDuration(ldatDispersion[[tt]],strG,bAddPlot)
    bAddPlot <- TRUE
  }
  
  return(lMSDSummaryData)
}

makeMSDPathDurationSummary <- function(vtimeWindows,bParallel=FALSE)
{
  lMSDSummaryData <- list()
  # Process Each Time Interval Sequentially
  for (t in vtimeWindows)
  {
    ldatDispersion <- list()
    #<- readRDS(file=paste0(strDataStore,"/foragingState_Dispersion",t,"sec.rds") ) ##loadDispersionData(forceReload = TRUE,t)
    
    ldatDispersion[[as.character(t)]] <- loadDispersionData(forceReload =  TRUE, t)
    #lMSDSummaryData <- processMSDPathDurationSummary_Parallel(ldatDispersion,strG,lMSDSummaryData)
    ##Make Sub List For Each group - Add the different Time Intervals as sub-lists
    if  (!bParallel)
    {
      for (strG  in vGroups)
      {
          if (is.null(lMSDSummaryData[[strG]] ) ) ##list per twindow integration for this group
            lMSDSummaryData[[strG]] <- list()
          
        lMSDSummaryData <- processMSDPerIntegrationTime(ldatDispersion,strG,lMSDSummaryData)
      }
    }
    ##Clear Memory
    rm(ldatDispersion)
  }
  message("Path stat summary over duration time windows done.")
  message(paste0(strDataExportDir,"statPerPathDurationSummaryResults-",head(vtimeWindows,1),"-",tail(vtimeWindows,1),"sec.rds"))
  saveRDS(lMSDSummaryData,paste0(strDataExportDir,"statPerPathDurationSummaryResults-",head(vtimeWindows,1),"-",tail(vtimeWindows,1),"sec.rds"))
  
  return(lMSDSummaryData)
}
# Main Load/Make MSD Distributios and Mean MSD versus time (Path Duration)

### TODO : NOT COMPLETED - Function needs to be defined within foreach
processMSDPathDurationSummary_Parallel <- function(ldatDispersion,strG,lMSDSummaryData)
{
  library(foreach)
  library(doParallel)

  #setup parallel backend to use many processors
  cores=detectCores()
  cl <- makeCluster(cores[1]-1) #not to overload your computer
  registerDoParallel(cl)

  #.combine=rbind
  lMSDSummaryData <- foreach(strG=vGroups  ) %dopar% {
                        lMSDSummaryData[[strG]] <- list()
                        lMSDSummaryData <- processMSDPerIntegrationTime(ldatDispersion,strG,lMSDSummaryData)
   #do other things if you want
   #lMSDSummaryData #Equivalent to finalMatrix = cbind(finalMatrix, tempMatrix)
                    }

  #stop cluster
  stopCluster(cl)
return(lMSDSummaryData)
}

rm(ldatDispersion)
ldatDispersion <- list()
lLinModel <- list() ##Start new list Containing The mean Vals per group per time

vtimeWindows <- getAvailablePathTimewindows()
rm(lMSDSummaryData)
try(
  lMSDSummaryData <<- readRDS(paste0(strDataExportDir,"statPerPathDurationSummaryResults-",min(vtimeWindows),"-",max(vtimeWindows),"sec.rds"))
)
if (!exists("lMSDSummaryData"))
{
  lMSDSummaryData <<- makeMSDPathDurationSummary(vtimeWindows)
  #lMSDSummaryData <- makeMSDPathDurationSummary_Parallel
}

```





## Dispersion over time - Clearly Distinct for LE

In the initial sections I took Marquez et al 2019 regime to estimate dispersions given a 5sec window. But how dispersions change over time is uknown. Lets have a look:


```{r dispersion among larvae across time, fig.show="hold",fig.cap="Mean dispersions over path lengths of increasing durations ", out.width="50%", echo=FALSE, cache=FALSE}

plotDispersionVsTimePerLarva <- function(lModelwithMSD,addPlot=FALSE)
{
  
  lMSD <- list()
  vTimeWindow <- vector()
  for (i in 1:NROW(lModelwithMSD))
  {
    if (!is.null(lModelwithMSD[[i]]$meanDispersionPerLarva))
    {
        lMSD[[i]] <- lModelwithMSD[[i]]$meanDispersionPerLarva
        vTimeWindow[i] <-as.numeric( names(lModelwithMSD[i]) )
    }
  }
  ##Now plot MSD evolution of each larva
  datMeanMSDVsTimePerLarva <- data.frame(do.call(rbind,lMSD))
  if (!addPlot)
    plot(vTimeWindow,datMeanMSDVsTimePerLarva[,1],type="p",col=colourDataScheme[lModelwithMSD[[1]]$groupID][[1]],ylim=c(0,13),ylab="Dispersion (mm)",xlab="Time (sec)")
  for (i in 1:ncol(datMeanMSDVsTimePerLarva))
    lines(vTimeWindow,datMeanMSDVsTimePerLarva[,i],type="p",col=colourDataScheme[lModelwithMSD[[1]]$groupID][[1]])
  
} 

plotDispersionVsTimePerLarva(lMSDSummaryData[["NE"]],FALSE)
plotDispersionVsTimePerLarva(lMSDSummaryData[["NL"]],FALSE)
title(main="NL Dispersion ")
plotDispersionVsTimePerLarva(lMSDSummaryData[["LE"]],FALSE)
plotDispersionVsTimePerLarva(lMSDSummaryData[["LL"]],FALSE)
title(main="LL Dispersion ")
plotDispersionVsTimePerLarva(lMSDSummaryData[["DE"]],FALSE)
plotDispersionVsTimePerLarva(lMSDSummaryData[["DL"]],FALSE)
title(main="DL Dispersion ")  
```



```{r  dispersion over log-log distribution , fig.show="hold", out.width="50%", echo=FALSE,results=FALSE,warning=TRUE, cache=TRUE }

## A Histogram in Log Scale Of MSD scale
plotLogLogDistribution_Dispersion <- function(lLinModel_GE,addPlot=FALSE)
{
    strG <-lLinModel_GE$groupID
    if (!addPlot) 
    {
      plot(lLinModel_GE$xtickDispersion,lLinModel_GE$logPMFDispersion,
         main=paste(" Log-Log distribution of Dispersion "),
         xlab="log_10 Dispersion (mm)", col=colourDataScheme[strG][[1]], pch=16,
         xlim=c(min(lLinModel_GE$xtickDispersion,na.rm=TRUE),max(lLinModel_GE$xtickDispersion,na.rm=TRUE)*1.01),
         ylim=c(-4,3),
         ylab="log N(l) %",xaxt="n" ,type="b")
        axis(side=1, at=lLinModel_GE$xtickDispersion, labels =  as.character(10^lLinModel_GE$xtickDispersion))
       #text(x=lLinModel_GE$xtick[seq(0,length(lLinModel_GE$xtick),3)],  par("usr")[3], labels = (10^xtick[seq(0,9,3)]), srt = 45, pos = 1, xpd = TRUE)
    }else
    {
        points(lLinModel_GE$xtickDispersion,lLinModel_GE$logPMFDispersion,
         main=paste(" Log-Log percentage of Dispersion " ),type="b",
         xlab="log_10 Dispersion (mm)", col=colourDataScheme[strG][[1]], pch=16, ylab="log N(l) %")
    }
    ##Plot Linear Model
    lines(lLinModel_GE$ptx_line,lLinModel_GE$pty_line,lwd=3,col=colourDataScheme[strG][[1]])
  
    return(lLinModel_GE)
}

##Collect the mean MSD from each Dispersion Calcl integration Window and show mean diffusion
plotDispersionPerTime <- function(lModelwithDispersion,addPlot=FALSE)
{
  vDispersion <- vector()
  vTimeWindow <- vector()
  for (i in 1:NROW(lModelwithDispersion))
  {
    if (!is.null(lModelwithDispersion[[i]]$meanDispersion))
    {# \TODO CHECK WARNING HERE
      vDispersion[i] <- mean(lModelwithDispersion[[i]]$meanDispersion)
      vTimeWindow[i] <-as.numeric( names(lModelwithDispersion[i]) )
    }
   # return(0)
  }
  idxOrder <- order(vTimeWindow)
  xLim <- c(0,max(vTimeWindow ) *1.10 )
  if (!addPlot)
  {
    plot(vTimeWindow[idxOrder],vDispersion[idxOrder],xlim=xLim,ylim=c(0,13),
         col=colourDataScheme[[lModelwithDispersion[[1]]$groupID]],
         pch=pointTypeScheme[[lModelwithDispersion[[1]]$groupID]],
         xlab="Path duration (sec)", ylab="Dispersion (mm)")
  }else
    points(vTimeWindow[idxOrder],vDispersion[idxOrder],
           col=colourDataScheme[[lModelwithDispersion[[1]]$groupID]],
           pch=pointTypeScheme[[lModelwithDispersion[[1]]$groupID]])
  
  lines(vTimeWindow[idxOrder],vDispersion[idxOrder], col=colourDataScheme[[lModelwithDispersion[[1]]$groupID]],
        pch=pointTypeScheme[[lModelwithDispersion[[1]]$groupID]])
}

# Main Load/Make MSD Distributios and Mean MSD versus time (Path Duration)

vGroups <- c("LL","LE","NL","NE","DL","DE")
vsmallTimeWindows <- c(1,2,4,5,6,7,8,10,15,20,30,40,50,60)
vLargeScaletimeWindows <- c(0,2,10,40,80,120,180,200,260) #360 No Data
#vtimeWindows <- c(vsmallTimeWindows,70,80,90,95,98,100,120,180)# c(1,2,4) # vsmallTimeWindows##c(4,10,20,80,200,260,360)
##Process *  Serially * So we do not run out of memory
# Results are plotted and Aggregated In lLinModel
vtimeWindows <- getAvailablePathTimewindows()
try(
  {
  rm(lMSDSummaryData);
lMSDSummaryData <<- readRDS(paste0(strDataExportDir,"statPerPathDurationSummaryResults-",min(vtimeWindows),"-",max(vtimeWindows),"sec.rds"))
}
)
if (!exists("lMSDSummaryData"))
{ ##Same As Above - Repeated Here IN case we want to run this independently
  lMSDSummaryData <<- makeMSDPathDurationSummary(vtimeWindows)
}
  
##Now Plot All processed Results results
for (strG  in vGroups)
{
  bAddPlot <- FALSE
 for (tt in names( lMSDSummaryData[[strG]]) )
  {
    plotLogLogDistribution_Dispersion(lMSDSummaryData[[strG]][[as.character(tt)]],bAddPlot )
   bAddPlot <- TRUE
  }
}


```



```{r Dispersion over time , fig.cap="Dispersion for LF spontaneous grows distinctively fast, in agreement with MSD", fig.show="hold", out.width="100%", echo=FALSE, cache=FALSE}

##Get Distribution of MSD and Mean MSD for each time integration window 
##load Precalc Results
  plotDispersionPerTime(lMSDSummaryData[["NE"]])
  plotDispersionPerTime(lMSDSummaryData[["NL"]],TRUE)
  plotDispersionPerTime(lMSDSummaryData[["LE"]],TRUE)
  plotDispersionPerTime(lMSDSummaryData[["LL"]],TRUE)
  plotDispersionPerTime(lMSDSummaryData[["DE"]],TRUE)
  plotDispersionPerTime(lMSDSummaryData[["DL"]],TRUE)
  
  legend("topright", legend=names(colourDataScheme)[4:9],
         col=unlist(colourDataScheme[names(colourDataScheme)[4:9]]),
         pch=unlist(pointTypeScheme[names(colourDataScheme)[4:9]]) )

# legend("topright", 
#            legend=c(paste("Spont μ",format(lLinModel_DE[[1]]$coeff,digits=2)),
#                     paste("Evoked μ",format(lLinModel_DL[[1]]$coeff,digits=2) ) ),
#        col=c(colourDataScheme$DE ,colourDataScheme$DL) ,pch=c(16,16) )

```

:::
{#figDispersionPerTime}

As with the development of MSD over time, I also find that Dispersion is distinct for LE, and thus with experience larvae learn when to initiate exploration, (at sooner than  controls) .


## Comparing Mean Path Lengths

```{r path-length larval-mean across time, fig.show="hold",fig.cap="Mean group (mean per larva) path-length with increasing duration ", out.width="50%", echo=FALSE, cache=FALSE}

# Collect the mean PathLength from each Dispersion Calcl integration Window and show mean diffusion
# Path Length Mean
plotMeanPathLengthVsTime <- function(lModelwithMSD,addPlot=FALSE, bUsePooledMean=TRUE)
{
  vPathLength <- vector()
  vTimeWindow <- vector()
  for (i in 1:NROW(lModelwithMSD))
  {
    if (!is.null(lModelwithMSD[[i]]$meanPooledPathLength))
    {
      if (bUsePooledMean)
        vPathLength[i] <- lModelwithMSD[[i]]$meanPooledPathLength
      else ##Use Group Mean
        vPathLength[i] <- mean(lModelwithMSD[[i]]$meanPathLength,na.rm=TRUE)
      
      vTimeWindow[i] <-as.numeric( names(lModelwithMSD[i]) )
    }
   # return(0)
  }
  idxOrder <- order(vTimeWindow)
  xLim <- c(0,max(vTimeWindow ) *1.10 )
  if (!addPlot)
  {
    plot(vTimeWindow[idxOrder],vPathLength[idxOrder],xlim=xLim,ylim=c(0,200),
         col=colourDataScheme[[lModelwithMSD[[1]]$groupID]],
         pch=pointTypeScheme[[lModelwithMSD[[1]]$groupID]],
         xlab="Path duration (sec)", ylab="mean path length (mm)")
  }else
    points(vTimeWindow[idxOrder],vPathLength[idxOrder],
           col=colourDataScheme[[lModelwithMSD[[1]]$groupID]],
           pch=pointTypeScheme[[lModelwithMSD[[1]]$groupID]])
  
  lines(vTimeWindow[idxOrder],vPathLength[idxOrder], col=colourDataScheme[[lModelwithMSD[[1]]$groupID]],
        pch=pointTypeScheme[[lModelwithMSD[[1]]$groupID]])
}


plotMeanPathLengthVsTime(lMSDSummaryData[["NE"]],FALSE,FALSE)
plotMeanPathLengthVsTime(lMSDSummaryData[["NL"]],TRUE,FALSE)
plotMeanPathLengthVsTime(lMSDSummaryData[["LE"]],TRUE,FALSE)
plotMeanPathLengthVsTime(lMSDSummaryData[["LL"]],TRUE,FALSE)
title(main="Mean group path length ")
plotMeanPathLengthVsTime(lMSDSummaryData[["DE"]],TRUE,FALSE)
plotMeanPathLengthVsTime(lMSDSummaryData[["DL"]],TRUE,FALSE)

plotMeanPathLengthVsTime(lMSDSummaryData[["NE"]],FALSE,TRUE)
plotMeanPathLengthVsTime(lMSDSummaryData[["NL"]],TRUE,TRUE)
plotMeanPathLengthVsTime(lMSDSummaryData[["LE"]],TRUE,TRUE)
plotMeanPathLengthVsTime(lMSDSummaryData[["LL"]],TRUE,TRUE)
title(main="Pooled Mean path length ")
plotMeanPathLengthVsTime(lMSDSummaryData[["DE"]],TRUE,TRUE)
plotMeanPathLengthVsTime(lMSDSummaryData[["DL"]],TRUE,TRUE)


```

Interestignly, the above plot is representative of the speed of movement over time. The mean distance travelled over long periods of time depends on experience. 
  - NF show constant speed across time, regardless of how long the duration of path is, They travel more in the presence of prey 
  - LF change speed over time, Without prey, the speed up after a minute, and with prey they slow down.
        -*(Show whether this is adaptive behaviour or simply a heteregenous population)*
  - DF, similar to LF  but slower

### Path Length Distributions

```{r path-length among larvae across time, fig.show="hold",fig.cap="Distribution of larval mean path-lengths with increasing duration ", out.width="50%", echo=FALSE, cache=FALSE}

## This plots The mean points Per Larvae- Revealing the Distribution
plotPathVsTimePerLarva <- function(lModelwithMSD, addPlot=FALSE)
{
  
  lMSD <- list()
  vTimeWindow <- vector()
  for (i in 1:NROW(lModelwithMSD))
  {
    if (!is.null(lModelwithMSD[[i]]$meanPathLengthPerLarva))
    {
        lMSD[[i]] <- lModelwithMSD[[i]]$meanPathLengthPerLarva
        vTimeWindow[i] <-as.numeric( names(lModelwithMSD[i]) )
    }
  }
  ##Now plot MSD evolution of each larva
  datMeanMSDVsTimePerLarva <- (do.call(rbind.data.frame,lMSD))
  if (!addPlot)
    plot(vTimeWindow,datMeanMSDVsTimePerLarva[,1],type="p",col=colourDataScheme[lModelwithMSD[[1]]$groupID][[1]],pch=pointTypeScheme[lModelwithMSD[[1]]$groupID][[1]],
         ylim=c(0,250),xlim=c(0,250),ylab="mean larval path length (mm)",xlab="Time (sec)",)
  for (i in 1:ncol(datMeanMSDVsTimePerLarva))
    lines(vTimeWindow,datMeanMSDVsTimePerLarva[,i],type="p",col=colourDataScheme[lModelwithMSD[[1]]$groupID][[1]],pch=pointTypeScheme[lModelwithMSD[[1]]$groupID][[1]])
  
} 

plotPathVsTimePerLarva(lMSDSummaryData[["NE"]],FALSE)
plotPathVsTimePerLarva(lMSDSummaryData[["NL"]],FALSE)
title(main="NL Mean path length per larva")
plotPathVsTimePerLarva(lMSDSummaryData[["LE"]],FALSE)
plotPathVsTimePerLarva(lMSDSummaryData[["LL"]],FALSE)
title(main="LL Mean path length per larva")
plotPathVsTimePerLarva(lMSDSummaryData[["DE"]],FALSE)
plotPathVsTimePerLarva(lMSDSummaryData[["DL"]],FALSE)
title(main="DL Mean path length per larva")  

```


Looking at the mean path length against time of each larva:

  -Experienced larvae move faster, ie travelling larger distance over the equal amounts of path duration to controls.
  - The LE paths are the shortest in duration, and the fastest, supporting that the LE larvae move out of the ROI quicker.
 - NF seem to accellerate movement in the presence of prey and so does DF
 - NF shows suprising linear rise in path-length with time - constant speed (homogeneous population perhaps) in both conditions (E/S)
 

*I need to fit linear functions to get distributions of estimated travel-speed per larvae.*
 


```{r prob-of-path-length, fig.cap="Distribution of overall path lengths (regardless of duration) shows likely power laws, with evoked conditions having longer tails, (lower mu < 2) and evoked mu > 2 across groups ",echo=FALSE,include=FALSE}

plot_PathLengthDistribution <- function(lMSDGroupSummaryData,addPlot=FALSE,linRegion=12)
{
  vLarvaFraction <- vector()

    ## 0 Index Contains PAth lengths Unconstrained of duration
    vLarvaFraction <- lMSDGroupSummaryData[["0"]]$logPMFPathLength
    vPathLengths  <- lMSDGroupSummaryData[["0"]]$xtickPathLength
    
    proportion <- (unlist(vLarvaFraction[(10^vPathLengths) > linRegion]))
    length <- vPathLengths[(10^vPathLengths) > linRegion]
    linFit <- lm(proportion[proportion >0 ] ~ length[proportion >0 ] )
    #linFit <- lm(proportion~length,data=datHist[!is.infinite(datHist$proportion),] )
  
    y_linModel <- (linFit$coefficients[1] + (linFit$coefficients[2]* (linFit$model$length ) ) )
    x_linModel <- linFit$model$length
  
  if (!addPlot)
  {
    plot((vPathLengths),(unlist(vLarvaFraction)),type="b",
         col=colourDataScheme[lMSDGroupSummaryData[[1]]$groupID][[1]],pch=pointTypeScheme[lMSDGroupSummaryData[[1]]$groupID][[1]],
         ylim=c(-1,2),xlim=c(0,2.5),ylab="log % of larvae ",xlab="log path length (mm)",xaxt="n" )
    
    axXTick <- axisTicks(c(0,max(length)) ,log=TRUE)
    axis(side=1, at=log10(axXTick), labels =  as.character(axXTick) ) 
    
  }
  #for (i in 1:NROW(lMSDGroupSummaryData))
    lines((vPathLengths),(unlist(vLarvaFraction)),type="b",
          col=colourDataScheme[lMSDGroupSummaryData[[1]]$groupID][[1]],pch=pointTypeScheme[lMSDGroupSummaryData[[1]]$groupID][[1]])
  
  ##Add Linear Model On PowerLaw Drop
    lines(x_linModel,y_linModel,lwd=2,lty=2,col=colourDataScheme[lMSDGroupSummaryData[[1]]$groupID][[1]])
    return(linFit)
} 

#lMSDSummaryData <- 
linMod <- list()
linMod[["NE"]] <- plot_PathLengthDistribution(lMSDSummaryData[["NE"]])
linMod[["NL"]] <- plot_PathLengthDistribution(lMSDSummaryData[["NL"]],TRUE)

linMod[["LE"]] <- plot_PathLengthDistribution(lMSDSummaryData[["LE"]],TRUE)
linMod[["LL"]] <- plot_PathLengthDistribution(lMSDSummaryData[["LL"]],TRUE)

linMod[["DE"]] <- plot_PathLengthDistribution(lMSDSummaryData[["DE"]],TRUE)
linMod[["DL"]] <- plot_PathLengthDistribution(lMSDSummaryData[["DL"]],TRUE)
title(main=" Distribution of path lengths ")

vLegend<-vector()
for (i in 4:9)
  vLegend[i-3] <- paste(names(colourDataScheme)[i],"μ=", format(linMod[[ names(colourDataScheme)[i] ]]$coeff[2],digits=2) )

legend("topright", legend=vLegend,
         col=unlist(colourDataScheme[names(colourDataScheme)[4:9]]),
         pch=unlist(pointTypeScheme[names(colourDataScheme)[4:9]]) )

#plot(lMSDSummaryData$LL$`0`$logPMFPathLength)


```
 
    
 
## Probability of staying within bounded recording area shows LF move out quickest

The above Dispersion and MSD plots analysed at the level of each larva against time raise gave me the idea that it may be useful to describe differences in the motion between groups in terms of the probability of staying within a bounded area $A$ with increasing time $P(within A | t)$ , or $P_A(t)$.
This can be calculated through the fraction of points larvae that remain observable with increasing path duration $T$, because larvae are more likely to leave the arena with increasing path-duration, and thus the probaility of observing a path-length longer than $T>X$, can be indicative of difference in how the disperse, or explore space.

```{r prob-of-path-duration, fig.cap="Probability of path duration reveals differences in the amount of time larva dwell within an area. LF spontaneous move out faster than controls, with an exponent that appears near the optimal 2",echo=FALSE,results=FALSE}


plot_ProbOfPathDuration <- function(lMSDGroupSummaryData,addPlot=FALSE,linRegion=12)
{
 lLarvaFraction <- list()
  vTimeWindow <- vector()
  for (i in 1:NROW(lMSDGroupSummaryData))
  {
    if (!is.null(lMSDGroupSummaryData[[i]]$countMSDPerLarva))
    { ##Divide as a fraction of larval population count with the smalles path duration
        lLarvaFraction[[i]] <- nrow(lMSDGroupSummaryData[[i]]$countMSDPerLarva)/nrow(lMSDGroupSummaryData[[1]]$countMSDPerLarva)
        vTimeWindow[i] <-as.numeric( names(lMSDGroupSummaryData[i]) )
    }
  }
    proportion <- log10(unlist(lLarvaFraction[vTimeWindow > linRegion]))
    duration <- log10(vTimeWindow[vTimeWindow > linRegion]) 
    linFit <- lm(proportion ~ duration )
    #linFit <- lm(proportion~length,data=datHist[!is.infinite(datHist$proportion),] )
  
  y_linModel <- (linFit$coefficients[1] + (linFit$coefficients[2]* (linFit$model$duration ) ) )
  x_linModel <- linFit$model$duration
  
  
  if (!addPlot)
  {
    plot(log10(vTimeWindow),log10(unlist(lLarvaFraction)),type="b",
         col=colourDataScheme[lMSDGroupSummaryData[[1]]$groupID][[1]],pch=pointTypeScheme[lMSDGroupSummaryData[[1]]$groupID][[1]],
         ylim=c(-2,1),xlim=c(0,2.5),ylab="log fraction of larvae ",xlab="log time to escape circular ROI (sec)",xaxt="n" )
    axis(side=1, at=log10(vTimeWindow), labels =  as.character(vTimeWindow) ) 
  }
  #for (i in 1:NROW(lMSDGroupSummaryData))
    lines(log10(vTimeWindow),log10(unlist(lLarvaFraction)),type="b",
          col=colourDataScheme[lMSDGroupSummaryData[[1]]$groupID][[1]],pch=pointTypeScheme[lMSDGroupSummaryData[[1]]$groupID][[1]])
  
  ##Add Linear Model On PowerLaw Drop
    lines(x_linModel,y_linModel,lwd=2,lty=2,col=colourDataScheme[lMSDGroupSummaryData[[1]]$groupID][[1]])
    
    #message(lMSDGroupSummaryData[[1]]$groupID[[1]], linFit$coefficients )
    
    
    
    return(linFit)
} 
#lMSDSummaryData <- 
linMod <- list()
linMod[["NE"]] <- plot_ProbOfPathDuration(lMSDSummaryData[["NE"]])
linMod[["NL"]] <- plot_ProbOfPathDuration(lMSDSummaryData[["NL"]],TRUE)

linMod[["LE"]] <- plot_ProbOfPathDuration(lMSDSummaryData[["LE"]],TRUE)
linMod[["LL"]] <- plot_ProbOfPathDuration(lMSDSummaryData[["LL"]],TRUE)

linMod[["DE"]] <- plot_ProbOfPathDuration(lMSDSummaryData[["DE"]],TRUE)
linMod[["DL"]] <- plot_ProbOfPathDuration(lMSDSummaryData[["DL"]],TRUE)
title(main=" Distribution of path durations ")

vLegend<-vector()
for (i in 4:9)
  vLegend[i-3] <- paste(names(colourDataScheme)[i],"μ=", format(linMod[[ names(colourDataScheme)[i] ]]$coeff[2],digits=2) )

legend("topright", legend=vLegend,
         col=unlist(colourDataScheme[names(colourDataScheme)[4:9]]),
         pch=unlist(pointTypeScheme[names(colourDataScheme)[4:9]]) )


```

The above mean path lengths are equivalent to the mean path length between entering and exiting a circlular region, as the depict the length of path from the time the larva enters the tracking ROI until its exit.

The probability of path duration plot gives some clarity on what is actually happening. We estimate this probability by counting the fraction of larvae that show paths with duration of $T$ (perhaps I could/should be counting the number of paths per larvae maybe?)
In any case paths above a particular duration, are not generated because the larva has moved out of view by time T, and thus is out of bounds. This is equivalent to measuring Exit times from the ~22mm tracking ROI. Clearly LF are behaving distinctively, with shorter exit times in both Spontaneous and Evoked conditions. The Evoked LF are similar to the spontaneous DF,NF, while **LF larva in absence of prey move out of the region quicker than controls**

Linear fitting to the log-log curves can approximate the power law exponent. 


## Mean Squared Displacement - looking for diffusion type

A prediction of the theory of *Fickian diffusion is that the mean squared displacement of a ‘random walker’ increases linearly with time*, not *super linearly (for example, quadratically) or sublinearly (for example, as the square root).
Any process that is inconsistent with Fick’s laws  is known as anomalous diffusion: super diffusion leads to superlinear
 growth of the mean squared displacement,  whereas subdiffusion leads to sublinear growth (#viswanathan2010fish).

The MSD at time t {\displaystyle t} t is defined as an ensemble average (statistical mechanics): 
\[
MSD(t) = |\vec{x(t)} - \vec{x_0}|^2 = \frac{1}{N}\sum^{N}_{i=1}|x^{(i)}(t) - x^{(i)}(0)  |^2 \>
\]
where N is the number of particles (here trajectories) to be averaged, vector $\vec{x_0}$ is the reference position of the i-th particle and vector $\vec{x(t)}$ is the position fo the i-th particle at time $t$.



### MSD distributions over full and time-constrained paths

```{r mean-squared-displacement Log-Log distributions , fig.show="hold", out.width="50%", echo=FALSE, cache=TRUE }

##Now Plot All processed Results results
for (strG  in vGroups)
{
  bAddPlot <- FALSE
 for (tt in names( lMSDSummaryData[[strG]]) )
  {
   
    plotLogLogDistribution_MSD(lMSDSummaryData[[strG]][[as.character(tt)]],tt,bAddPlot )
    bAddPlot <- TRUE
 }
  legend("bottomleft",lty=c(2,NA),pch=c(NA,16),legend=c("Full path",paste("Fixed duration",names( lMSDSummaryData[[strG]])[1],"-",tt )) )
}

```

MSD over full event path duration looks the same across groups.

### MSD over time 

The duration-contrained MSDs however do not look  similar between conditions and groups:
  - *LF evoked contains larger MSDs than spontaneous - Same in NF but prob not in DF*

```{r mean-squared-distance over time on pooled data, fig.show="hold",fig.cap="Pooled Mean squared distance over time for LF spontaneous shows distinctive quick growth", out.width="100%", echo=FALSE, cache=FALSE,fig.show="hold", out.width="50%"}



##Get Distribution of MSD and Mean MSD for each time integration window 
##load Precalc Results
bLog <- TRUE
lMSDVsTimeData_Pooled <- list()
## Returns MSD and Time which we can use to calculate Hurst Coefficient
  lMSDVsTimeData_Pooled[["NE"]] <- plotMSDPerTime(lMSDSummaryData[["NE"]],FALSE,TRUE,bLog)
  lMSDVsTimeData_Pooled[["NL"]] <- plotMSDPerTime(lMSDSummaryData[["NL"]],TRUE,TRUE,bLog)
  lMSDVsTimeData_Pooled[["LE"]] <- plotMSDPerTime(lMSDSummaryData[["LE"]],TRUE,TRUE,bLog)
  lMSDVsTimeData_Pooled[["LL"]] <- plotMSDPerTime(lMSDSummaryData[["LL"]],TRUE,TRUE,bLog)
  lMSDVsTimeData_Pooled[["DE"]] <- plotMSDPerTime(lMSDSummaryData[["DE"]],TRUE,TRUE,bLog)
  lMSDVsTimeData_Pooled[["DL"]] <- plotMSDPerTime(lMSDSummaryData[["DL"]],TRUE,TRUE,bLog)
  title(main="Pooled Mean")
  legend("bottomright", legend=names(colourDataScheme)[4:9],
         col=unlist(colourDataScheme[names(colourDataScheme)[4:9]]),
         pch=unlist(pointTypeScheme[names(colourDataScheme)[4:9]]) )

lMSDVsTimeData_Grouped <- list()  
  lMSDVsTimeData_Grouped[["NE"]] <- plotMSDPerTime(lMSDSummaryData[["NE"]],FALSE,FALSE,bLog)
  lMSDVsTimeData_Grouped[["NL"]] <- plotMSDPerTime(lMSDSummaryData[["NL"]],TRUE,FALSE,bLog)
  lMSDVsTimeData_Grouped[["LE"]] <- plotMSDPerTime(lMSDSummaryData[["LE"]],TRUE,FALSE,bLog)
  lMSDVsTimeData_Grouped[["LL"]] <- plotMSDPerTime(lMSDSummaryData[["LL"]],TRUE,FALSE,bLog)
  lMSDVsTimeData_Grouped[["DE"]] <- plotMSDPerTime(lMSDSummaryData[["DE"]],TRUE,FALSE,bLog)
  lMSDVsTimeData_Grouped[["DL"]] <- plotMSDPerTime(lMSDSummaryData[["DL"]],TRUE,FALSE,bLog)
  title(main="Group Mean")
  legend("bottomright", legend=names(colourDataScheme)[4:9],
         col=unlist(colourDataScheme[names(colourDataScheme)[4:9]]),
         pch=unlist(pointTypeScheme[names(colourDataScheme)[4:9]]) )
  
  ##Hurst Exponent per time
 
   
## Use the Fixed Domain Data Paths to examine Durations distribution for fat-tails and And MSD per duration
  strG <- "NL"
  
  for (strG in vGroups)
  {
   durationBreaks <- seq(0,150,0.05)
   lBoundedTrackInfo[[strG]]$DurationBin <- cut(unlist(lBoundedTrackInfo[[strG]]$duration),breaks=durationBreaks)
  vMSDPerDuration <- tapply(unlist(lBoundedTrackInfo[[strG]]$SqDisplacement),lBoundedTrackInfo[[strG]]$DurationBin,mean)
  plot(durationBreaks[1:length(durationBreaks)-1],sqrt(vMSDPerDuration),
       main=paste(strG," domain R path MSD vs duration" ) )
  hist_Dur <- hist(unlist(lBoundedTrackInfo[[strG]]$duration),breaks=seq(0,175,3), 
       xlim=c(0,50),plot=FALSE )
   plot(hist_Dur$mids,hist_Dur$counts,log="xy",main=paste(strG," domain R path duration" ))
  }
  
  plot(unlist(lBoundedTrackInfo[[strG]]$duration),sqrt(unlist(lBoundedTrackInfo[[strG]]$SqDisplacement)) )
  

```



What is clear is that MSD becomes truncated around 10 seconds in, and that the LE grows the fastest. 
By that time the radius of displacement covered on average for LE is `r sqrt(lMSDSummaryData[["LE"]][["10"]]$meanGroupMSD)`mm, while for NE  `r sqrt(lMSDSummaryData[["NE"]][["10"]]$meanGroupMSD)`, for DE `r sqrt(lMSDSummaryData[["NE"]][["10"]]$meanGroupMSD)`

<!---TODO: Take the 0 dispersion data, which contain measurements in reference to path start, and look at msd per path duration so that the number of - Nope lets look at path-duration within fixed domains-->

## Identify diffusion type using Hurst coefficients

```{r Hurst coefficient over path durations , fig.show="hold",fig.cap=" Hurst coefficients between the range of 1 > H > 1/2 indicates superdiffusion, while H > 1 indicates Balistic behaviour.", out.width="100%", echo=FALSE, cache=FALSE}

addPlot <- FALSE
for (strG in vGroups)
{
  linFit <- lm(log10(lMSDVsTimeData_Grouped[[strG]]$time) ~ log10(lMSDVsTimeData_Grouped[[strG]]$MSD)  )
  #plotMSDPerTime(lMSDSummaryData[["LL"]],FALSE,FALSE,bLog)
  #plot(linFit$model$`log(lMSDVsTimeData_Grouped[["LL"]]$time)`, lin_Mod$fitted.values )
  y_linModel <- (linFit$coefficients[1] + (linFit$coefficients[2]* (linFit$model$`log10(lMSDVsTimeData_Grouped[[strG]]$MSD)` ) ) )
  x_linModel <- linFit$model$`log10(lMSDVsTimeData_Grouped[[strG]]$time)`
  #plot(x_linModel,y_linModel,main=strG,ylim=c(0,2))
  #points(log10(lMSDVsTimeData_Grouped[[strG]]$time) , log10(lMSDVsTimeData_Grouped[[strG]]$MSD),main=strG)

  vhurstCoeff <- 0.5*log10(lMSDVsTimeData_Grouped[[strG]]$MSD)/log10(lMSDVsTimeData_Grouped[[strG]]$time)
  n <- length( vhurstCoeff)
  if (!addPlot)
    plot( lMSDVsTimeData_Grouped[[strG]]$time[2:n], vhurstCoeff[2:n],
        ylab="Hurst coefficient (log(MSD)/log(duration))", xlab="Path duration (sec)",type="b",
        main="Hurst coefficient per path duration (Grouped)", ylim=c(0.5,4), log="xy", col=colourDataScheme[strG][[1]], pch=pointTypeScheme[strG][[1]] )
  else
    lines( lMSDVsTimeData_Grouped[[strG]]$time[2:n], vhurstCoeff[2:n],type="b",
           col=colourDataScheme[strG][[1]], pch=pointTypeScheme[strG][[1]])

  addPlot <- TRUE
  message(strG," lin fit Hurst Coeff:",linFit$coefficients[2]/2, " Converge:", mean(tail(vhurstCoeff),na.rm=FALSE ) )
  #Balistic H limit
  segments(0,1,100,1)
}
```


The Hurst exponent equals half the slope in the double-log plot of the mean squared displacement versus time for a random walk.
Alternatively, it equals the slope of the double-log plot of the root mean squared displacement (see #viswanathan2011physics pg. 28)

Intermittent searches typically consist of alternating phases: a Brownian search phase alternating with ballistic relocations. The ballistic relocations help to reduce oversampling, in a manner similar to how Lévy walks help reduce oversampling.

Thus evidence of *Balistic* motion (H>1) are stronger in LE indicating the ontogeny of intermittent search strategies, through balistic relocations. This is a result of experience because in controls the coefficients appear identical in the respective test conditions.

Do intermittent searches correspond to the actual movements of real organisms? Intermittent searches appear to work 
remarkably well for some species. For example, they may correctly describe the phenomenology of planktivorous fish and ground-foraging birds [304]. Atlantic bluefin tuna (Thunnus thynnus) also appear to switch between two search modes
[262].


## Distribution MSD over time per larva 

```{r mean-squared-distance over time distribution over larva , fig.show="hold",fig.cap=" Mean squared distance for paths of increasing duration.", out.width="50%", echo=FALSE, cache=FALSE}

##Get Distribution of MSD and Mean MSD for each time integration window 
##load Precalc Results
xbreaks = seq(0,210,10)
t <- as.character(vtimeWindows[9])
plotMSDVsTimePerLarva <- function(lModelwithMSD,addPlot=FALSE)
{
  
  lMSD <- list()
  vTimeWindow <- vector()
  for (i in 1:NROW(lModelwithMSD))
  {
    if (!is.null(lModelwithMSD[[i]]$meanMSDPerLarva))
    {
        lMSD[[i]] <- lModelwithMSD[[i]]$meanMSDPerLarva
        vTimeWindow[i] <-as.numeric( names(lModelwithMSD[i]) )
    }
  }
  ##Now plot MSD evolution of each larva
  datMeanMSDVsTimePerLarva <- data.frame(do.call(rbind,lMSD))
  ##Extract from Column Names the ID part only
  vExpIDS <- as.vector(lapply(  names(datMeanMSDVsTimePerLarva) ,FUN = function(s){  gsub(pattern = "[^0-9]", replacement = "", x = s) }))
  names(datMeanMSDVsTimePerLarva) <- vExpIDS ## Now replace Col names - so we can keep track of Which Larvae has each path
  ##Calculate The Hurst Coeffcient Indicating the type of diffussion each larva exectutes in the length duration of its path examined/available
  hurstCoeffPerLarvaPerT <- lapply(datMeanMSDVsTimePerLarva,FUN = function(s){0.5*log10(s)/log10(vTimeWindow) } )
  datHurstCoeff <- data.frame(do.call(cbind,hurstCoeffPerLarvaPerT))
  vExpIDS <- as.vector(lapply(  names(datHurstCoeff) ,FUN = function(s){  gsub(pattern = "[^0-9]", replacement = "", x = s) }))
  names(datHurstCoeff) <- vExpIDS ## Now replace Col names - so we can keep track of Which Larvae has each path

  if (!addPlot)
    plot(vTimeWindow,datMeanMSDVsTimePerLarva[,1],type="p",
         col=colourDataScheme[lModelwithMSD[[1]]$groupID][[1]],ylim=c(0,250),xlab="Time (sec)",ylab="MSD (mm)",xlim=c(0,max(vTimeWindow)))
  for (i in 1:ncol(datMeanMSDVsTimePerLarva))
    lines(vTimeWindow,datMeanMSDVsTimePerLarva[,i],type="p",col=colourDataScheme[lModelwithMSD[[1]]$groupID][[1]])
  
  ## plot Hurst Coeff for this Larva
  plot(vTimeWindow,datHurstCoeff[,1],type="p",
         col=colourDataScheme[lModelwithMSD[[1]]$groupID][[1]],ylim=c(0.1,3),xlab="Time (sec)",ylab="Hurst Coefficient (log(MSD)/log(duration))",xlim=c(0,max(vTimeWindow)),cex=0.5)
    for (i in 1:ncol(datHurstCoeff))
    lines(vTimeWindow,datHurstCoeff[,i],type="p",col=colourDataScheme[lModelwithMSD[[1]]$groupID][[1]])


  
} ##Plot Function 

plotMSDVsTimePerLarva(lMSDSummaryData[["NE"]],FALSE)
plotMSDVsTimePerLarva(lMSDSummaryData[["NL"]],FALSE)
title(main="NL MSD ")
plotMSDVsTimePerLarva(lMSDSummaryData[["LE"]],FALSE)
plotMSDVsTimePerLarva(lMSDSummaryData[["LL"]],FALSE)
title(main="LL MSD ")
plotMSDVsTimePerLarva(lMSDSummaryData[["DE"]],FALSE)
plotMSDVsTimePerLarva(lMSDSummaryData[["DL"]],FALSE)
title(main="DL MSD ")  
  #legend("topright", legend=names(colourDataScheme)[4:9],
  #       col=unlist(colourDataScheme[names(colourDataScheme)[4:9]]),
  #       pch=unlist(pointTypeScheme[names(colourDataScheme)[4:9]]) )

```

The mean of the mean squared displacement confirms the finding:  **Movement in absence and presence of prey differs between groups in manner that depends on experience **
Looking at group mean and pooled means essentially shows the same differences, only *group mean shows waves of LE leaving the recording area*.
I then examine the distribution of mean MSD among larvae and find that LE clearly advance to higher MSDs in spontaneous conditions.



### MSD to path-length for evidence of super-Diffusion - (Integrate time out)

Lets now look at how Mean squared distance increases with path length. 
The distance is measured over an arbitrary starting point chosen to be at some X sec in the past. 
We investigate this over a range of integration periods, from 2 to 10 .. T seconds
If the animals moved at constant velocity then path length could be a serrogate for time. Instead here we have regular bout movent, with pauses likely possible, and so the different integration times allow us to combine similar path-lengths, which took different times to develop, but nevertheless examine their diffusive properties through MSD, regardless of time.


<!--resulting plots show **evidence of superdiffusion **-->

```{r  mean-squared-distance over path-length , fig.show="hold", out.width="100%", echo=FALSE, cache=TRUE}
## iNvariance Principle Theoretical Mean Path Length
theoreticalMeanLength <- function(D,propFactor=1.5)
{
  A <- pi*( (D)^2)
  C <- 2*pi*(D)
  return(round(100*(propFactor* pi*A/C)) /100 )
}
##Integrate time out, and plot MSD per path-length
# ie legth to hit the boundary of the observation circle, is only proportional to the circle (in 2D), volume in 3D- 
process_MSDVsPathLengthData <- function(ldatDispersion,strGroupID,addPlot=FALSE)
{
  YLIM <- 200
  dispBreaks <- seq(1,40,2)
  vmeanPooledMSDPerPathOft  <- list()
  vsdPooledMSDPerPathOft    <- list()
  vcountPooledMSDPerPathOft <- list()
  message("Extracting ", strGroupID )

  datGroupDispersion <- ldatDispersion[ldatDispersion$groupID %in% strGroupID & 
                                                !is.na(ldatDispersion$Length) ,]
  if (NROW(datGroupDispersion) == 0)
  {
    warning("No path length data for ", strGroupID)
    return(list(muMSDPerT=NA,sdPooledMSDPerT=NA,N=NA,breaks=NA))
  }

  datGroupDispersion$dispRange <- cut(datGroupDispersion[datGroupDispersion$groupID %in% strGroupID ,"Length" ],breaks=dispBreaks)
  
  vmeanPooledMSDPerPathOft  <- tapply(datGroupDispersion$DisplacementSq,datGroupDispersion$dispRange, mean,na.rm=TRUE)
  vcountPooledMSDPerPathOft <- tapply(datGroupDispersion$DisplacementSq,datGroupDispersion$dispRange, NROW)
  vsdPooledMSDPerPathOft    <- tapply(datGroupDispersion$DisplacementSq,datGroupDispersion$dispRange, sd,na.rm=TRUE)
  names(dispBreaks)=names(vmeanPooledMSDPerPathOft)
  #boxplot(datGroupDispersion$Length~datGroupDispersion$dispRange,main=strTitle,col=colourDataScheme[[strGroupID]],ylim=c(0,35))
  return(list(muMSDPerT=vmeanPooledMSDPerPathOft,sdPooledMSDPerT=vsdPooledMSDPerPathOft,N=vcountPooledMSDPerPathOft,breaks=dispBreaks[1:length(vmeanPooledMSDPerPathOft)]  ) )
}

plot_MSDPerPathLengthSummary <- function(lMSDPathLStat)
{
  
    strTitle <- paste("mean MSD per path length", strGroupID,"#")

  if (!addPlot)
  {
    plot(seq(1,max(dispBreaks),length.out = NROW(vmeanPooledMSDPerPathOverAllt)),
         vmeanPooledMSDPerPathOverAllt,pch=pointTypeScheme[[strGroupID]],main=strTitle,xlab="Path Length (mm)",
         ylim=c(0,YLIM),xlim=c(0,max(dispBreaks)),col=colourDataScheme[[strGroupID]],cex=0.7 )
  }else
  {
    points(seq(1,max(dispBreaks),length.out = NROW(vmeanPooledMSDPerPathOverAllt)),
         vmeanPooledMSDPerPathOverAllt,pch=16,main=strTitle,xlab="Path Length (mm)",
         col=colourDataScheme[[strGroupID]],cex=0.7 )
    lines(seq(1,max(dispBreaks),length.out = NROW(vmeanPooledMSDPerPathOverAllt)),
         vmeanPooledMSDPerPathOverAllt,lwd=1,lty=lineTypeScheme[[strGroupID]])
  }
  
  if (!addPlot)
  {
    propFactor <- 1.0
    rpoints <- seq(0.5,max(dispBreaks), length.out = NROW(vmeanPooledMSDPerPathOverAllt) )
    points(rpoints,theoreticalMeanLength(rpoints,propFactor ),pch=2,cex=0.8 ) #Low Lim
    points(seq(2,max(dispBreaks),1),theoreticalMeanLength(seq(2,max(dispBreaks),1),propFactor ),pch=2,cex=0.5 ) #Up Lim
    points(seq(1,max(dispBreaks),1),theoreticalMeanLength(seq(1,max(dispBreaks),1),propFactor ),pch=2,cex=0.5 ) #Up Lim
    legend("topleft",pch=c(16,2),legend=c("Data","Theory"),col=c(colourDataScheme[[strGroupID]],"black") )
  }
  
}

#pdf(file= paste(strPlotExportPath,"/foraging/plot_meanPathLengthPerMSD.pdf",sep=""),width=7,height=7)
## bottom, left,top, right
#par(mar = c(4.3,4.3,2,1))
makeMSDPathLengthSummary <- function ()
{
  #vtimeWindows <- vsmallTimeWindows #c(1,2,10) #
  ##Load All
  baddPlot <- FALSE
  lMSDStat <- list()
  datmeanPooledMSDPerPathOft <- data.frame()
  ## Loop to sequantially load and process Dispersion data across time scales - freeing memory before re-allocating
  for (strG in vGroups)
  {
    lMSDStat[[strG]] <- list()  
    
    for (t in vtimeWindows)
    { 
      
      rm(ldatDispersion)   #Clear Mem
      ldatDispersion<- list()
      print (t)
      ##Load MSD /Dispersion/ Path Data
      ldatDispersion[[as.character(t)]]<- loadDispersionData(TRUE,t) #readRDS(file=paste0(strDataExportDir,"/foragingState_Dispersion",t,"sec.rds") ) 
      
      lMSDStat[[strG]][[as.character(t)]] <- process_MSDVsPathLengthData(ldatDispersion[[as.character(t)]],strG)
      
      #plotMSDPerIntegrationTime(ldatDispersion,"NE",lLinModel)
    
      datNewTable <- data.frame(do.call(cbind, lMSDStat[[strG]][[as.character(t)]] ))
      datNewTable$T <- as.character(t)
      datNewTable$groupID <- strG
      datmeanPooledMSDPerPathOft <- rbind(datmeanPooledMSDPerPathOft, datNewTable ) 
      #vmeanPooledMSDPerPathOverAllt <- colMeans(datmeanPooledMSDPerPathOft,na.rm=TRUE)
      #vmeanPooledMSDPerPathOverAllt <- as.matrix(vmeanPooledMSDPerPathOverAllt[names(vmeanPooledMSDPerPathOverAllt)]) #Convert to Vector 
      #vmeansdPooledMSDPerPathOverAllt <- as.matrix(colMeans(do.call(rbind,vsdPooledMSDPerPathOft),na.rm=TRUE))
      #vcountPooledMSDPerPathOverAllt <- as.matrix(colSums(do.call(rbind,vcountPooledMSDPerPathOft),na.rm=TRUE))
    }
  }
  
  saveRDS(lMSDStat,paste0(strDataExportDir,"lMSDPerPathLength2mmSummaryResults",min(vtimeWindows),"-",max(vtimeWindows),"sec.rds"))
  saveRDS(datmeanPooledMSDPerPathOft,paste0(strDataExportDir,"datMSDPerPathLength2mmSummaryResults",min(vtimeWindows),"-",max(vtimeWindows),"sec.rds"))
  return(datmeanPooledMSDPerPathOft)
}

vtimeWindows <- getAvailablePathTimewindows()
##Try To load Precalc Results
try(
{
  rm(lMSDStat);
  datMSDVsPathlengthSummaryData <<- readRDS(paste0(strDataExportDir,"datMSDPerPathLength2mmSummaryResults",min(vtimeWindows),"-",max(vtimeWindows),"sec.rds"));
 lMSDStat <<- readRDS(paste0(strDataExportDir,"lMSDPerPathLength2mmSummaryResults",min(vtimeWindows),"-",max(vtimeWindows),"sec.rds"))
}
)
if (!exists("lMSDStat"))
{
  datMSDVsPathlengthSummaryData <<- makeMSDPathLengthSummary()
}

lMSDStat <<- readRDS(paste0(strDataExportDir,"lMSDPerPathLength2mmSummaryResults",min(vtimeWindows),"-",max(vtimeWindows),"sec.rds"))
  
# PLOT Summary per Path Range - Mean MSD Per Path Length over all T
baddPlot <- FALSE
datmeanPooledMSDPerPathOft <- list()
for (strG in vGroups)
{
  datmeanPooledMSDPerPathOft[[strG]] <-tapply(datMSDVsPathlengthSummaryData[datMSDVsPathlengthSummaryData$groupID == strG,"muMSDPerT"] , datMSDVsPathlengthSummaryData[datMSDVsPathlengthSummaryData$groupID == strG,"breaks"],mean,na.rm=TRUE)
  xtick <- unique(datMSDVsPathlengthSummaryData[datMSDVsPathlengthSummaryData$groupID == strG,"breaks"]) 
  xtick <- xtick[!is.na(xtick)]
  if (!baddPlot)
  {
    plot(xtick, (datmeanPooledMSDPerPathOft[[strG]]),col=colourDataScheme[[strG]],pch=pointTypeScheme[[strG]],lty=lineTypeScheme[[strG]],type="b",
         xlab="Path length (mm)",ylab=" Mean Squared Displacement (mm)",xaxt="n" ,ylim=c(0.2,250))
  
    axis(side=1, at=xtick, labels = names(lMSDStat[[strG]]$`2`$breaks))
    #axis(side=2, at=(axisTicks(c(0.3,2),log=TRUE,nint=5)), labels = axisTicks(c(0.3,2),log=TRUE,nint=5) )  
  }
  else
    points(xtick,(datmeanPooledMSDPerPathOft[[strG]]),col=colourDataScheme[[strG]],pch=pointTypeScheme[[strG]],lty=lineTypeScheme[[strG]],type="b" )
  
  baddPlot <- TRUE
}
  ##Add Theoretical MSD growth vs Time
  propFactor <- 2.0
  lines(xtick ,(theoreticalMeanLength(xtick+0.0,propFactor )),pch=18,cex=0.5,type="b" ) #Up Lim

  legend("topleft", legend=c(names(colourDataScheme)[4:9],"Linear"),
         col=c(unlist(colourDataScheme[names(colourDataScheme)[4:9]]),"black" ),
         pch=c( unlist(pointTypeScheme[names(colourDataScheme)[4:9]]),18 ) )



```

Findings:
  1. Spontaneous MSD grows faster than Evoked
  2. Evoked MSDs look very similar between groups
  2. Over small path lengths there is signs of a Non-linear MSD regime, which suggests super-diffusion

Compared to the linear Dispersion to mean-path length relationship (#path-length per dispersion), the MSD to path-length appears to be non-linear.

## MSD While crossing fixed circular Domains

I plot the cdf of MSD for paths crossing a circular domain of a fixed radius $R$ located in the centre of the ROI, and compare groups between conditions. 

```{r MSD-cdf , fig.show="hold", out.width="33%", echo=FALSE, cache=FALSE}


cdfplot_pathDisplacementCrossingDomain <- function(DomainRadius)
{
    lBoundedTrackInfo <- readRDS(file=paste0(strDataExportDir,"/stat_boundedPathsB_R",DomainRadius,"mm.rds") )
    # 
    dRad <- DomainRadius #head(unlist(lBoundedTrackInfo[[strG]]$DomainRadius),1 )
    strG<- "LL"
    plot(ecdf(sqrt(unlist(lBoundedTrackInfo[[strG]]$SqDisplacement) ) ), col=colourDataScheme[[strG]], pch=pointTypeScheme[[strG]], lty=lineTypeScheme[[strG]], main=paste("LF CDF MSD vs duration crossing domain R",dRad),xlab="Displacement (mm)")
    strG<- "LE"
    lines(ecdf(sqrt(unlist(lBoundedTrackInfo[[strG]]$SqDisplacement)) ), col=colourDataScheme[[strG]], pch=pointTypeScheme[[strG]], lty=lineTypeScheme[[strG]])
    
    strG<- "NL"
    plot(ecdf(sqrt(unlist(lBoundedTrackInfo[[strG]]$SqDisplacement)) ), col=colourDataScheme[[strG]], pch=pointTypeScheme[[strG]], lty=lineTypeScheme[[strG]],main=paste("NF CDF MSD vs duration crossing domain R",dRad),xlab="Displacement  (mm)")
    strG<- "NE"
    lines(ecdf(sqrt(unlist(lBoundedTrackInfo[[strG]]$SqDisplacement)) ), col=colourDataScheme[[strG]], pch=pointTypeScheme[[strG]], lty=lineTypeScheme[[strG]])
    strG<- "DL"
    plot(ecdf(sqrt(unlist(lBoundedTrackInfo[[strG]]$SqDisplacement)) ), col=colourDataScheme[[strG]], pch=pointTypeScheme[[strG]], lty=lineTypeScheme[[strG]],main=paste("DF CDF MSD vs duration crossing domain R",dRad),xlab="Displacement  (mm)")
    strG<- "DE"
    lines(ecdf(sqrt(unlist(lBoundedTrackInfo[[strG]]$SqDisplacement)) ), col=colourDataScheme[[strG]], pch=pointTypeScheme[[strG]], lty=lineTypeScheme[[strG]])
}

cdfplot_pathDisplacementCrossingDomain(2)
cdfplot_pathDisplacementCrossingDomain(4)
cdfplot_pathDisplacementCrossingDomain(8)
cdfplot_pathDisplacementCrossingDomain(10)

hist(lBoundedTrackInfo$LL$duration )
```

Evoked conditions are more heavily tailed towards shorter displacements.
Also it appears that the difference between conditions in NF is stronger, indicating that displacements increase strongly in the absence of prey, as NF seems to sway towards lower displacement in evoked conditions, than others, which could indicate a propensity to stay in region of prey. 
Because DF and LF show almost identical MSD behaviours, the NF behaviour could interpreted  to be a result of increased risk taking in the presence of prey in response to prior experience of lack of food or due to immediate hunger(although each larva
has settled with food for 1 hour).

**Note Shorter MSDs in this context indicate that larvae exit the Domain over a shorter chord**, ie without crossing the diameter which is the maximum available displacement (padded by 0.5mm for boundary crossing detection).
This may be indicative of more tortuous paths, higher turn rates etc.

But results are not scale-free, they depend on the domain radius:

  -  R=10mm I find that evoked-spontaneous differences are minimized for DF, LF, these still exist for NF
  -  R=9mm *NF* show the strongest responses, with *shorter MSD in evoked*, and longer in spontaneous. *ie. propensity for shorter free paths in presence of prey*
  -  R=5, again NF stand out with evoked having shorter overall displacement
  -  R=4 *Surprise:* LF shows the largest E-S difference and skew towards longer MSD, while DF no difference, 
  -  R=2, the same MSD is NF clearly distinct between E-Spont, but not in DF, LF 
  -  R=1 NF maintains the E-Spont. Difference! but none of the controls do.

## Dispersion Vs MSD

I obtained similar results when looking at MSD and Dispersion over time. These have obvious links, but is their relationship linear?
There is a linear relationship of Dispersion against path-length, but this is supralinear for MSD vs path-length, so perhaps they are not linearly related. 


```{r  mean-squared-distance over Dispersion , fig.show="hold",fig.cap="Non-Linear relationship between dispersal and MSD, is likely evidence of superdiffussion (Disp. is linear to <Path-length>", out.width="100%", echo=FALSE, cache=TRUE, results=FALSE}
## iNvariance Principle Theoretical Mean Path Length
theoreticalMeanLength <- function(D,propFactor=1.5)
{
  A <- pi*( (D)^2)
  C <- 2*pi*(D)
  return(round(100*(propFactor* pi*A/C)) /100 )
}
##Integrate time out, and plot MSD per Dispersion size
# ie legth to hit the boundary of the observation circle, is only proportional to the circle (in 2D), volume in 3D- 
process_MSDVsDispersion <- function(ldatDispersion,strGroupID,addPlot=FALSE)
{
  YLIM <- 200
  dispBreaks <- seq(1,13,0.5)
  vmeanPooledMSDPerPathOft  <- list()
  vsdPooledMSDPerPathOft    <- list()
  vcountPooledMSDPerPathOft <- list()
  message("Extracting ", strGroupID )

  datGroupDispersion <- ldatDispersion[ldatDispersion$groupID %in% strGroupID & 
                                                !is.na(ldatDispersion$Dispersion) ,]
  if (NROW(datGroupDispersion) == 0)
  {
    warning("No Dispersion path data for ", strGroupID)
    return(list(muMSDPerT=NA,sdPooledMSDPerT=NA,N=NA,breaks=NA))
  }

  datGroupDispersion$dispRange <- cut(datGroupDispersion[datGroupDispersion$groupID %in% strGroupID ,"Dispersion" ],breaks=dispBreaks)
  
  vmeanPooledMSDPerPathOft  <- tapply(datGroupDispersion$DisplacementSq,datGroupDispersion$dispRange, mean,na.rm=TRUE)
  vcountPooledMSDPerPathOft <- tapply(datGroupDispersion$DisplacementSq,datGroupDispersion$dispRange, NROW)
  vsdPooledMSDPerPathOft    <- tapply(datGroupDispersion$DisplacementSq,datGroupDispersion$dispRange, sd,na.rm=TRUE)
  names(dispBreaks)=names(vmeanPooledMSDPerPathOft)
  #boxplot(datGroupDispersion$Length~datGroupDispersion$dispRange,main=strTitle,col=colourDataScheme[[strGroupID]],ylim=c(0,35))
  return(list(muMSDPerT=vmeanPooledMSDPerPathOft,sdPooledMSDPerT=vsdPooledMSDPerPathOft,N=vcountPooledMSDPerPathOft,breaks=dispBreaks[1:length(vmeanPooledMSDPerPathOft)]  ) )
}

plot_MSDPerDispersionSummary <- function(lMSDPathLStat)
{
  
    strTitle <- paste("mean MSD per Dispersion size", strGroupID,"#")

  if (!addPlot)
  {
    plot(seq(1,max(dispBreaks),length.out = NROW(vmeanPooledMSDPerPathOverAllt)),
         vmeanPooledMSDPerPathOverAllt,pch=pointTypeScheme[[strGroupID]],main=strTitle,xlab="Dispersion size (mm)",
         ylim=c(0,YLIM),xlim=c(0,max(dispBreaks)),col=colourDataScheme[[strGroupID]],cex=0.7 )
  }else
  {
    points(seq(1,max(dispBreaks),length.out = NROW(vmeanPooledMSDPerPathOverAllt)),
         vmeanPooledMSDPerPathOverAllt,pch=16,main=strTitle,xlab="Dispersion size (mm)",
         col=colourDataScheme[[strGroupID]],cex=0.7 )
    lines(seq(1,max(dispBreaks),length.out = NROW(vmeanPooledMSDPerPathOverAllt)),
         vmeanPooledMSDPerPathOverAllt,lwd=1,lty=lineTypeScheme[[strGroupID]])
  }
  
  if (!addPlot)
  {
    propFactor <- 1.0
    rpoints <- seq(0.5,max(dispBreaks), length.out = NROW(vmeanPooledMSDPerPathOverAllt) )
    points(rpoints,theoreticalMeanLength(rpoints,propFactor ),pch=2,cex=0.8 ) #Low Lim
    points(seq(2,max(dispBreaks),1),theoreticalMeanLength(seq(2,max(dispBreaks),1),propFactor ),pch=2,cex=0.5 ) #Up Lim
    points(seq(1,max(dispBreaks),1),theoreticalMeanLength(seq(1,max(dispBreaks),1),propFactor ),pch=2,cex=0.5 ) #Up Lim
    legend("topleft",pch=c(16,2),legend=c("Data","Linear"),col=c(colourDataScheme[[strGroupID]],"black") )
  }
  
}

#pdf(file= paste(strPlotExportPath,"/foraging/plot_meanPathLengthPerMSD.pdf",sep=""),width=7,height=7)
## bottom, left,top, right
#par(mar = c(4.3,4.3,2,1))
makeMSDDispersionSummary <- function ()
{
    ##Load All
  baddPlot <- FALSE
  lMSDStat <- list()
  datmeanPooledMSDPerPathOft <- data.frame()
  ## Loop to sequantially load and process Dispersion data across time scales - freeing memory before re-allocating
  for (strG in vGroups)
  {
    lMSDStat[[strG]] <- list()  
    
    for (t in vtimeWindows)
    { 
      
      rm(ldatDispersion)   #Clear Mem
      ldatDispersion<- list()
      print (t)
      ##Load MSD /Dispersion/ Path Data
      ldatDispersion[[as.character(t)]]<- loadDispersionData(T,t) #readRDS(file=paste0(str,"/foragingState_Dispersion",t,"sec.rds") ) 
      
      lMSDStat[[strG]][[as.character(t)]] <- process_MSDVsDispersion(ldatDispersion[[as.character(t)]],strG)
      
      #plotMSDPerIntegrationTime(ldatDispersion,"NE",lLinModel)
    
      datNewTable <- data.frame(do.call(cbind, lMSDStat[[strG]][[as.character(t)]] ))
      datNewTable$T <- as.character(t)
      datNewTable$groupID <- strG
      datmeanPooledMSDPerPathOft <- rbind(datmeanPooledMSDPerPathOft, datNewTable ) 
      #vmeanPooledMSDPerPathOverAllt <- colMeans(datmeanPooledMSDPerPathOft,na.rm=TRUE)
      #vmeanPooledMSDPerPathOverAllt <- as.matrix(vmeanPooledMSDPerPathOverAllt[names(vmeanPooledMSDPerPathOverAllt)]) #Convert to Vector 
      #vmeansdPooledMSDPerPathOverAllt <- as.matrix(colMeans(do.call(rbind,vsdPooledMSDPerPathOft),na.rm=TRUE))
      #vcountPooledMSDPerPathOverAllt <- as.matrix(colSums(do.call(rbind,vcountPooledMSDPerPathOft),na.rm=TRUE))
    }
  }
  
  saveRDS(lMSDStat,paste0(strDataExportDir,"lMSDPerDispersion05mmSummaryResults",min(vtimeWindows),"-",max(vtimeWindows),"sec.rds"))
  saveRDS(datmeanPooledMSDPerPathOft,paste0(strDataExportDir,"datMSDPerDispersion05mmSummaryResults",min(vtimeWindows),"-",max(vtimeWindows),"sec.rds"))
  return(datmeanPooledMSDPerPathOft)
}


##Try To load Precalc Results
try(
  {
    rm(lMSDDispersionStat)
    datMSDVsDispersionSummaryData <<- readRDS(paste0(strDataExportDir,"datMSDPerDispersion05mmSummaryResults",min(vtimeWindows),"-",max(vtimeWindows),"sec.rds"));
    lMSDDispersionStat <<- readRDS(paste0(strDataExportDir,"lMSDPerDispersion05mmSummaryResults",min(vtimeWindows),"-",max(vtimeWindows),"sec.rds"))
  }
)
if (!exists("lMSDDispersionStat"))
{
  datMSDVsDispersionSummaryData <<- makeMSDDispersionSummary()
}

lMSDDispersionStat <<- readRDS(paste0(strDataExportDir,"lMSDPerDispersion05mmSummaryResults",min(vtimeWindows),"-",max(vtimeWindows),"sec.rds"))
  
# PLOT Summary per Path Range - Mean MSD Per Path Length over all T
baddPlot <- FALSE
datmeanPooledMSDPerDispersionOft <- list()
for (strG in vGroups)
{
  datmeanPooledMSDPerDispersionOft[[strG]] <- tapply(datMSDVsDispersionSummaryData[datMSDVsDispersionSummaryData$groupID == strG,"muMSDPerT"] , datMSDVsDispersionSummaryData[datMSDVsDispersionSummaryData$groupID == strG,"breaks"],mean,na.rm=TRUE)
  
  datmeanPooledMeanDisplacementPerDispersionOft <- sqrt(datmeanPooledMSDPerDispersionOft[[strG]])
  xtick <- unique(datMSDVsDispersionSummaryData[datMSDVsDispersionSummaryData$groupID == strG,"breaks"]) 
  xtick <- xtick[!is.na(xtick)]
  if (!baddPlot)
  {
    plot(xtick, (datmeanPooledMeanDisplacementPerDispersionOft),col=colourDataScheme[[strG]],pch=pointTypeScheme[[strG]],lty=lineTypeScheme[[strG]],type="b",
         xlab="Dispersion size (mm)",ylab=" Mean Displacement (mm)",xaxt="n" ,ylim=c(2,20),log="xy")
  
    axis(side=1, at=xtick, labels = names(lMSDDispersionStat[[strG]]$`2`$breaks))
    #axis(side=2, at=(axisTicks(c(0.3,2),log=TRUE,nint=5)), labels = axisTicks(c(0.3,2),log=TRUE,nint=5) )  
  }
  else
    points(xtick,(datmeanPooledMeanDisplacementPerDispersionOft),col=colourDataScheme[[strG]],pch=pointTypeScheme[[strG]],lty=lineTypeScheme[[strG]],type="b" )
  
  baddPlot <- TRUE
}
  ##Add Theoretical MSD growth vs Time
  propFactor <- 1.0
  lines(xtick ,(theoreticalMeanLength(xtick+0.5,propFactor )),pch=18,cex=0.5,type="b" ) #Up Lim

  legend("bottomright", legend=c(names(colourDataScheme)[4:9],"Linear "),
         col=c(unlist(colourDataScheme[names(colourDataScheme)[4:9]]),"black" ),
         pch=c( unlist(pointTypeScheme[names(colourDataScheme)[4:9]]),18 ) )



```

I find that a the principle of invariance holds between dispersion and Mean Displacement (calculated as $\sqrt{MSD}$  ) that appears almost consistent across groups.
Thus  not only are Dispersion and mean Path length near linearly related, but so is mean displacement, albeit some differences between conditions appear to exist,
*In the absence of prey, mean displacement is likely higher within dispersion sizes of 3-8mm*.

Note, the reason why  mean displacement be larger to dispersion is because dispersion is the *radius containing the path*, and thus the largest mean displacement can only be less or equal to the the diameter, twice the dispersion size.



# Statistical comparison of motion-trajectories 
<!--Clustering Code Separated into a sub RMarkdown-->
```{r statistical Model-fitting, child='ForagingStateAnalysis_ModelFitting.Rmd',eval=FALSE}
```
  

# Identifying states of foraging behaviour

```{r Clustering-Dispersion, child = 'ForagingStateAnalysis_Clustering.Rmd',eval=FALSE}
```


# Hunt initiation and foraging state

```{r Analysis of Hunt Events, child = 'ForagingStateAnalysis_HuntEvents.Rmd',eval=FALSE}
```


<!--

### Model implementantion in Stan

To implement the normal mixture model outlined in the previous section in Stan, the discrete parameters can be summed out of the model.
If Y is a mixture of K normal distributions with locations μk and scales σk with mixing proportions λ in the unit K-simplex, then 
\[p_Y\left(y \mid \lambda, \mu, \sigma \right) = \sum_{k=1}^K \lambda_k \, \textsf{normal}\left(y \mid \mu_k, \sigma_k\right).\]
I will defer using Stan for this and go for my familiar Jags model implementation.
-->
# Analysis Trajectory micro-structure explains macro movements.

## Bout-detection and turns

To reveal how the macroscopic observations within the domain-constrained paths arise, I take each domain size (R=1...11mm) and analyze paths into bout sequences, measuring the angle change, distance traveled (straight line from start-end of bout), and the path lenght inscribed during the bout. 
I am looking to see if free path-lengths,  turn-frequency or magnitudes can explain why LE leave the domains quicker than naive larvae.

```{r  extract bout and turn structure from domain paths,eval=FALSE,out.width="100%", echo=FALSE, cache=TRUE, results=FALSE}

  #library(signal)
  #require(Rwave) 
  library (plyr) #Split list, apply function #Thanks to https://stackoverflow.com/questions/4227223/convert-a-list-to-a-data-frame
  source("HuntEpisodeAnalysis/HuntEpisodeAnalysis_lib.r")
  
  MIN_BOUT_TURN_SPEED = 0.2
  G_THRES_MOTION_BOUT_SPEED = 0.2
  MIN_PATH_LENGTH     = 0.5 ##Also Set  in Previous Chunk
  MIN_TURN_SIZE_THRES = 6 #Degrees - Reject As Non Turns If Overall Turn is less than 6 degrees
  MIN_GAP_FRAMES_BETWEEN_TURNS = 50

########## BOUT DETECTION #################
getTrajectoryTurnsAndRuns<- function(TrackLetInfo)  
{
  ## Some rare and Bizarre Dublication Exist where exp,event, trackID & frame are the same 
  datDomainTrajectory <- datAllFrames[datAllFrames$expID == as.numeric(TrackLetInfo$expID) &
                                      datAllFrames$eventID == as.numeric(TrackLetInfo$EventID) &
                                      datAllFrames$frameN >= as.numeric(TrackLetInfo$startFrame) &
                                      datAllFrames$frameN <= as.numeric(TrackLetInfo$endFrame) & 
                                      datAllFrames$posX != 0,  ]
  
  if (length(unique(datDomainTrajectory$trackletID)) > 1)
  {
    warning("*Dublicate track with same Exp, Event and frame range found for TrackletUID:",TrackLetInfo$TrackletUID, ". Selecting longest track for analysis")

    tbl_trackSize<-table(datDomainTrajectory$trackletID)
    maxTrackletID <- names(which(tbl_trackSize ==max(tbl_trackSize)))
    datDomainTrajectory <- datDomainTrajectory[datDomainTrajectory$trackletID == maxTrackletID,]
  }
  ##Get TAIL Tip motion
  #vTailDisp <-  datDomainTrajectory$DThetaSpine_6 + datDomainTrajectory$DThetaSpine_7 #+ datRenderHuntEvent$DThetaSpine_7
  #vTailDisp <- filtfilt(bf_tailClass, clipEyeRange(vTailDisp,-120,120))
  #vTailDispFilt <- filtfilt(bf_tailClass2,abs( vTailDisp) )  ##Heavily Filtered and Used For Classifying Bouts
 
 #### PROCESS BOUTS ###
  vDeltaXFrames        <- diff(datDomainTrajectory$posX,lag=1,differences=1)
  vDeltaYFrames        <- diff(datDomainTrajectory$posY,lag=1,differences=1)
  vDeltaDisplacement   <- sqrt(vDeltaXFrames^2+vDeltaYFrames^2) ## Path Length Calculated As Total Displacement
  
  dframe               <- diff(datDomainTrajectory$frameN,lag=1,differences=1)
  dframe               <- dframe[dframe > 0] ##Clear Any possible Nan - and Convert To Time sec  
  
  vEventSpeed          <- meanf(vDeltaDisplacement/dframe,5) ##IN (mm) Divide Displacement By TimeFrame to get Instantentous Speed, Apply Mean Filter Smooth Out 
  ##Replace NA with 0s
  vEventSpeed[is.na(vEventSpeed)] = 0
  vEventSpeed_smooth <- filtfilt(bf_speed, vEventSpeed) #meanf(vEventSpeed,100) #
  vEventSpeed_smooth[vEventSpeed_smooth < 0] <- 0 ## Remove -Ve Values As an artefact of Filtering
  vEventSpeed_smooth[is.na(vEventSpeed_smooth)] = 0
  
  
  vDeltaBodyAngle      <- diffPolar(datDomainTrajectory$BodyAngle) 
  vTurnSpeed           <- meanf(vDeltaBodyAngle[1:NROW(dframe)]/dframe,5)
  vAngleDisplacement   <- cumsum(vDeltaBodyAngle)
  vPathLength_mm       <- cumsum(vEventSpeed_smooth)*DIM_MMPERPX
  
  vTurnSpeed[is.na(vTurnSpeed)] <- 0
  vTurnSpeed <- filtfilt(bf_speed, vTurnSpeed)

  
  TurnboutsIdx <- NA
  MoveboutsIdx <- NA
  TailboutsIdx <- NA
  
  
  ## Do Wavelet analysis Of Tail End-Edge Motion Displacements - 
  # Returns List Structure will all Relevant Data including Fq Mode Per Time Unit
  #lwlt <- getPowerSpectrumInTime(vTailDisp,Fs)
  ## Let All non Turns Be Moves
  MoveboutsIdx <- detectMotionBouts(vEventSpeed_smooth,G_THRES_MOTION_BOUT_SPEED) # +min()
  #TailboutsIdx <- detectTailBouts(lwlt$freqMode)
  
  ##Note that sensitivity of this Determines detection of 1st turn to Prey
  datTrackletBout <- detectMotionBoutsV2(vTurnSpeed+vEventSpeed_smooth,MIN_BOUT_TURN_SPEED,MIN_GAP_FRAMES_BETWEEN_TURNS)  ##detectTurnBouts(vTurnSpeed,lwlt$freqMode,MIN_BOUT_TURN_SPEED)
  datTrackletBout$boutStartFrame <- datTrackletBout$boutStartFrame + as.numeric(TrackLetInfo$startFrame)
  datTrackletBout$boutEndFrame <- datTrackletBout$boutEndFrame + as.numeric(TrackLetInfo$startFrame)
 
  
  ## Filter Turns Filling in The Gap Frames  And Correct Frame Indicators for turns
  datDomainTrajectory$BoutFlag <- 0
  for (tID in as.character(datTrackletBout$boutID) )
  {
      datDomainTrajectory[datDomainTrajectory$frameN >= datTrackletBout[tID,]$boutStartFrame &
                       datDomainTrajectory$frameN <= datTrackletBout[tID,]$boutEndFrame,"BoutFlag"] = as.numeric(tID)
      #datDomainTrajectory[TurnboutsIdx,"IndTurnBout"]  = as.numeric(tID)
     #plot(vAngleDisplacement[datTrackletTurns[tID,]$turnStartFrame:datTrackletTurns[tID,]$turnEndFrame] - as.numeric(TrackLetInfo$startFrame)  )
  }
  ##Refresh Vector of Detected Turn Idx to reflect Filtered List
  boutsIdx <- which(datDomainTrajectory$BoutFlag > 0)

  ##Now Pass Though All Frames And Add Bout ID -(So we Include Non Bout Frames too )
  blockBoutFramesIDs <- split(datDomainTrajectory$frameN, 
                                       ##Sum Increments When the following Indicators Of Changing Class Become TRUE (I added Track Splitters when Exp or Event Change)
                                 cumsum(c(1, diff(datDomainTrajectory$BoutFlag) != 0 )  ) 
                                )
  datBoutBlockIds <- ldply (blockBoutFramesIDs, data.frame)
  ##Here Extract The Turn and Displacement of All Motion Bouts,  as classified by changes in Turn or Motion speed -
#  datMoveIds <- ldply (blockMotionBoutFramesIDs, data.frame)
  names(datBoutBlockIds) <- c("boutID","frameN")
  boutStartFrame <- tapply(datBoutBlockIds$frameN,datBoutBlockIds$boutID,min)
  boutStartIdx <- sapply((boutStartFrame) - as.numeric(TrackLetInfo$startFrame),max,1)  ##Fix Range TO Start from Idx 1
  boutStartIdx <- sapply((boutStartIdx),min,length(vPathLength_mm))  ##Fix Range TO Start from Idx 1
  
  boutEndFrame <- tapply(datBoutBlockIds$frameN,datBoutBlockIds$boutID,max)
  boutEndIdx <- sapply((boutEndFrame) - as.numeric(TrackLetInfo$startFrame),max,1)  ##Fix Range TO Start form 1
  boutEndIdx <- sapply((boutEndIdx),min,length(vPathLength_mm))  ##Fix Range TO Start from Idx 1
  
  turn_deg <- vAngleDisplacement[(boutEndIdx) ] - vAngleDisplacement[(boutStartIdx) ]
  pathLength_mm <- vPathLength_mm[(boutEndIdx) ] - vPathLength_mm[(boutStartIdx)]
  duration_sec <- (boutEndFrame - boutStartFrame)/head(datDomainTrajectory$fps,1)
  vDeltaXFrames = vDeltaYFrames  <- vector()
  for (i in 1:NROW(boutEndFrame))
  {##Re Adjust To FrameN from IDx increment +1 above
    if (boutEndFrame[i] > boutStartFrame[i])
    {
      vDeltaXFrames[i] <- datDomainTrajectory[datDomainTrajectory$frameN == (boutEndFrame[i]),]$posX - datDomainTrajectory[datDomainTrajectory$frameN == (boutStartFrame[i]),]$posX
      vDeltaYFrames[i] <- datDomainTrajectory[datDomainTrajectory$frameN == (boutEndFrame[i]),]$posY - datDomainTrajectory[datDomainTrajectory$frameN == (boutStartFrame[i]),]$posY      }else{
        vDeltaXFrames[i] = vDeltaYFrames[i] = 0
      }
  }
  travelDistance_mm   <- sqrt(vDeltaXFrames^2+vDeltaYFrames^2)*DIM_MMPERPX ## Path Length Calculated As Total Displacement
  

  if (length(datBoutBlockIds) == 1 )
  { pathLength_mm <- 0
    turn_deg <- 0 #There were No Turns detected but 1 frame- Handle Exception
    travelDistance_mm <- 0
  }

  datTrackletBouts <- data.frame(boutID=names(boutEndFrame),boutStartFrame,boutEndFrame,duration_sec,travelDistance_mm=travelDistance_mm,pathLength_mm,turn_deg,stringsAsFactors=FALSE)
  datTrackletBouts <- datTrackletBouts[!is.na(datTrackletBouts$travelDistance_mm), ]
  ##Set to correct order
  orderSeq <- order(as.numeric(as.character(datTrackletBouts$boutID)) )
  datTrackletBouts <- datTrackletBouts[orderSeq,]
  ##Add Bout Sequence IDs and Non Bout IDs (=0) - So we can determine Pauses from Movements
  rleBoutSequence <- rle(datDomainTrajectory$BoutFlag)
  datTrackletBouts <- cbind(datTrackletBouts,boutSeqID=rleBoutSequence$values,boutFrames=rleBoutSequence$lengths)
  
  ### PLOT Trajectory Results ##
  #plot(datDomainTrajectory$posX,datDomainTrajectory$posY,
  #     col=c("black","red")[(datDomainTrajectory$BoutFlag>0)+1],
  #     pch =c(9,25,3)[(datDomainTrajectory$BoutFlag>0)+1],
  #     cex=c(1,1)[(datDomainTrajectory$BoutFlag>0)+1] )  
  
  ## Turn  Speed Class
  #plot(as.numeric(TrackLetInfo$startFrame)+1:length(vTurnSpeed), vTurnSpeed,type="l")
  #points(TurnboutsIdx+as.numeric(TrackLetInfo$startFrame),vTurnSpeed[TurnboutsIdx],col="red")

  ## Motion Speed Class
  #plot(as.numeric(TrackLetInfo$startFrame)+1:length(vEventSpeed), vEventSpeed,type="l")
  #points(boutsIdx+as.numeric(TrackLetInfo$startFrame),vEventSpeed[ boutsIdx],col="red")
  
  ### PLOT Trajectory Results ##
  #plot(datDomainTrajectory$posX,datDomainTrajectory$posY, col=c("black"),      pch =c(20),       cex=c(1) )  
  #points(datDomainTrajectory[boutsIdx,]$posX,datDomainTrajectory[boutsIdx,]$posY,       col=c("red"),       pch =c(20),       cex=c(1) )  

  ##Add The Frame Duration of Each Mode -Run-Length Encoding (RLE) Between Runs and Turns
  return(datTrackletBouts )
}

  ## Go through Each Trajectory withing each Domain
  #### Plot Mean Path Length Per Domain Radius ###
  #lBoundedTrajectoryFiles <- dir(strDataExportDir, pattern = "stat_boundedPaths_R[0-9]{1,3}mm.rds", full.names = FALSE, ignore.case = TRUE)
  #vAvailableDomainRadius <- lapply( lBoundedTrajectoryFiles,FUN = function(s){  gsub(pattern = "[^0-9]", replacement = "", x = s)  }  )
  #Order them and Converr to Number
  #vAvailableDomainRadius <- as.integer(unlist(vAvailableDomainRadius[order(as.integer(unlist(vAvailableDomainRadius)))] ) )
  
  vAvailableDomainRadius <- getAvailablePathDomainsSizes() 
  message("Available Domain sizes:",paste(vAvailableDomainRadius,collapse=","))

  for (DomainRadius in vAvailableDomainRadius)
  {   
      lMeanPathLengthAll <- list() ##Reset List
  
      strFile <- paste0(strDataExportDir,"/stat_boundedPathsB_R",DomainRadius,"mm.rds")
      if ( file.exists(strFile))
        next() ##Skip Existing
      lBoundedTrackInfo <- readRDS(file=strFile )
      for (strGroup in names(lBoundedTrackInfo) )
      {

        #TrackLetInfo <- lBoundedTrackInfo$LL["228-1-11",] ##Short Problematic
        #TrackLetInfo <- lBoundedTrackInfo$LL["228-2-68",] 
        for (TrackLetID in rownames(lBoundedTrackInfo[[strGroup]]))
        {
          TrackLetInfo <- lBoundedTrackInfo[[strGroup]][TrackLetID,]
          if (TrackLetInfo$pathLength > MIN_PATH_LENGTH)
          {
            message(rownames(TrackLetInfo))
            lMeanPathLengthAll[[rownames(TrackLetInfo) ]] <- getTrajectoryTurnsAndRuns(TrackLetInfo)
            lMeanPathLengthAll[[rownames(TrackLetInfo) ]]$DomainRadius <- DomainRadius
          }
        }##For Each TrackLet/Path in Domain-Radius for a group

      }##For Each Group
      
      saveRDS(lMeanPathLengthAll,file=strFile)
      

  }##For Each Domain Radius
  
  
```

```{r  analyse bout structure within domains, fig.show="hold",fig.cap="Distribution of free paths (Straight runs before turning)", out.width="50%", echo=FALSE, cache=TRUE, results=TRUE}
MIN_TURN_SIZE_THRES <- 6
calcFreePathLength <- function(datTrackBouts)
{
    datStraightMotionBouts <- datTrackBouts[datTrackBouts$turn_deg < MIN_TURN_SIZE_THRES,  ]
    
    
    
    if (NROW(datStraightMotionBouts) > 1)
    {
      # Truncate long decimals -- avoid accumulating small Errors
      # TODO: Check How pathLength is calculated and truncate the Accumulation of small error
      datTrackBouts$pathLength_mm     <- as.integer(100*unlist(datTrackBouts$pathLength_mm))/100
      datTrackBouts$travelDistance_mm <- as.integer(100*unlist(datTrackBouts$travelDistance_mm))/100
      #  Calc Consecutive Straight Bouts As - Freepath - Assign same FreePathID to bouts between turnss
      blockFreePathBoutIDs <- split(datTrackBouts$boutID, 
      # Sum Increments When the following Indicators Of Changing Class Become TRUE (I added Track Splitters when Exp or Event Change)
                             cumsum(c(1, abs(diff(datTrackBouts$turn_deg)) > MIN_TURN_SIZE_THRES )  ) 
                                    ) 
      blockFreePathBoutIDs <- ldply (blockFreePathBoutIDs, data.frame)
      # Here Extract The Turn and Displacement of All Motion Bouts,  as classified by changes in Turn or Motion speed -
      names(blockFreePathBoutIDs) <- c("freePathID","boutID")
      # Attach FreePath ID
      datTrackBouts$freePathID <- blockFreePathBoutIDs$freePathID
      # Check freePathIds Correctly Assigned to bouts with the respective boutID 
      stopifnot(any(datTrackBouts[blockFreePathBoutIDs$boutID,]$freePathID == blockFreePathBoutIDs$freePathID) ) 
      
      
      # Free Path - (Exclude Turns add active-bouts and Glide-bouts paths going in  straight line)
      lTrackFreePaths <- tapply((datTrackBouts[datTrackBouts$turn_deg < MIN_TURN_SIZE_THRES,  ]$travelDistance_mm), ##pathLength_mm
                                (datTrackBouts[datTrackBouts$turn_deg < MIN_TURN_SIZE_THRES,  ]$freePathID),sum )
      
      lTrackBoutsPerFreePath <- lTrackFreePaths # I need bout count to  have same ROws num. as freepaths, (Can become otherwise if no active bout in free path)
      lTrackBoutsPerFreePath[1:NROW(lTrackFreePaths)] = 0 #Set Count to zero
      lTrackBoutsPerFreePath_tmp <- tapply((datTrackBouts[datTrackBouts$turn_deg < MIN_TURN_SIZE_THRES & datTrackBouts$boutSeqID > 0,  ]$travelDistance_mm), 
                                (datTrackBouts[datTrackBouts$turn_deg < MIN_TURN_SIZE_THRES & datTrackBouts$boutSeqID > 0,  ]$freePathID),length )
      if(!is.numeric(lTrackBoutsPerFreePath_tmp))
        lTrackBoutsPerFreePath_tmp <- array(0)
      lTrackBoutsPerFreePath[1:NROW(lTrackBoutsPerFreePath_tmp)] <- lTrackBoutsPerFreePath_tmp

    }else{ # Return Path length of the only available Single Bout that is not a turn
      lTrackFreePaths       <- array(datTrackBouts[datTrackBouts$turn_deg < MIN_TURN_SIZE_THRES,  ]$travelDistance_mm,1)
      lTrackBoutsPerFreePath <- array(1)
    }
    
    if (is.null(unlist(lTrackFreePaths) ))
    {
      lTrackFreePaths <- NA
      lTrackBoutsPerFreePath <- NA
    }else{
      ## Sanity Check - That these are almost straight - Should not exceed Domain diameterX2
      stopifnot(any(lTrackFreePaths <  5*head(datTrackBouts$DomainRadius,1) ) )
    }

  return(list(freePaths=lTrackFreePaths,boutsPerPath=lTrackBoutsPerFreePath) )          
}

plotBoundedFreePath <- function(datBoundedTrack,strG,addPlot=FALSE,XLIM=20)  
{
   mxbreaks=seq(0,XLIM,1)
   strTitle <- paste("free path R",DomainRadius)
 
  hist_D <- hist(unlist(datBoundedTrack$freePathLength_mm),breaks=mxbreaks, plot=FALSE )  
  XLIM <- c( min(log10(hist_D$mids),na.rm=TRUE), max(log10(hist_D$mids), na.rm=TRUE)*1.01)
  if (!addPlot)
  {
  plot(log10(hist_D$mids),log10( (100*hist_D$counts)/sum(hist_D$counts) ) , 
       main=strTitle,
       xlab="path length (mm)", col=colourDataScheme[strG][[1]], pch=pointTypeScheme[strG][[1]],
       xlim=XLIM,
       ylim=c(-2,2),
       ylab="log N(l) %",xaxt="n" ,type="b")
  }else {
      points(log10(hist_D$mids),log10( (100*hist_D$counts)/sum(hist_D$counts)),type="b",
      col=colourDataScheme[strG][[1]],pch=pointTypeScheme[strG][[1]] )
  }
  axis(side=1, at=log10(axisTicks(XLIM,log=TRUE)), labels =  as.character(axisTicks(XLIM,log=TRUE)))  
}   # Plot Free Paths Distribution


## Combine Bouts of a Radius onto a Single Data  frame and merge  Groups/Exp ID info
### Analyze Free Paths - Look at distribution Run lengths between turns For Each Domain Size
## Does not take long to calculate but in any case Saves Results To output Files :stat_BOUT_PerDomainSize.rds , stat_BOUT_FreePathPerDomainSize.rds

makeBoutAndFreePathSummary <- function()
{
  vAvailableDomainRadius <- getAvailablePathDomainsSizes()
  ldatBoutsPerDomain <- list()
  ldatFreePathsPerDomain <- list()
  for (DomainRadius in vAvailableDomainRadius)
  {

    strBoutAnalysisFile <- paste0(strDataExportDir,"/stat_BOUT_boundedPathsB_R",DomainRadius,"mm.rds")
    if (!file.exists(strBoutAnalysisFile))
      next()
    
    message("Processing R:",DomainRadius)
    lMeanPathLengthAll <- readRDS(file=strBoutAnalysisFile )
    lBoundedTrackInfo <- readRDS(file=paste0(strDataExportDir,"/stat_boundedPathsB_R",DomainRadius,"mm.rds") )
    
    ## Combine data on Motion Bouts with expID and group / So I can compare pooled distributions of Run Lenghts
    lRundf <- list()
    lFreePathdf <- list()
    for (strGroup in names(lBoundedTrackInfo) )
    {
      groupdomainTracks <- lBoundedTrackInfo[[strGroup]]
      for (trackID in rownames( groupdomainTracks ) )
      {
        if (is.null(lMeanPathLengthAll[[trackID]]))
          next()
        
          n = NROW(lMeanPathLengthAll[[trackID]])
          datTrackBouts <- lMeanPathLengthAll[[trackID]]
          # Remove Rounding <0 errors
          datTrackBouts$travelDistance_mm <- lapply(datTrackBouts$travelDistance_mm,max,c(0))
          datTrackBouts$pathLength_mm <- lapply(datTrackBouts$pathLength_mm,max,c(0))
           
        
          ##Add Exp/Group etc to Bout Info And Append to list
          lRundf[[trackID]] <- cbind.data.frame(datTrackBouts, 
                                                DomainRadius =rep(groupdomainTracks$DomainRadius[[trackID]],n ) ,
                                                expID=rep(groupdomainTracks$expID[[trackID]],n),
                                                EventID=rep(groupdomainTracks$EventID[[trackID]],n),
                                                TrackletUID=rep(trackID,n),#groupdomainTracks$TrackletUID[[trackID]]
                                                groupID=rep(strGroup,n) )
          
          ##Make LIst Of Detected Free Paths Per Domain-Tracklet
          lTrackFreePaths <- calcFreePathLength(datTrackBouts) ##Uses TravelDistance
          
          nP = NROW(lTrackFreePaths$freePaths)
          lFreePathdf[[trackID]] <- cbind.data.frame(freePathLength_mm=lTrackFreePaths$freePaths, 
                                                boutCount = lTrackFreePaths$boutsPerPath,
                                                DomainRadius =rep(groupdomainTracks$DomainRadius[[trackID]],nP ) ,
                                                expID=rep(groupdomainTracks$expID[[trackID]],nP),
                                                EventID=rep(groupdomainTracks$EventID[[trackID]],nP),
                                                TrackletUID=rep(trackID,nP),#groupdomainTracks$TrackletUID[[trackID]]
                                                groupID=rep(strGroup,nP) )
      }
    }
    datBoutsPerDomain <- do.call(rbind.data.frame,lRundf)
    datFreePathsPerDomain <- do.call(rbind.data.frame,lFreePathdf)

    cD <- as.character(DomainRadius) 
  
    ldatBoutsPerDomain[[cD]]     <- datBoutsPerDomain[datBoutsPerDomain$DomainRadius == cD ,]
    ldatFreePathsPerDomain[[cD]] <- datFreePathsPerDomain[datFreePathsPerDomain$DomainRadius == cD ,]
  
  } ##For Each Domain Size
  saveRDS(ldatBoutsPerDomain , file=paste0(strDataExportDir,"/stat_BOUT_PerDomainSize.rds") )
  saveRDS(ldatFreePathsPerDomain , file=paste0(strDataExportDir,"/stat_BOUT_FreePathPerDomainSize.rds") )
  
  return(list(boutsPerDomain=ldatBoutsPerDomain,freePathsPerDomain=ldatFreePathsPerDomain))
} ##Make Bout And Free Path Per DOmain Summary
        
if (!file.exists(paste0(strDataExportDir,"/stat_BOUT_PerDomainSize.rds")))
  makeBoutAndFreePathSummary()

ldatBoutsPerDomain <- readRDS(file=paste0(strDataExportDir,"/stat_BOUT_PerDomainSize.rds"))
ldatFreePathsPerDomain <- readRDS(file=paste0(strDataExportDir,"/stat_BOUT_FreePathPerDomainSize.rds"))
           
  ##Calculate Mean Bout Length Per Group
  meanBoutLengthPathPerDomain <- list()
   i<- 0
  for (R in names(ldatFreePathsPerDomain) )
  {
    
    for (strG in vGroups)
    {
        i <- i + 1
        meanBoutLengthPathPerDomain[[i]] <-list( meanBoutDistance = mean( unlist(ldatBoutsPerDomain[[R]][ldatBoutsPerDomain[[R]]$groupID == strG &
                                                                       ldatBoutsPerDomain[[R]]$turn_deg < MIN_TURN_SIZE_THRES &
                                                                   ldatBoutsPerDomain[[R]]$boutSeqID > 0 ,"travelDistance_mm"]), na.rm = T),
                                                 sdBoutDistancePath = sd( unlist(ldatBoutsPerDomain[[R]][ldatBoutsPerDomain[[R]]$groupID == strG & 
                                                                       ldatBoutsPerDomain[[R]]$turn_deg < MIN_TURN_SIZE_THRES &
                                                                   ldatBoutsPerDomain[[R]]$boutSeqID > 0 ,"travelDistance_mm"]), na.rm = T),
                                                 n = NROW(sd( unlist(ldatBoutsPerDomain[[R]][ldatBoutsPerDomain[[R]]$groupID == strG & 
                                                                       ldatBoutsPerDomain[[R]]$turn_deg < MIN_TURN_SIZE_THRES &
                                                                   ldatBoutsPerDomain[[R]]$boutSeqID > 0 ,"travelDistance_mm"]), na.rm = T)),
                                                groupID=strG,
                                                DomainRadius = as.numeric(R))
    }
  }
 datmeanBoutLengthPathPerDomain <- do.call(rbind.data.frame,meanBoutLengthPathPerDomain)
  
 
 ### Mean Free Path
  meanFreePathPerDomain <- list()
   i<- 0
  for (R in names(ldatFreePathsPerDomain) )
  {
    
    for (strG in vGroups)
    {
        i <- i + 1
        # Include Only Paths With >0 - As 0 means *no free path!*
        datFreePathsOfGroupInDomain <- ldatFreePathsPerDomain[[R]][ldatFreePathsPerDomain[[R]]$groupID == strG & 
                                                                     ldatFreePathsPerDomain[[R]]$freePathLength_mm > 0 &
                                                                     ldatFreePathsPerDomain[[R]]$boutCount > 0,] ##Only Count Free Paths That contain at least one active bout
        
        meanFreePathPerDomain[[i]] <- list( meanFreePath = mean(unlist(datFreePathsOfGroupInDomain$freePathLength_mm), na.rm = T),
                                                 sdFreePath = sd( unlist(datFreePathsOfGroupInDomain$freePathLength_mm), na.rm = T),
                                                 n = NROW(sd( unlist(datFreePathsOfGroupInDomain$freePathLength_mm), na.rm = T)),
                                                meanBoutsPerPath = mean(unlist(datFreePathsOfGroupInDomain$boutCount), na.rm = T),
                                                groupID=strG,
                                                DomainRadius = as.numeric(R))
    }
  }
 meanFreePathPerDomain <- do.call(rbind.data.frame,meanFreePathPerDomain)

 
 
 ### PLOT MEAN BOUT LENGTH PATH PER DOMAIN SIZE
 addPlot =FALSE
 for (strG in vGroups)
 {
  if (!addPlot)
  plot(datmeanBoutLengthPathPerDomain[datmeanBoutLengthPathPerDomain$groupID ==strG,"DomainRadius"],
       datmeanBoutLengthPathPerDomain[datmeanBoutLengthPathPerDomain$groupID ==strG,"meanBoutDistance"],
       col=colourDataScheme[strG][[1]],pch=pointTypeScheme[strG][[1]],ylim=c(0,3),ylab="Mean motion-bout distance (mm)",xlab="Domain radius (mm)" )
  else
  points(datmeanBoutLengthPathPerDomain[datmeanBoutLengthPathPerDomain$groupID ==strG,"DomainRadius"],
       datmeanBoutLengthPathPerDomain[datmeanBoutLengthPathPerDomain$groupID ==strG,"meanBoutDistance"],
       col=colourDataScheme[strG][[1]],pch=pointTypeScheme[strG][[1]] )
    
    addPlot <- TRUE
 }
 title("Mean distance travelled by each bout")
 
 
 ### PLOT MEAN Free Path LENGTH PATH PER DOMAIN SIZE
 addPlot =FALSE
 for (strG in vGroups)
 {
    if (!addPlot)
    plot(meanFreePathPerDomain[meanFreePathPerDomain$groupID ==strG,"DomainRadius"],
         meanFreePathPerDomain[meanFreePathPerDomain$groupID ==strG,"meanFreePath"],
         col=colourDataScheme[strG][[1]],pch=pointTypeScheme[strG][[1]],ylim=c(0,3),ylab="Mean free path (mm)",xlab="Domain radius (mm)" )
    else
    points(meanFreePathPerDomain[meanFreePathPerDomain$groupID ==strG,"DomainRadius"],
         meanFreePathPerDomain[meanFreePathPerDomain$groupID ==strG,"meanFreePath"],
         col=colourDataScheme[strG][[1]],pch=pointTypeScheme[strG][[1]] )
      
      addPlot <- TRUE
      
 }
  title("Mean free-path length ")
 
 ### PLOT MEAN Bout Number Per Path / Per Domain
 addPlot =FALSE
 for (strG in vGroups)
 {
  
    if (!addPlot)
        plot(meanFreePathPerDomain[meanFreePathPerDomain$groupID ==strG,"DomainRadius"],
         meanFreePathPerDomain[meanFreePathPerDomain$groupID ==strG,"meanBoutsPerPath"],
         col=colourDataScheme[strG][[1]],pch=pointTypeScheme[strG][[1]],ylim=c(0,5),ylab="bouts per free path  ",xlab="Domain radius (mm)" )
    else
      points(meanFreePathPerDomain[meanFreePathPerDomain$groupID ==strG,"DomainRadius"],
         meanFreePathPerDomain[meanFreePathPerDomain$groupID ==strG,"meanBoutsPerPath"],
         col=colourDataScheme[strG][[1]],pch=pointTypeScheme[strG][[1]] )
      
      addPlot <- TRUE
 }
 title("Mean number of bouts per free-path")
 
 ## Distribution of Free Path Lengths For Domain Size ##
   DomainRadius<- 8
   cD <- as.character(DomainRadius) 
   addPlot <- FALSE
   #datfreePathPerGroup <- data.frame(cbind(freePathLength_mm=ldatFreePathsPerDomain[[cD]]$freePathLength_mm,boutCount= ldatFreePathsPerDomain[[cD]]$boutCount, groupID=ldatFreePathsPerDomain[[cD ]]$groupID) )
   maxFreePath <- max(tapply(unlist(ldatFreePathsPerDomain[[cD ]]$freePathLength_mm),
                             unlist(ldatFreePathsPerDomain[[cD ]]$groupID),max,na.rm=TRUE))
  for (strG in vGroups)
  {
   datBoundedFreePath <- ldatFreePathsPerDomain[[cD ]][ldatFreePathsPerDomain[[cD ]]$groupID == strG,]

   ##Choose Turn-Motion Bouts, No Stops
   plotBoundedFreePath(datBoundedFreePath,strG,addPlot,maxFreePath+1)
   #message(paste(strG,"") )
   addPlot <- TRUE
  }
 
   
 ## Distribution of Free Path Lengths For Domain Size ##
   DomainRadius<- 4
   cD <- as.character(DomainRadius) 
   addPlot <- FALSE
   #datfreePathPerGroup <- data.frame(cbind(freePathLength_mm=ldatFreePathsPerDomain[[cD]]$freePathLength_mm,boutCount= ldatFreePathsPerDomain[[cD]]$boutCount, groupID=ldatFreePathsPerDomain[[cD ]]$groupID) )
   maxFreePath <- max(tapply(unlist(ldatFreePathsPerDomain[[cD ]]$freePathLength_mm),
                             unlist(ldatFreePathsPerDomain[[cD ]]$groupID),max,na.rm=TRUE))
  for (strG in vGroups)
  {
   datBoundedFreePath <- ldatFreePathsPerDomain[[cD ]][ldatFreePathsPerDomain[[cD ]]$groupID == strG,]

   ##Choose Turn-Motion Bouts, No Stops
   plotBoundedFreePath(datBoundedFreePath,strG,addPlot,maxFreePath+1)
   #message(paste(strG,"") )
   addPlot <- TRUE
  }
 
   
 ## Distribution of Free Path Lengths For Domain Size ##
   DomainRadius<- 10
   cD <- as.character(DomainRadius) 
   addPlot <- FALSE
   #datfreePathPerGroup <- data.frame(cbind(freePathLength_mm=ldatFreePathsPerDomain[[cD]]$freePathLength_mm,boutCount= ldatFreePathsPerDomain[[cD]]$boutCount, groupID=ldatFreePathsPerDomain[[cD ]]$groupID) )
   maxFreePath <- max(tapply(unlist(ldatFreePathsPerDomain[[cD ]]$freePathLength_mm),
                             unlist(ldatFreePathsPerDomain[[cD ]]$groupID),max,na.rm=TRUE))
  for (strG in vGroups)
  {
   datBoundedFreePath <- ldatFreePathsPerDomain[[cD ]][ldatFreePathsPerDomain[[cD ]]$groupID == strG,]

   ##Choose Turn-Motion Bouts, No Stops
   plotBoundedFreePath(datBoundedFreePath,strG,addPlot,maxFreePath+1)
   #message(paste(strG,"") )
   addPlot <- TRUE
  }
 
   
   
# Plot Distribution Of Bout Count Per Free Path
addPlot <- FALSE
 for (strG in vGroups)
 {    
   vBoutCount <- unlist(ldatFreePathsPerDomain[[cD ]][ldatFreePathsPerDomain[[cD ]]$groupID == strG &
                                                   ldatFreePathsPerDomain[[cD ]]$boutCount >0,]$boutCount)
   hist_bT <- hist(vBoutCount,  breaks=seq(0,200,1),plot=FALSE )
       message(paste("Bout Count",strG," mu:",mean(vBoutCount)) )
    if (!addPlot){
        plot(hist_bT$mids,hist_bT$counts/sum(hist_bT$counts),log="xy",col=colourDataScheme[strG][[1]],pch=pointTypeScheme[strG][[1]],type="b",xlim=c(1,50),
             xlab="Number of bouts",ylab="Log normalized bout frequency")
       }
    else{
        lines(hist_bT$mids,hist_bT$counts/sum(hist_bT$counts),col=colourDataScheme[strG][[1]],pch=pointTypeScheme[strG][[1]],type="b")
    }
   addPlot <- TRUE
 }
 title("Frequency of Bouts between-turns (free-path)")
   
 
## Interbout Intervals & Pauses - Density
addPlot <- FALSE
for (strG in vGroups)
{
    vInterBoutInterval <- ldatBoutsPerDomain[[cD]][ldatBoutsPerDomain[[cD]]$groupID == strG & 
                             ldatBoutsPerDomain[[cD]]$boutSeqID == 0 &
                                ldatBoutsPerDomain[[cD]]$duration_sec < 500 ,"duration_sec"]
    xbreaks <- c(seq(0,0.1,0.02),seq(0.11,1,0.1),seq(1.5,500,1)) #,seq(10,60,1)
    #scaling <- c(rep(1/1,11),rep(1/10,98)) #,seq(10,60,1) ## Because We are Changing the bin size - The fractrions needs top be scaled according to bin size-rations
    
    #xbreaks <- seq(0,5,0.01)
    hist_IBI <- hist(vInterBoutInterval,
              breaks=xbreaks,plot=FALSE   )
    
    message(paste("Mean inter-Bout Interval ",strG," :",mean(vInterBoutInterval) ))
    
    if (!addPlot){
        plot(hist_IBI$mids,hist_IBI$density,col=colourDataScheme[strG][[1]],pch=pointTypeScheme[strG][[1]],
             type="b",xlim=c(0.01,50),log="xy",
             xlab="Inter-bouts interval (sec)",ylab="Log Density inter-bout interval ")
    }
    else{
        lines(hist_IBI$mids,hist_IBI$density,col=colourDataScheme[strG][[1]],pch=pointTypeScheme[strG][[1]],type="b") #scaling*hist_IBI$counts/(sum(hist_IBI$counts))
    }
   addPlot <- TRUE
}
title("Inter-bout interval ")


```


*The length of motion Bout is largest for LE*, while all groups show some reduction in motion-bout length, for LF this is effect is much stronger.

Found Difference between the distributions of free-paths (lengths of straight runs before a turn),  between groups, for a domain radius of 7mm
*- Mean free path highest for LE *

Number of bouts per free(straight)-path look the same between naive but it appears  *LF execute less bouts within a straight-path* (ie in a straight line before turning). Yet each bout is longer (at least in LE)

Found bimodal distribution and that *inter-bout intervals are shorter for LF*, but also that long > 2 sec pauses are missing from LF, while naive fish will stay in one place, LF remain active.
*Evidence of fat-tails for DF and NF*:
LF do not do long-pauses between starting to move, especially in absence of prey, which is contrary to what is seen for both DF and NF.


## Correlation of bout length to interbout interval

Analytically if the step-length is decoupled from the pause time then we can treat them separatelly within in a correlated random walk processes (CRWP) 


## Turn counts per path

```{r path-turn-frequency per domain size, out.width="100%", echo=FALSE, cache=FALSE, results=FALSE}
#  MIN_TURN_SIZE_THRES

plotBoundedPathTurns <- function(turnsPerPath,strG,addPlot=FALSE)  
{
   mxbreaks=seq(0,max(turnsPerPath,na.rm=T),1)
   strTitle <- paste("Number of turns in bounded path R",DomainRadius)
 
  hist_D <- hist(unlist(turnsPerPath$TurnCount),breaks=mxbreaks, plot=FALSE )  
  XLIM <- c( min(log10(hist_D$mids),na.rm=TRUE), max(log10(hist_D$mids), na.rm=TRUE)*1.01)
  if (!addPlot)
  {
      plot(log10(hist_D$mids),log10( (100*hist_D$counts)/sum(hist_D$counts) ) , 
       main=strTitle,
       xlab="Turn count ", col=colourDataScheme[strG][[1]], pch=pointTypeScheme[strG][[1]],
       xlim=XLIM,
       ylim=c(-2,2),
       ylab="log N(l) %",xaxt="n" ,type="b")
  }else {
      points(log10(hist_D$mids),log10( (100*hist_D$counts)/sum(hist_D$counts)),type="b",
      col=colourDataScheme[strG][[1]],pch=pointTypeScheme[strG][[1]] )
  }
  axis(side=1, at=log10(axisTicks(XLIM,log=TRUE)), labels =  as.character(axisTicks(XLIM,log=TRUE)))  
}#END OF FUNCTION   


datTurnsPerDomain <- ldatBoutsPerDomain[["8"]]

## Count Turns Per Tracklet
turnsPerPath <- list()
runsPerPath <- list()
for (strG in vGroups)
{
    turnsPerPath[[strG]] <- with(datTurnsPerDomain[datTurnsPerDomain$groupID == strG & 
                                                     datTurnsPerDomain$turn_deg > MIN_TURN_SIZE_THRES &
                                                     datTurnsPerDomain$boutSeqID > 0,],{
    as.data.frame( tapply(TrackletUID,TrackletUID, NROW), col.names = c("TurnCount") ) ##COUNT Turns Pewr
  })
    runsPerPath[[strG]] <- with(datTurnsPerDomain[datTurnsPerDomain$groupID == strG & 
                                                    datTurnsPerDomain$turn_deg < MIN_TURN_SIZE_THRES & 
                                                    datTurnsPerDomain$boutSeqID > 0,],{ ##boutSeqID > 0 Ensures we are counting Active bouts 
    as.data.frame( tapply(TrackletUID,TrackletUID, NROW ),col.names = c("RunCount")) ##COUNT Turns Pewr 
  })

 names(turnsPerPath[[strG]]) <- c("TurnCount")
 names(runsPerPath[[strG]]) <- c("RunCount")
}
  ## Count Fraction of Bouts Thaty Appears as Turns , aaginst Total Active bouts (runs+Turns)
  turnBoutFraction <- turnsPerPath[[strG]]/(runsPerPath[[strG]]+turnsPerPath[[strG]])
  
  
  maxTurnCountPerGroup <- lapply(turnsPerPath,max,na.rm=T)
  ####Find the High Turners
  strG<-"LL"
  trackletID <- rownames(turnsPerPath[[strG]])[turnsPerPath[[strG]]$TurnCount > 70 & !is.na(turnsPerPath[[strG]]$TurnCount)]
  
  ## Compare Number of Turns Per Path
  addPlot <- FALSE
  for (strG in vGroups)
  {
   datBoundedTrack <- turnsPerPath[[strG]]  
   plotBoundedPathTurns(datBoundedTrack,strG,addPlot)
   addPlot <- TRUE
   message(paste("Mean turn count per free-path ",strG,":", mean(unlist( turnsPerPath[[strG]] ),na.rm=TRUE )   ) )
  }
    
  ##Clip Range
  #for (strG in vGroups)
  #  turnsPerPath[[strG]]$TurnCount <- sapply(turnsPerPath[[strG]]$TurnCount,min,c(70),na.rm=T )
  
 ##Turn Magnitude distributions
  BW <- 5
  addPlot <- FALSE
  #par(mfrow=c(1,2))
  i <- 1
  for (strG in vGroups)
  {
    datGTurns<- datTurnsPerDomain[datTurnsPerDomain$groupID == strG & abs(datTurnsPerDomain$turn_deg) < 80 & abs(datTurnsPerDomain$turn_deg) > 1 &
                                    datTurnsPerDomain$boutSeqID >0,] ##No Pause / no-moving Bouts
    #hist(datGTurns$turn_deg,breaks=seq(-80,80,2),main=paste(strG) ,xlab="Turn deg") #ylim=c(0,80)
    
    if (!addPlot)
      plot(density(datGTurns$turn_deg,bw=BW ),col=colourDataScheme[strG][[1]],pch=pointTypeScheme[strG][[1]],lty=lineTypeScheme[strG][[1]],lwd=3,ylim=c(0,0.07),xlim=c(-60,60),
           main=paste(strG,"Turns while crossing domain R",DomainRadius))
    else
     lines(density(datGTurns$turn_deg,bw=BW),col=colourDataScheme[strG][[1]],pch=pointTypeScheme[strG][[1]],lty=lineTypeScheme[strG][[1]],lwd=3)
   
    addPlot <- i%%2
    i = i +1 
    
    message(strG," Mean turn when crossing domain R",DomainRadius," : ",mean(datGTurns$turn_deg))
  }
  #mtext(paste("Turns while crossing domain R",DomainRadius), side=3, outer=TRUE, line=-1) 

```


*I see an apparent difference in turn-frequency distributions and in the distribution of free-path lengths for LE* within the paths in crossing a bounded circular domain.
- There is also a tiny right turn bias across groups
These are related to the macroscopic observations differently.

I also discover that the turn distributions of spontaneous events show a mode-tendency towards larger turns, near the 35-45 degrees, such as that I have previously found 
is associated with successful hunt events


## Bout durations

```{r bout-duration for a domain size, out.width="100%", echo=FALSE, cache=FALSE, results=FALSE}
#  MIN_TURN_SIZE_THRES
#CD is radius of domain
plotBoundedPathBoutDuration <- function(ldatBoutsPerDomain,strG,addPlot=FALSE,cD="10")  
{
    vBoutDuration <- ldatBoutsPerDomain[[cD]][ldatBoutsPerDomain[[cD]]$groupID == strG & 
                             ldatBoutsPerDomain[[cD]]$boutSeqID != 0 &
                               ldatBoutsPerDomain[[cD]]$turn_deg < MIN_TURN_SIZE_THRES &
                                ldatBoutsPerDomain[[cD]]$duration_sec < 10 ,"duration_sec"]
    xbreaks <- c(seq(0,0.5,0.02),seq(0.51,1,0.1),seq(1.5,50,1)) #,seq(10,60,1)

    hist_BI <- hist(vBoutDuration,
              breaks=xbreaks,plot=FALSE)
    
    
    if (!addPlot){
        plot(hist_BI$mids,hist_BI$density,col=colourDataScheme[strG][[1]],pch=pointTypeScheme[strG][[1]],
             type="b",xlim=c(0.01,3),log="xy",
             xlab="bout duration (sec)",ylab="Log Density bout duration ")
    }else{
        lines(hist_BI$mids,hist_BI$density,col=colourDataScheme[strG][[1]],pch=pointTypeScheme[strG][[1]],type="b") #scaling*hist_IBI$counts/(sum(hist_IBI$counts))
    }
   print(paste("Bout Duration ",strG," mu:",mean(vBoutDuration) ))
}

## Interbout Intervals & Pauses - Density
addPlot <- FALSE
plotBoundedPathBoutDuration(ldatBoutsPerDomain,'NE',FALSE,cD)
plotBoundedPathBoutDuration(ldatBoutsPerDomain,'NL',TRUE,cD)
plotBoundedPathBoutDuration(ldatBoutsPerDomain,'LE',FALSE,cD)
plotBoundedPathBoutDuration(ldatBoutsPerDomain,'LL',TRUE,cD)
plotBoundedPathBoutDuration(ldatBoutsPerDomain,'DE',FALSE,cD)
plotBoundedPathBoutDuration(ldatBoutsPerDomain,'DL',TRUE,cD)
title("Bout duration (Pooled)")
legend("bottomright", legend=c(names(colourDataScheme)[4:9]),
         col=c(unlist(colourDataScheme[names(colourDataScheme)[4:9]]) ),
         pch=c( unlist(pointTypeScheme[names(colourDataScheme)[4:9]]),18 ) )

#}

# Compare Pooled Bout Durations
 datPathBouts <- ldatBoutsPerDomain[[cD]][ldatBoutsPerDomain[[cD]]$boutSeqID != 0 &
                               ldatBoutsPerDomain[[cD]]$turn_deg < MIN_TURN_SIZE_THRES &
                                ldatBoutsPerDomain[[cD]]$duration_sec < 10 ,]
boxplot(duration_sec ~ groupID,data=datPathBouts,main="Pooled bout durations",
        col=c(colourDataScheme$LL, colourDataScheme$LE, colourDataScheme$NL, colourDataScheme$NE, colourDataScheme$DL, colourDataScheme$DE ),ylim=c(0,0.35) )

# Stat check if differences in bout duration between conditions are true
t.test(datPathBouts[datPathBouts$groupID == "LE","duration_sec"],datPathBouts[datPathBouts$groupID == "LL","duration_sec"])
t.test(datPathBouts[datPathBouts$groupID == "NE","duration_sec"],datPathBouts[datPathBouts$groupID == "NL","duration_sec"])
t.test(datPathBouts[datPathBouts$groupID == "DE","duration_sec"],datPathBouts[datPathBouts$groupID == "DL","duration_sec"])



# Group Bout Duration compared using means per Larva
datPathBoutsDuration_perLarva <- tapply(datPathBouts$duration_sec,list(expID=datPathBouts$expID,groupID=datPathBouts$groupID),mean,na.rm=TRUE)

############################
# Group Distribution of mean bout duration among larvae- 
histMeanBoutDurationsPerLarva <- function(datPathBoutsDuration_perLarva,strG,addPlot = FALSE)
{
xbreaks <- c(seq(0,0.5,0.01),seq(0.51,1,0.1),seq(1.5,50,1)) #,seq(10,60,1)
    hist_GBD <- hist(datPathBoutsDuration_perLarva[,strG],breaks=xbreaks, plot=FALSE)
  
      if (!addPlot){
          plot(hist_GBD$mids,hist_GBD$density,col=colourDataScheme[strG][[1]],pch=pointTypeScheme[strG][[1]],
               type="b",xlim=c(0.01,0.3),ylim=c(0.0,20),#log="xy",
               xlab="bout duration (sec)",ylab=" Density bout duration ")
      }else{
          lines(hist_GBD$mids,hist_GBD$density,col=colourDataScheme[strG][[1]],pch=pointTypeScheme[strG][[1]],type="b") #scaling*hist_IBI$counts/(sum(hist_IBI$counts))
      }
     print(paste("Group bout duration ",strG," mu:",mean(datPathBoutsDuration_perLarva[,strG]) ))
}

# Group Distribution of mean bout duration among larvae- 
densMeanBoutDurationsPerLarva <- function(datPathBoutsDuration_perLarva,strG,addPlot = FALSE)
{
#xbreaks <- c(seq(0,0.5,0.01),seq(0.51,1,0.1),seq(1.5,50,1)) #,seq(10,60,1)
    dens_GBD <- density(datPathBoutsDuration_perLarva[!is.na(datPathBoutsDuration_perLarva[,strG]),strG],bw=0.02 )
  
      if (!addPlot){
          plot(dens_GBD,col=colourDataScheme[strG][[1]],pch=pointTypeScheme[strG][[1]],lty=lineTypeScheme[strG][[1]],
               type="l",lwd=3,xlim=c(0.01,0.3),ylim=c(0.0,20),#log="xy",
               xlab="bout duration (sec)",ylab=" Density bout duration ",main="mean bout duration per larva")
      }else{
          lines(dens_GBD,col=colourDataScheme[strG][[1]],pch=pointTypeScheme[strG][[1]],lty=lineTypeScheme[strG][[1]],type="l",lwd=3) #scaling*hist_IBI$counts/(sum(hist_IBI$counts))
      }
     print(paste("Group bout duration ",strG," mu:",mean(datPathBoutsDuration_perLarva[,strG]) ))
}

# BOXPLOT OF Group Duration
lmeanBoutDurationPerLarvaInGroup <- list()
for (strG in vGroups)
{
  lmeanBoutDurationPerLarvaInGroup[[strG]] <- 
    cbind.data.frame( duration_sec=as.numeric(datPathBoutsDuration_perLarva[!is.na(datPathBoutsDuration_perLarva[,strG]) ,strG]),groupID=strG)
}# For each Group - Plot larval mean bout duration
datMeanBoutDurationPerLarva <- do.call(rbind.data.frame,lmeanBoutDurationPerLarvaInGroup)
datMeanBoutDurationPerLarva$duration_sec <- as.numeric(datMeanBoutDurationPerLarva$duration_sec)


boxplot(duration_sec ~ groupID,data=datMeanBoutDurationPerLarva,main="Mean bout duration per larva",
        col=c(colourDataScheme$LL, colourDataScheme$LE, colourDataScheme$NL, colourDataScheme$NE, colourDataScheme$DL, colourDataScheme$DE ),ylim=c(0,0.35) )


#title("Mean larval bout duration ")
densMeanBoutDurationsPerLarva(datPathBoutsDuration_perLarva,"NE",FALSE)
densMeanBoutDurationsPerLarva(datPathBoutsDuration_perLarva,"NL",TRUE)
densMeanBoutDurationsPerLarva(datPathBoutsDuration_perLarva,"LE",FALSE)
densMeanBoutDurationsPerLarva(datPathBoutsDuration_perLarva,"LL",TRUE)
densMeanBoutDurationsPerLarva(datPathBoutsDuration_perLarva,"DE",FALSE)
densMeanBoutDurationsPerLarva(datPathBoutsDuration_perLarva,"DL",TRUE)



```


It appears that LE and NE bouts last longer, than their respective evoked conditions (LL,NL).
The *LE, bouts are the longest*, which could also explain why LE travel faster (mean path length for fixed duration is longer).
The same is true in NF, where presence of prey makes bout duration shorter, but importantly *bout duration in DF does not change between prey and non-prey conditions*.

## Bout distance

```{r bout-distance for fixed domain size, out.width="100%", echo=FALSE, cache=FALSE, results=FALSE,warning=FALSE}
#  MIN_TURN_SIZE_THRES
#CD is radius of domain
plotBoundedPathBoutDistance <- function(ldatBoutsPerDomain,strG,addPlot=FALSE,cD="10")  
{
    vBoutDistance <- unlist(ldatBoutsPerDomain[[cD]][ldatBoutsPerDomain[[cD]]$groupID == strG & 
                             ldatBoutsPerDomain[[cD]]$boutSeqID != 0 &
                               ldatBoutsPerDomain[[cD]]$turn_deg < MIN_TURN_SIZE_THRES &
                                ldatBoutsPerDomain[[cD]]$duration_sec < 1 ,"travelDistance_mm"])
    xbreaks <- c(seq(0,4.5,0.25),seq(4.51,20,0.5)) #,seq(10,60,1)
    #scaling <- c(rep(1/1,11),rep(1/10,98)) #,seq(10,60,1) ## Because We are Changing the bin size - The fractrions needs top be scaled according to bin size-rations
    
    #xbreaks <- seq(0,5,0.01)
    hist_BD <- hist(vBoutDistance, breaks=xbreaks,plot=FALSE)
    
    if (!addPlot){
        plot(hist_BD$mids,hist_BD$density,col=colourDataScheme[strG][[1]],pch=pointTypeScheme[strG][[1]],
             type="b",xlim=c(0.1,15),ylim=c(0.001,50),log="xy",
             xlab="bout distance (mm)",ylab="Log Density bout distance ")
    }else{
        lines(hist_BD$mids,hist_BD$density,col=colourDataScheme[strG][[1]],pch=pointTypeScheme[strG][[1]],type="b") #scaling*hist_IBI$counts/(sum(hist_IBI$counts))
    }
   print(paste("Bout Distance ",strG," mu:",mean(vBoutDistance) ))
}

## Interbout Intervals & Pauses - Density
addPlot <- FALSE
plotBoundedPathBoutDistance(ldatBoutsPerDomain,'NE',FALSE,cD)
plotBoundedPathBoutDistance(ldatBoutsPerDomain,'NL',TRUE,cD)
plotBoundedPathBoutDistance(ldatBoutsPerDomain,'LE',FALSE,cD)
plotBoundedPathBoutDistance(ldatBoutsPerDomain,'LL',TRUE,cD)
plotBoundedPathBoutDistance(ldatBoutsPerDomain,'DE',FALSE,cD)
plotBoundedPathBoutDistance(ldatBoutsPerDomain,'DL',TRUE,cD)
   

title("Bout Distance ")

legend("topright", legend=c(names(colourDataScheme)[4:9]),
         col=c(unlist(colourDataScheme[names(colourDataScheme)[4:9]]) ),
         pch=c( unlist(pointTypeScheme[names(colourDataScheme)[4:9]]),18 ) )

#}

 datPathBouts <- ldatBoutsPerDomain[[cD]][ldatBoutsPerDomain[[cD]]$boutSeqID != 0 &
                               ldatBoutsPerDomain[[cD]]$turn_deg < MIN_TURN_SIZE_THRES &
                                ldatBoutsPerDomain[[cD]]$duration_sec < 1 ,]
 datPathBouts$travelDistance_mm <- unlist(datPathBouts$travelDistance_mm)
 
boxplot(travelDistance_mm ~ groupID,data=datPathBouts,main="Bout Distance",
        col=c(colourDataScheme$LL, colourDataScheme$LE, colourDataScheme$NL, colourDataScheme$NE, colourDataScheme$DL, colourDataScheme$DE ),ylim=c(0,3) )

# Stat check if differences in bout duration between conditions are true
t.test(datPathBouts[datPathBouts$groupID == "LE","travelDistance_mm"],datPathBouts[datPathBouts$groupID == "LL","travelDistance_mm"])
t.test(datPathBouts[datPathBouts$groupID == "NE","travelDistance_mm"],datPathBouts[datPathBouts$groupID == "NL","travelDistance_mm"])
t.test(datPathBouts[datPathBouts$groupID == "DE","travelDistance_mm"],datPathBouts[datPathBouts$groupID == "DL","travelDistance_mm"])
t.test(datPathBouts[datPathBouts$groupID == "DE","travelDistance_mm"],datPathBouts[datPathBouts$groupID == "NE","travelDistance_mm"])
#t.test(datPathBouts[datPathBouts$groupID == "DL","duration_sec"],datPathBouts[datPathBouts$groupID == "NL","travelDistance_mm"])



# Group Bout Duration compared using means per Larva
datPathBoutsDistance_perLarva <- tapply(unlist(datPathBouts$travelDistance_mm),list(expID=datPathBouts$expID,groupID=datPathBouts$groupID),mean,na.rm=TRUE)

############################
# Group Distribution of mean bout duration among larvae- 
histMeanBoutDistancePerLarva <- function(datPathBoutsDistance_perLarva,strG,addPlot = FALSE)
{
xbreaks <- c(seq(0,1,0.1),seq(0.51,1,0.1),seq(1.5,50,1)) #,seq(10,60,1)
    hist_GBD <- hist(datPathBoutsDistance_perLarva[,strG],breaks=xbreaks, plot=FALSE)
  
      if (!addPlot){
          plot(hist_GBD$mids,hist_GBD$density,col=colourDataScheme[strG][[1]],pch=pointTypeScheme[strG][[1]],
               type="b",xlim=c(0.01,3),ylim=c(0.0,10),#log="xy",
               xlab="bout distance (sec)",ylab=" Density bout distance ")
      }else{
          lines(hist_GBD$mids,hist_GBD$density,col=colourDataScheme[strG][[1]],pch=pointTypeScheme[strG][[1]],type="b") #scaling*hist_IBI$counts/(sum(hist_IBI$counts))
      }
     print(paste("Group bout distance ",strG," mu:",mean(datPathBoutsDistance_perLarva[,strG],na.rm=TRUE) ))
}

# Group Distribution of mean bout duration among larvae- 
densMeanBoutDistancePerLarva <- function(datPathBoutsDistance_perLarva,strG,addPlot = FALSE)
{
#xbreaks <- c(seq(0,0.5,0.01),seq(0.51,1,0.1),seq(1.5,50,1)) #,seq(10,60,1)
    dens_GBD <- density(datPathBoutsDistance_perLarva[!is.na(datPathBoutsDistance_perLarva[,strG]),strG],bw=0.2 )
  
      if (!addPlot){
          plot(dens_GBD,col=colourDataScheme[strG][[1]],pch=pointTypeScheme[strG][[1]],lty=lineTypeScheme[strG][[1]],
               type="l",lwd=3,xlim=c(0.0,3),ylim=c(0.0,5),#log="xy",
               xlab="bout distance (mm)",ylab=" Density bout distance ",main="mean bout distance per larva")
      }else{
          lines(dens_GBD,col=colourDataScheme[strG][[1]],pch=pointTypeScheme[strG][[1]],lty=lineTypeScheme[strG][[1]],type="l",lwd=3) #scaling*hist_IBI$counts/(sum(hist_IBI$counts))
      }
     print(paste("Group bout distance ",strG," mu:",mean(datPathBoutsDistance_perLarva[,strG],na.rm=TRUE) ))
}

# BOXPLOT OF Group Duration
lmeanBoutDistancePerLarvaInGroup <- list()
for (strG in vGroups)
{
  lmeanBoutDistancePerLarvaInGroup[[strG]] <- 
    cbind.data.frame( distance_mm=as.numeric(datPathBoutsDistance_perLarva[!is.na(datPathBoutsDistance_perLarva[,strG]) ,strG]),groupID=strG)
}# For each Group - Plot larval mean bout duration
datMeanBoutDistancePerLarva <- do.call(rbind.data.frame,lmeanBoutDistancePerLarvaInGroup)
datMeanBoutDistancePerLarva$distance_mm <- as.numeric(datMeanBoutDistancePerLarva$distance_mm)


boxplot(distance_mm ~ groupID,data=datMeanBoutDistancePerLarva,main="Mean bout distance per larva",
        col=c(colourDataScheme$LL, colourDataScheme$LE, colourDataScheme$NL, colourDataScheme$NE, colourDataScheme$DL, colourDataScheme$DE ),ylim=c(0,3) )


#title("Mean larval bout duration ")
densMeanBoutDistancePerLarva(datPathBoutsDistance_perLarva,"NE",FALSE)
densMeanBoutDistancePerLarva(datPathBoutsDistance_perLarva,"NL",TRUE)
densMeanBoutDistancePerLarva(datPathBoutsDistance_perLarva,"LE",FALSE)
densMeanBoutDistancePerLarva(datPathBoutsDistance_perLarva,"LL",TRUE)
densMeanBoutDistancePerLarva(datPathBoutsDistance_perLarva,"DE",FALSE)
densMeanBoutDistancePerLarva(datPathBoutsDistance_perLarva,"DL",TRUE)

#histMeanBoutDistancePerLarva(datPathBoutsDistance_perLarva,"LL",FALSE)

```

*Bout distances appear longer in LF, compared to DF and NF*.
In all groups bout distances are longer in  spontaneous conditions, and shorter in evoked conditions, except for DF. 
This agrees with spontaneous conditions having longer bout durations.
I need to verify that this applies to exploratory movements, and i is not simply due to hunt event bouts being shorter in evoked conditions when reacting to prey, but in anycase the DF shows that this is not due to growth, and likely not due to interacting with prey either - because in DF bout distance does not change with test conditions.

# Bout Speed

```{r bout-speed for fixed domain size, out.width="100%", echo=FALSE, cache=FALSE, results=FALSE,warning=FALSE}
#  MIN_TURN_SIZE_THRES
#CD is radius of domain
plotBoundedPathBoutSpeed <- function(ldatBoutsPerDomain,strG,addPlot=FALSE,cD="10")  
{
    vBoutDistance <- unlist(ldatBoutsPerDomain[[cD]][ldatBoutsPerDomain[[cD]]$groupID == strG & 
                             ldatBoutsPerDomain[[cD]]$boutSeqID != 0 &
                               ldatBoutsPerDomain[[cD]]$turn_deg < MIN_TURN_SIZE_THRES &
                                ldatBoutsPerDomain[[cD]]$duration_sec < 1 ,"travelDistance_mm"])
    
    vBoutDuration <- unlist(ldatBoutsPerDomain[[cD]][ldatBoutsPerDomain[[cD]]$groupID == strG & 
                             ldatBoutsPerDomain[[cD]]$boutSeqID != 0 &
                               ldatBoutsPerDomain[[cD]]$turn_deg < MIN_TURN_SIZE_THRES &
                                ldatBoutsPerDomain[[cD]]$duration_sec < 1 ,"duration_sec"])
    
    vBoutSpeed <- vBoutDistance/vBoutDuration
    xbreaks <- c(seq(0.0,20,1),seq(20.1,200,5)) #,seq(10,60,1)
    #scaling <- c(rep(1/1,11),rep(1/10,98)) #,seq(10,60,1) ## Because We are Changing the bin size - The fractrions needs top be scaled according to bin size-rations
    
    #xbreaks <- seq(0,5,0.01)
    hist_BS <- hist(vBoutSpeed, breaks=xbreaks,plot=FALSE)
    
    if (!addPlot){
        plot(hist_BS$mids,hist_BS$density,col=colourDataScheme[strG][[1]],pch=pointTypeScheme[strG][[1]],
             type="b",xlim=c(0.5,55),ylim=c(0.001,50),log="xy",
             xlab="bout speed (mm/sec)",ylab="Log Density bout speed ")
    }else{
        lines(hist_BS$mids,hist_BS$density,col=colourDataScheme[strG][[1]],pch=pointTypeScheme[strG][[1]],type="b") #scaling*hist_IBI$counts/(sum(hist_IBI$counts))
    }
   print(paste("Bout Speed ",strG," mu:",mean(vBoutSpeed,na.rm=T) ))
}

## Interbout Intervals & Pauses - Density
addPlot <- FALSE
plotBoundedPathBoutSpeed(ldatBoutsPerDomain,'NE',FALSE,cD)
plotBoundedPathBoutSpeed(ldatBoutsPerDomain,'NL',TRUE,cD)
plotBoundedPathBoutSpeed(ldatBoutsPerDomain,'LE',FALSE,cD)
plotBoundedPathBoutSpeed(ldatBoutsPerDomain,'LL',TRUE,cD)
plotBoundedPathBoutSpeed(ldatBoutsPerDomain,'DE',FALSE,cD)
plotBoundedPathBoutSpeed(ldatBoutsPerDomain,'DL',TRUE,cD)
   

title("Bout Speed ")

legend("topright", legend=c(names(colourDataScheme)[4:9]),
         col=c(unlist(colourDataScheme[names(colourDataScheme)[4:9]]) ),
         pch=c( unlist(pointTypeScheme[names(colourDataScheme)[4:9]]),18 ) )

#}

 datPathBouts <- ldatBoutsPerDomain[[cD]][ldatBoutsPerDomain[[cD]]$boutSeqID != 0 &
                               ldatBoutsPerDomain[[cD]]$turn_deg < MIN_TURN_SIZE_THRES &
                                ldatBoutsPerDomain[[cD]]$duration_sec < 1 ,]
 datPathBouts$travelDistance_mm <- unlist(datPathBouts$travelDistance_mm)
 
boxplot(travelDistance_mm/duration_sec ~ groupID,data=datPathBouts,main="Bout speed",
        col=c(colourDataScheme$LL, colourDataScheme$LE, colourDataScheme$NL, colourDataScheme$NE, colourDataScheme$DL, colourDataScheme$DE ),ylim=c(0,40) )

# Stat check if differences in bout duration between conditions are true
t.test(datPathBouts[datPathBouts$groupID == "LE","duration_sec"],datPathBouts[datPathBouts$groupID == "LL","travelDistance_mm"])
t.test(datPathBouts[datPathBouts$groupID == "NE","duration_sec"],datPathBouts[datPathBouts$groupID == "NL","travelDistance_mm"])
t.test(datPathBouts[datPathBouts$groupID == "DE","duration_sec"],datPathBouts[datPathBouts$groupID == "DL","travelDistance_mm"])
t.test(datPathBouts[datPathBouts$groupID == "DE","duration_sec"],datPathBouts[datPathBouts$groupID == "NE","travelDistance_mm"])
#t.test(datPathBouts[datPathBouts$groupID == "DL","duration_sec"],datPathBouts[datPathBouts$groupID == "NL","travelDistance_mm"])



# Group Bout Duration compared using means per Larva
datPathBoutsSpeed_perLarva <- tapply(unlist(datPathBouts$travelDistance_mm)/unlist(datPathBouts$duration_sec),list(expID=datPathBouts$expID,groupID=datPathBouts$groupID),mean,na.rm=TRUE)

############################
# Group Distribution of mean bout duration among larvae- 
histMeanBoutSpeedPerLarva <- function(datPathBoutsSpeed_perLarva,strG,addPlot = FALSE)
{
xbreaks <- c(seq(0,10,0.5),seq(0.51,1,0.1),seq(1.5,50,1)) #,seq(10,60,1)
    hist_GBD <- hist(datPathBoutsSpeed_perLarva[,strG],breaks=xbreaks, plot=FALSE)
  
      if (!addPlot){
          plot(hist_GBD$mids,hist_GBD$density,col=colourDataScheme[strG][[1]],pch=pointTypeScheme[strG][[1]],
               type="b",xlim=c(0.01,3),ylim=c(0.0,10),#log="xy",
               xlab="bout speed (mm/sec)",ylab=" Density bout speed ")
      }else{
          lines(hist_GBD$mids,hist_GBD$density,col=colourDataScheme[strG][[1]],pch=pointTypeScheme[strG][[1]],type="b") #scaling*hist_IBI$counts/(sum(hist_IBI$counts))
      }
     print(paste("Group bout speed ",strG," mu:",mean(datPathBoutsSpeed_perLarva[,strG],na.rm=TRUE) ))
}

# Group Distribution of mean bout duration among larvae- 
densMeanBoutSpeedPerLarva <- function(datPathBoutsSpeed_perLarva,strG,addPlot = FALSE)
{
#xbreaks <- c(seq(0,0.5,0.01),seq(0.51,1,0.1),seq(1.5,50,1)) #,seq(10,60,1)
    dens_GBD <- density(datPathBoutsSpeed_perLarva[!is.na(datPathBoutsSpeed_perLarva[,strG]),strG],bw=1 )
  
      if (!addPlot){
          plot(dens_GBD,col=colourDataScheme[strG][[1]],pch=pointTypeScheme[strG][[1]],lty=lineTypeScheme[strG][[1]],
               type="l",lwd=3,xlim=c(0.0,15),ylim=c(0.0,1),#log="xy",
               xlab="bout speed (mm/sec)",ylab=" Density bout speed ",main="mean bout speed per larva")
      }else{
          lines(dens_GBD,col=colourDataScheme[strG][[1]],pch=pointTypeScheme[strG][[1]],lty=lineTypeScheme[strG][[1]],type="l",lwd=3) #scaling*hist_IBI$counts/(sum(hist_IBI$counts))
      }
     print(paste("Group bout speed ",strG," mu:",mean(datPathBoutsSpeed_perLarva[,strG],na.rm=TRUE) ))
}

# BOXPLOT OF Group Duration
lmeanBoutSpeedPerLarvaInGroup <- list()
for (strG in vGroups)
{
  lmeanBoutSpeedPerLarvaInGroup[[strG]] <- 
    cbind.data.frame( speed_mmsec=as.numeric(datPathBoutsSpeed_perLarva[!is.na(datPathBoutsSpeed_perLarva[,strG]) ,strG]),groupID=strG)
}# For each Group - Plot larval mean bout duration
datMeanBoutSpeedPerLarva <- do.call(rbind.data.frame,lmeanBoutSpeedPerLarvaInGroup)
datMeanBoutSpeedPerLarva$speed_mmsec <- as.numeric(datMeanBoutSpeedPerLarva$speed_mmsec)


boxplot(speed_mmsec ~ groupID,data=datMeanBoutSpeedPerLarva,main="Mean bout speed per larva",
        col=c(colourDataScheme$LL, colourDataScheme$LE, colourDataScheme$NL, colourDataScheme$NE, colourDataScheme$DL, colourDataScheme$DE ),ylim=c(0,40) )


#title("Mean larval bout duration ")
densMeanBoutSpeedPerLarva(datPathBoutsSpeed_perLarva,"NE",FALSE)
densMeanBoutSpeedPerLarva(datPathBoutsSpeed_perLarva,"NL",TRUE)
densMeanBoutSpeedPerLarva(datPathBoutsSpeed_perLarva,"LE",FALSE)
densMeanBoutSpeedPerLarva(datPathBoutsSpeed_perLarva,"LL",TRUE)
densMeanBoutSpeedPerLarva(datPathBoutsSpeed_perLarva,"DE",FALSE)
densMeanBoutSpeedPerLarva(datPathBoutsSpeed_perLarva,"DL",TRUE)



```
**Bout Speed increases in the absence of prey**
*LE produce the fastest bouts (6.9 mm/sec)*, while DF are slower than naive, which means size does not explain speed increase.
It is also shown that DF does not change bout speed with prey abundance, (same is true for distance and speed of DF).

These results may be associated to the circuits underlying the short-term motor learning  by which swim vigour is modified depending on visual feedback (Kawashima et al. ).
The authors found that such a learned motor-sensory gain is retained after a delay with no stimulus, and scales with the duration of training

For DF, where actions converge this may be linked to adaptation to motor actions that reduce energy expenditure when their actions are futile:
  - Andalman et al.  found that 1.5–2 week old zebrafish exposed to inescapable shocks would first attempt to escape from these aversive stimuli, but then transitioned into a prolonged state of behavioral passiv- ity—no longer attempting to move because their actions were futile
  - Mu et al. examined fish in a closed- loop optomotor assay, where the fish’s fictive swimming behavior updated their visual environment (similar to Refs. [31,33]). When the authors suddenly made these swimming behaviors ineffective – no longer influencing the visual environment – fish first attempted vigorous movement before entering into an extended passive state
  
# Full figure List of trajectories per experiment

The following figures show the tracked trajectories per experiment of each group.
Trajectory segments are colour coded according to whether these can be classified as exploration or exploitation based on ta theshold on the normalized dispersion. This threshold is set here to `r thres_dispersion_class ` .
Red signiifies segments of exploitation, blue is for exploration. 
The column on the right shows the dispersion measurement along recording time. Note the x-axis is not real time, it is the total time of  concatenated recording events. The horizontal line represents where the exploit/explore dispersal threshold sits for each larva, given its normalized disperal measurements.
The triangles at the bottom denote hunt-event initiations in relation to dispersal.

  - Observing dispersals and trajectories it becomes clear that during a 10 min recording a larva could be in exploitation phase all the way, and thus the range of dispersals that this larva can produce is most likely not observed. see : 
   - NL 309/NE 302


## Trajectories clustered on Global NB Mix Model  

Note that dispersion is normalized based on the trajectories from Spontaneous and Evoked conditions *combined* for each larva.
Here it should be noted that in Marquez et al 2019 "To facilitate comparison across animals, the dispersal distance was normalized to the range of each animal."
That means this is not a division by the maximum dispersal of each animal, but it also makes use of the minimum.


#### LF - Evoked /Spontaneous Trajectories

```{r  NBMixClustered-trajectories-LL, fig.show="hold", out.width="50%", echo=FALSE, results='hide' , cache=TRUE, autodep=TRUE,eval=FALSE,warning=FALSE}

loaddatAllFrames()
loadDispersionData()

  plotNBMixGClusteredDispersionTrajectories(c('LL','LE'),datAllFrames, datDispersion ,datHEventDispersion,datExpPairs,  thres_dispersion_class )

```

#### NF - Evoked/Spontaneous Trajectories 
```{r larva_norm-trajectories-NL, fig.show="hold", out.width="50%", echo=FALSE, results='hide',cache=TRUE, autodep=TRUE,eval=FALSE,warning=FALSE}
plotLarvaNormDispersionTrajectories(c('NL','NE'),datAllFrames, datDispersion ,datHEventDispersion,datExpPairs, thres_dispersion_class )

```
  
#### DF - Evoked/Spontaneous Trajectories 
```{r larva_norm-trajectories-DL, fig.show="hold", out.width="50%", echo=FALSE, results='hide', cache=TRUE, autodep=TRUE,eval=FALSE,warning=FALSE}

plotLarvaNormDispersionTrajectories(c('DL','DE'),datAllFrames, datDispersion , datHEventDispersion, datExpPairs, thres_dispersion_class)


```

## Classifying exploitation/exploration phases based on **global threshold**
The dispersion of each experiment is normalized globally and thus classification threhsold for exploitation identifies trajectory segments of spatially restricted motion relative to all larvae across groups

### Evoked conditions
Trajectories of 10min recordings in the presence of prey. Note, in contrast to Marquez et al. 2019, our recodings exclude motion at the boundary of petridish.

#### LF - Evoked+Sponτaneous larval trajectories
Eploitation state is shown in *red* and *orange* in evoked and spontaneous test conditions respectivelly, with hunt events shown as squares.
Exploration state is *blue* and *green* in evoked and spontaneous test conditions respectivelly, , with hunt events shown as triangles.

```{r  global_norm-trajectories-LL, fig.show="hold", out.width="50%", echo=FALSE, results='hide', cache=TRUE, autodep=TRUE,eval=FALSE }
loaddatAllFrames()
loadDispersionData()
plotGlobalNormDispersionTrajectories(c('LL','LE'), datAllFrames, datDispersion, datHEventDispersion, datExpPairs,   thres_dispersion_class )

```

#### NF - Evoked+Spont Trajectories 
```{r global_norm-trajectories-NL, fig.show="hold", out.width="50%", echo=FALSE, results='hide', cache=TRUE, autodep=TRUE,eval=FALSE}

plotGlobalNormDispersionTrajectories(c('NL','NE'),datAllFrames,datDispersion,datHEventDispersion,datExpPairs, thres_dispersion_class )

```

#### DF - Evoked Trajectories 
```{r global_norm-trajectories-DL, fig.show="hold", out.width="50%", echo=FALSE, results='hide', cache=TRUE, autodep=TRUE,eval=FALSE}

plotGlobalNormDispersionTrajectories(c('DL','DE'),datAllFrames,datDispersion,datHEventDispersion,datExpPairs, thres_dispersion_class)

```

## Classify based on normalizated experiment trajectory dispersion

Note that Spontaneous and Evoked conditions of each larva are considered individually

#### LF - Evoked /Spontaneous Trajectories
```{r  exp_norm-trajectories-LL, fig.show="hold", out.width="50%", echo=FALSE, results='hide' , cache=TRUE, autodep=TRUE,eval=FALSE}
loaddatAllFrames()
loadDispersionData()
plotExpNormDispersionTrajectories(c('LL','LE'),datAllFrames,datDispersion ,datHEventDispersion,datExpPairs,  thres_dispersion_class )

```

#### NF - Evoked/Spontaneous Trajectories 
```{r exp_norm-trajectories-NL, fig.show="hold", out.width="50%", echo=FALSE, results='hide',cache=TRUE, autodep=TRUE,eval=FALSE}

plotExpNormDispersionTrajectories(c('NL','NE'),datAllFrames,datDispersion ,datHEventDispersion,datExpPairs, thres_dispersion_class )

```

#### DF - Evoked/Spontaneous Trajectories 
```{r exp_norm-trajectories-DL, fig.show="hold", out.width="50%", echo=FALSE, results='hide', cache=TRUE, autodep=TRUE,eval=FALSE}


plotExpNormDispersionTrajectories(c('DL','DE'),datAllFrames,datDispersion ,datHEventDispersion,datExpPairs, thres_dispersion_class)

```



```{r ForagingStateAnalysis_Modelling,child = 'ForagingStateAnalysis_Modelling.Rmd'}
```

# Final Notes


##  Foraging and Predator Avoidance (#stephens2008)
Foraging may be optimal in terms of maximizing food uptake, but may involve a a balance between other factors such as risk of predation. Discrepancies between optimal foraging models and empirical field data have already been noted (see Phys of Foraging pg 15), which have suiggested trade-offs between optimal foragings and predator risk.
Thus in these investigations I can include the my data showing how experience shapes the balance between hunt-rate and prey density (the gaussian process model of hunt-rate vs Prey Density).

see also (#dunlap2012tracking) but also (#viswanathan2011physics)

special, but we find that the extent of this ‘specialness’ depends on the
subject’s prior experience of environmental change.

# END

```{r spare-code-notes,eval=FALSE, include=FALSE}
## Retrieve Dispersion of each Hunt Event
start.time <- Sys.time()
i <- 0
for (i in 1:NROW(datHuntLabelledEventsSBMerged_fixed) )
{

   datHEvent_disp <- datDispersion[datDispersion$expID == datHuntLabelledEventsSBMerged_fixed[i,]$expID &
                              datDispersion$eventID == datHuntLabelledEventsSBMerged_fixed[i,]$eventID &
                              datDispersion$frameN == datHuntLabelledEventsSBMerged_fixed[i,]$startFrame ,] #
   #message(datHEvent_disp$expID)

   if (NROW(datHEvent_disp) == 0 )
   {
     warning("Tracking dispersion data not found for huntevent ",i, "at startframe ",datHuntLabelledEventsSBMerged_fixed[i,]$startFrame )
     ##Try Again without the start frame - Slower
     datHEvent_disp <- datDispersion[datDispersion$expID == datHuntLabelledEventsSBMerged_fixed[i,]$expID &
                              datDispersion$eventID == datHuntLabelledEventsSBMerged_fixed[i,]$eventID  ,] #
   }

   if (NROW(datHEvent_disp) == 0 )
     warning("Attaching dispersion data for huntevent ",i, " Failed")

   # Check if Rec Exists
   if (NROW(datHEvent_disp) == 1 )
   {

     vHuntEventDispersion[i] <- datHEvent_disp$Dispersion
     vHuntEventDispersion_norm[i] <-  datHEvent_disp$Dispersion_norm
     message(i," Disp:",vHuntEventDispersion[i])

   }else {

     ## Multiple rows returned
     ## FInd Tracking (Dispersion dat) frame that is closest to hunt-event initiation (start frame)
     idx <- NA
     with(datHuntLabelledEventsSBMerged_fixed[i,],
          {
                idx <- which(abs(datHEvent_disp$frameN - startFrame) == min(abs(datHEvent_disp$frameN - startFrame) ) )

                vHuntEventDispersion_norm[i] <- datHEvent_disp[idx,"Dispersion_norm"]
                vHuntEventDispersion[i] <- datHEvent_disp[idx,"Dispersion"]
               ##This Maybe NA since there are no Dispersion Data In some Occassions
               ##stopifnot(!is.na(vHuntEventDispersion[i]))
               message("Found idx ",idx, " Disp ",vHuntEventDispersion[i])
          })

   }

    #Find Dispersion At start Frame of Hunt Event
    #
    print(i)


    #stopifnot(i <11)
}

   end.time <- Sys.time()
   time.taken <- end.time - start.time
   print(time.taken)

 
```
