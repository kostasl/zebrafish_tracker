---
title: 'Notebook: Identifying the role of experience on foraging and exploration movement patterns'
output:
  html_document:
    df_print: paged
    params: 
    output_dir: "/media/kostasl/D445GB_ext4/kostasl/Dropbox/Calculations/zebrafishtrackerData/foragingAnalysis"

  html_notebook: default
  pdf_document: default
  bibliography: ForagingStateAnalysis.bib
---


This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook, analysing zebrafish tracking data 
for foraging state as indicated by Marquez et al 2019. I aim to extend my previous work on the experience driven ontogeny of hunting skill [now published in eLife](https://elifesciences.org/articles/55119/figures) 
Zebrafish appear to spontaneously switch between an exploratory and exploitation phase that grossly defines their behavioural mode. 
The state can be read out be measuring trajectory dispersal over a fixed period of time (5 sec), 
According to Marquez et al  2020 Measures of dispersal should appear bimodal, with short dispersals indicating exploitation phase.

Given our behavioural recordings are not continuous, and exclude periods when the larva are swimming around the boundary, it is not certain whether we would be able to detect exploratory phases. These tend to be circling around the border of the petri-dish, as the fish attempts to swim forward. Nevertheless as we are interested in the mode-state under which hunt-events are executed, then we expect that some of these events should be executed during exploratory behaviour and this should be detectable - (dispersal, movement rates etc).
In essense the internal state and the its neural correlates as reported by Marquez et al 2019 can combined with my results on the learned aspects of efficient hunting to study if this foraging state swithcing is also influenced by experience and  whether differences in hunting kinematics correlate with internal state.

  Hypothesis being tested :
  - Does experience modify the dispersal  and so the exploit/explore state of each group?
  - Are foraging intervals modified based on priors built by experience and can these be modelled based on active inference ?(co-op with Rosalyn & Berk)
  - Could expansion of foraging interval explain the higher evoked hunt-rate of the LF group?
  - Does the execution of the kinematic adaptations of capture efficiency, found in the experience larvae,  depend on foraging state ?
  
Establishing a correlation of hunting state with the kinematics of efficient hunting can point us to the underlying circuits, because the circuits that correlate with foraging state, but also with capture-success,  have already been examined by Marquez et al 2019. So it would be posssible to use those to guide our search for the circuits that bring about the kinematics adaptations of success. 

In a new twist of this work *I discover structure in the larval trajectories that indicates a random search process*. 
Indeed although at the microscale larval do not move randomly, but have a rythm, it may well be the case (E.Raposo et al. 2009 ):
>Therefore, the foraging dynamics that defines the final outcomes of biological encounters becomes in essence a stochastic process (e.g. searches in landscapes
with low density of food sites).

In the absence of prey, the environment signals that prey is scarce, and in such conditions the optimal search strategy would be a Levy walk instead of brownian (#viswanathan1999optimizing).
*My recordings allow for the examination on whether search strategies are modified in the presence and absernce of prey, and how experience of prey may modify these behaviours.*
I find that prey scarcity can modify larval general motion patterns in an adaptive manner such that larger areas are searched, yet prior experience of prey can strongly affect this behaviour.

The concept of a characteristic scale is used extensively in statistical physics for describing macroscopic behavior of physical systems. 
In Levy walks/flights the step lengths (ie straight path lengths) are said tp have no characteristic scale, because they are power-law distributed.


In (#humphries2010environmental) it shown that searching animals adaptively adjust their optimal patterns of movement to different environmental resource distributions. 
It remains uknwown, however, whether the motions patterns arose as due to adaptive behaviour or whether observed patterns were an emergent property of the spatial distribution of prey (#sims2008scaling)

>What is the most efficient strategy to adopt while searching for randomly placed sites whose
locations are not apriori known for situations when the searcher has information only about
its close vicinity? (see  E P Raposo et al 2009)

  - Are these larvae executing Levy walks?

>From an evolutionary perspective, it is certainly pertinent to ask if efficient encounter rates are driven from selective pressures that systematically force organism adaption toward some optimal (or sub-optimal) solution.

Here use prior prey experience can alter the foraging search patterns in the scarcity and abundance of prey, to test wether changes in search patterns can be are adaptive, and not simply a result of interacting with dense prey environments. Thus if prior expectations on abandunce of prey  can modify motion, then changes in search patterns can be shown to be adaptive.
Thus we explore whether animals evolved to exploit experience in their search patterns, and whether they can use optimal search strategies such as Levy flights/walks when prey is scarce.

 I need to understand what changes in these walks, in terms of step length -
 Generally the LF group shows a bimodal distribution of path length  and an increase in the overall path length. which could be indicative of increased number of re-orientations. There is also a decrease in path-length between spontaneous and evoked conditions (most evident in LF )



# Analysis of larval trajectories 

## Examine dispersion to reveal foraging state as in Marquez et al. 2019

5s window measure radius encompassing trajectory

```{r setup, message=FALSE, cache=FALSE, results='hide', echo=FALSE, warning=FALSE}
## Init  Code 
library(rjags)
library(runjags)
library('coda')
message("Jags version: ",jags.version())
message(" For info in runjags check out:doi: 10.18637/jss.v071.i09")

setwd("/home/kostasl/workspace/zebrafishtrack/Rplots")
#setwd(here())
source("config_lib.R")
source("TrajectoryAnalysis.r")
source("HuntingEventAnalysis_lib.r")

setEnvFileLocations("HOME") #HOME,OFFICE,#LAPTOP
## To compile to different destination run:
# rmarkdown::render("ForagingStateAnalysis.Rmd",output_dir = paste0(strDataExportDir,'../foragingAnalysis') )


tsec_timeWindow <- 0 
thres_dispersion_class <- 0.2
##Clustering
Nclust <- 2
nsubsampleInterval <- G_APPROXFPS/2
vGroups <- c("LL","LE","NL","NE","DL","DE")
## Load datAllFrames
loaddatAllFrames <- function(forceReload = FALSE)
{
  if (!exists("datAllFrames") | forceReload)
  {
    attach(paste(strDatDir,"datAllFramesFix1_Ds-5-19.RData",sep="/"))
    attach(paste(strDatDir,"groupsrcdatListPerDataSet_Ds-5-19.RData",sep="/"))
  }
}


#Original Dispersion Record per frame
#datDispersion = readRDS(file=paste0(strDataExportDir,"/foragingState_Dispersion",tsec_timeWindow,"sec.rds") )
## Extended Dispersion Merged With maxDispersion Data
# Param tsec_timeWindow=0 default value loads pathstat calculated over the full event length - Not Confined to moving Time Window of X sec
loadDispersionData <- function(forceReload = FALSE,tsec_timeWindow=0)
{
  try(
    ##Check If Already Loaded
    if (!exists("datDispersion") | forceReload)
      datDispersion <<- readRDS(file=paste0(strDataStore,"/foragingState_Dispersion",tsec_timeWindow,"sec.rds") ) 
  )
  
  if (!exists("datDispersion"))
  {
    message("Calculate Trajectory Dispersions")
    loaddatAllFrames()
    datDispersion <<- calcTrajectoryDispersions(datAllFrames,tsec_timeWindow)
  }
  AllRange <<- range(datDispersion$Dispersion,na.rm=TRUE)
  tsec_timeWindow <<- tsec_timeWindow ##Change Global Ref to Last Call
  return(datDispersion)
}

## PathStat Data Merged onto Hunt Event based on initiation frame
loadHuntEventMergedWithPathStat <- function(tsec_timeWindow)
{
  
  datHEventDispersion <- data.frame()
  strFile <- paste0(strDataStore,"/huntEvent_mergedwith_Dispersion",tsec_timeWindow,"sec.rds")
  
  if (file.exists(strFile))
  {
    message("Loading from :",strFile )
  try(
    datHEventDispersion <- readRDS(file=strFile )
    )
  }else
  {
    message("Merged Data not generated yet ",strFile )
  }
  
## If we have not merged these records before, make them now
  if (!exists("datHEventDispersion") | !file.exists(strFile))
  { 
    loaddatAllFrames()
    datDispersion <- loadDispersionData_norm(tsec_timeWindow)
    datHuntLabelledEventsSBMerged_fixed <- getLabelledHuntEventsSet() # readRDS(file=paste(strDatDir,"/LabelledSet/",strProcDataFileName,".rds",sep="" ))
    datHEventDispersion <- mergeDispersionOntoHuntEvents(datDispersion,datAllFrames,datHuntLabelledEventsSBMerged_fixed)
  }
  
  return(datHEventDispersion)
}

## Check list of foragingStateDispersion files and return vector with the processed and available path-dispersion-msd Analysis timewindows 
getAvailablePathTimewindows <- function()
{
  
  # Check List of Available Calculated PathMeasure files  (Dispersion etc)
  # helper function : Convert WildCard to RegExp : glob2rx("foragingState_Dispersion???sec.rds", trim.head = FALSE, trim.tail = TRUE)
  lAvailableDispersionFiles <- dir(strDataStore, pattern = "foragingState_Dispersion[0-9]{1,3}sec.rds", full.names = FALSE, ignore.case = TRUE)
  vAvailabletimeWindows <- lapply( lAvailableDispersionFiles,FUN = function(s){  gsub(pattern = "[^0-9]", replacement = "", x = s)  }  )
  #Order them and Converr to Number
  vtimeWindows <- as.integer(unlist(vAvailabletimeWindows[order(as.integer(unlist(vAvailabletimeWindows)))] ) )
  message("Available timewindows:",paste(vAvailabletimeWindows,collapse=","))

  return (vtimeWindows)
}


##Re Run All Path Calculation 
generate_DispersionFiles <- function()
{
  ##Generate Files From Start 
  loaddatAllFrames()
  for (tt in seq(2,6,2) )
    calcTrajectoryDispersions(datAllFrames,tsec_timeWindow)
}


```

```{r merge max larval-dispersion onto dispersion data events, echo=FALSE,cache=FALSE,results=FALSE,warning=FALSE}
## Attaches the max Dispersion found between both evoked and spontaneous trajectories of each larva
## This is used so we can combine S/E larval recordings to detect both exploration/ exploitation state - and normalize appropriatelly to the joined trajectrories between tests as if they were ## one 20min recording  
mergeRangeOfLarvalDispersionPerLarvaOntoDispersion <- function(datDispersion,datExpPairs,tsec_timeWindow)
{
    ## Merge Max Dispersion per larva Onto Dispersion data (so we can normalize on a per larva basis instead of experiment basis)
  ## Calc Normalization to Max Dispersion by combining both Spont And Exoked cond per larva
  ## Find Max Dispersion Per Experiement
  datDispersionMax <- data.frame(tapply(datDispersion$Dispersion,datDispersion$expID,max,na.rm = TRUE))
  datDispersionMin <- data.frame(tapply(datDispersion$Dispersion,datDispersion$expID,min,na.rm = TRUE))
  
  ## pair each experiemnt with its max dispersion between Spontaneous and Evoked conditions of a larva
  ## We use this struct to merge with Dispersion data of each frame / So as to normalize approprietelly
  datDispesionRange_Pairs <-  rbind.data.frame(
                                           cbind.data.frame(
                                             expID = as.character(datExpPairs$expID.S) ,
                                             groupID = as.character(datExpPairs$groupID.S),
                                              max_exp_Disp = datDispersionMax[as.character(datExpPairs$expID.S),],
                                              max_exp_Disp.C = datDispersionMax[as.character(datExpPairs$expID.E),],
                                              min_exp_Disp = datDispersionMin[as.character(datExpPairs$expID.S),],
                                              min_exp_Disp.C = datDispersionMin[as.character(datExpPairs$expID.E),]),
                                           cbind.data.frame(
                                                expID = as.character(datExpPairs$expID.E) ,
                                                groupID = as.character(datExpPairs$groupID.E),
                                                max_exp_Disp = datDispersionMax[as.character(datExpPairs$expID.E),],
                                                max_exp_Disp.C = datDispersionMax[as.character(datExpPairs$expID.S),],
                                                min_exp_Disp = datDispersionMin[as.character(datExpPairs$expID.E),],
                                                min_exp_Disp.C = datDispersionMin[as.character(datExpPairs$expID.S),])
                                            )
                                      
                                          
  ## Add col for Max/min Dispersion across Spont and Evoked conditions
  datDispesionRange_Pairs$max <- as.numeric(apply(datDispesionRange_Pairs[,3:4], 1, max,na.rm=TRUE)) 
  datDispesionRange_Pairs$min <- as.numeric(apply(datDispesionRange_Pairs[,5:6], 1, min,na.rm=TRUE)) 
  
  ##Make Simple frame for merging with dispersion data
  datMaxDispersionPerLarva <- cbind.data.frame(expID=as.character(datDispesionRange_Pairs$expID),
                                               groupID=as.character(datDispesionRange_Pairs$groupID),
                                               max_larval_Dispersion=(datDispesionRange_Pairs$max),
                                               min_larval_Dispersion=(datDispesionRange_Pairs$min),
                                               max_exp_Dispersion=(datDispesionRange_Pairs$max_exp_Disp), # Add The max Disp Recorded for this larva
                                               min_exp_Dispersion=(datDispesionRange_Pairs$min_exp_Disp) # Add The max Disp Recorded for this larva
                                               )
  datDispersionM <- merge(datDispersion,datMaxDispersionPerLarva,all.x = TRUE,by=c("expID","groupID"),no.dups=FALSE)

  #Calculate Range Normalized dispersion per larva - to match Marquez et al 2019
  ## Save  dispersion data normalized across Spont and evoked condition for each larva (saves time in future plotting)
  datDispersionM <- cbind.data.frame(datDispersionM,
                                     Dispersion_larval_norm=(datDispersionM$Dispersion-datDispersionM$min_larval_Dispersion) / (datDispersionM$max_larval_Dispersion-datDispersionM$min_larval_Dispersion) )

  ## Now Merge onto Dispersion Data 
  saveRDS(datDispersionM,file=paste0(strDataExportDir,"/foragingState_Dispersion_merged_rangeperLarva_",tsec_timeWindow,"sec.rds") )
  saveRDS(datMaxDispersionPerLarva,file=paste0(strDataExportDir,"/foragingState_max_Dispersion_perLarva_",tsec_timeWindow,"sec.rds") )
  message("Saved to:",paste0(strDataExportDir,"/foragingState_Dispersion_merged_rangeperLarva_",tsec_timeWindow,"sec.rds") )
  message("Saved to:",paste0(strDataExportDir,"/foragingState_max_Dispersion_perLarva_",tsec_timeWindow,"sec.rds") )

  return(datDispersionM)
}
```



```{r  merge hunt-events with dispersion data, fig.show="hold", out.width="50%", echo=FALSE, cache=FALSE,results=FALSE,message=FALSE,warning=FALSE }
source("DataLabelling/labelHuntEvents_lib.r")
source("HuntingEventAnalysis_lib.r")
  

#load(file=paste(strDatDir,"/LabelledSet/",strProcDataFileName,".RData",sep="" )) ##Save With Dataset Idx Identifier
datHuntLabelledEventsSBMerged_fixed <- getLabelledHuntEventsSet() # readRDS(file=paste(strDatDir,"/LabelledSet/",strProcDataFileName,".rds",sep="" ))

##Clear Warningss : assign("last.warning", NULL, envir = baseenv()
## Link Evoked and Spontaneous Trajectories
datHuntStat <- makeHuntStat(datHuntLabelledEventsSBMerged_fixed)
datExpPairs <- getSpontaneousEvokedExperimentPairs(datHuntStat)
datHEventDispersion <<- loadHuntEventMergedWithPathStat(5)


#loadDispersionData(forceReload = TRUE,tsec_timeWindow = 0)
##Load Dispersion Data, check if data.frame has been extended with larva ranges, and merge if need to  have been added - 
loadDispersionData_norm <- function(tsec_timeWindow)
{
  
  try(rm("datDispersion"),silent=TRUE);
  strFile <- paste0(strDataExportDir,"foragingState_Dispersion_merged_rangeperLarva_",tsec_timeWindow,"sec.rds")
  if (file.exists(strFile))
  {
  try( {
    
    message("Loading ",strFile);
    datDispersion <<- readRDS(file=strFile ) ;
    }
    )
  }else
    message("No Dispersion data file found: ", strFile,"Attempting to generate now ...")
  ##If the Merged Version is not found then Make one
  if (!exists("datDispersion") | !file.exists(strFile))
  {
    datDispersion <- loadDispersionData(forceReload = TRUE,tsec_timeWindow)
  }
    ## Merge Max Dispersion on there - If it is not already there then Calculate and save 
  if (!any(grepl("max_larval_Dispersion",names(datDispersion)) ) | 
      !any(grepl("min_larval_Dispersion",names(datDispersion)) ) |
      !any(grepl("Dispersion_larval_norm", names(datDispersion)) )  )
    datDispersion <<- mergeRangeOfLarvalDispersionPerLarvaOntoDispersion(datDispersion,datExpPairs,tsec_timeWindow)
  
  return(datDispersion)
}

loadDispersionData_norm(tsec_timeWindow)
## Check for max Calc Error
#datDispersion[datDispersion$Dispersion > datDispersion$max_Dispersion,]
```


```{r plot-trajectories-figures-function, fig.show="hold", out.width="50%", echo=FALSE ,results=FALSE,ref.label='setup',warning=FALSE}
#Function to plot trajectories for each larva coloured based on dispersion
pairedTrajPalette <- col2hex(col2rgb(brewer.pal(12,"Paired"),alpha = 1))

#
# Function Plot Individual Trajectories for a group, split between exploration and exploitation
# given a *global* normalized dispersion measures threshold 
#
plotGlobalNormDispersionTrajectories <- function(groupID, datAllFrames, datDispersion, datHEventDispersion,datExpPairs,TH_DISP = 0.2)
{
  
  datGroupExploreTraj <- datAllFrames[datDispersion[datDispersion$groupID %in% groupID & datDispersion$Dispersion/AllRange[2] >= TH_DISP,"frameRow"],]
  datGroupExploitTraj <- datAllFrames[datDispersion[datDispersion$groupID %in% groupID & datDispersion$Dispersion/AllRange[2] < TH_DISP ,"frameRow"],]
  
  ## ind Exploration Hunt Events 
  datExplorationHuntEvents <- datHEventDispersion[datHEventDispersion$Dispersion/AllRange[2] >= TH_DISP, ]
  ## ind Exploration Hunt Events 
  datExploitationHuntEvents <- datHEventDispersion[datHEventDispersion$Dispersion/AllRange[2] < TH_DISP, ]
  
  
  plotExploreExploitTrajectories(groupID,datGroupExploreTraj,datGroupExploitTraj, datExplorationHuntEvents, 
                                 datExploitationHuntEvents,datDispersion,
                                 datExpPairs[datExpPairs$groupID.E %in%  groupID | datExpPairs$groupID.S %in%  groupID, ]) ##Subset to Targeted groups
  
} ## end of plot Function
 
##
# Function Plot Individual Trajectories for a group, split between exploration and exploitation
# given a *local* normalized dispersion measures threshold / the classification is relative to the mobility measure of each larvae in each condition 
##
plotExpNormDispersionTrajectories <- function(groupID, datAllFrames, datDispersion,datHEventDispersion, datExpPairs,TH_DISP = 0.2)
{

  datGroupExploreTraj <- datAllFrames[datDispersion[datDispersion$groupID %in% groupID & datDispersion$Dispersion_norm >= TH_DISP,"frameRow"],]
  datGroupExploitTraj <- datAllFrames[datDispersion[datDispersion$groupID %in% groupID & datDispersion$Dispersion_norm <  TH_DISP,"frameRow"],]
   
  ## \TODO: Norm per larva in both spont and Evoked
  ## ind Exploration Hunt Events 
  datExplorationHuntEvents <- datHEventDispersion[datHEventDispersion$Dispersion_norm >= TH_DISP, ]
  
  ## ind Exploration Hunt Events 
  datExploitationHuntEvents <- datHEventDispersion[datHEventDispersion$Dispersion_norm < TH_DISP, ]
  
  ## Call Plot Function - Both Spont And Evoked plo tted on same figure
  plotExploreExploitTrajectories(groupID,datGroupExploreTraj,datGroupExploitTraj, datExplorationHuntEvents, 
                                 datExploitationHuntEvents,datDispersion,
                                 datExpPairs[datExpPairs$groupID.E %in%  groupID | datExpPairs$groupID.S %in%  groupID, ]) ##Subset to Targeted groups
  
} ## end of plot Functon


## TODO: plot NB Mix clustered traj
# Function Plot Individual Trajectories for a group, split between exploration and exploitation
# given based on threshold placed on the normalized dispersion of the trajectories from combined spont and evoked conditions of each larva .
##
plotNBMixGClusteredDispersionTrajectories <- function(groupID, datAllFrames, datDispersion, datHEventDispersion,datExpPairs,TH_DISP = 0.2)
{ 
  #load(file=paste0(strDataExportDir,'jagsModelTestResults_NBMixGroupclustDispersion_All.RData') )
  #datHEventDispersion <<- readRDS(file=paste0(strDataExportDir,"/huntEvent_mergedwith_Dispersion",tsec_timeWindow,"sec.rds") )
  datHEventDispersion <<- loadHuntEventMergedWithPathStat(5)
  ## Merge sparse Clustered Dispersions Results onto full Dispersion Data
  lparamsAll <- getMCMCNBGroupEstimatedParams(results.All,"All",2)
  if (!("clustID" %in% names(datSubDispersion)))
    datSubDispersion$clustID <- as.vector(lparamsAll$clustID)
  
  ##Add Clust ID on all Dispersion Data - interpolating the sparse   datSubDispersion
  datDispersion$clustID <- NA
  datDispersion[datSubDispersion$frameRow,"clustID"] <- datSubDispersion$clustID
  ##Fill in the gaps with the last value
  lastClustID <- NA
  idxA <- 1:NROW(datDispersion)
  for (i in 1:nsubsampleInterval )
  {
      datDispersion[idxA+i,"clustID"] <- datDispersion[idxA,"clustID"]
  }
    
  ##Merge Cluster ID onto Hunt Events
  datHEventDispersion <- merge(datHEventDispersion, cbind.data.frame (frameRow=datSubDispersion$frameRow,
                                                          #expID=datSubDispersion$expID,
                                                          #groupID=datSubDispersion$expID,
                                                          clustID=as.numeric(datSubDispersion$clustID) ),
                               by=c("frameRow"),all.x =TRUE,no.dups = FALSE)

  
  
  datGroupExploreTraj <- datAllFrames[datDispersion[datSubDispersion$groupID %in% groupID & datDispersion$clustID == 1,"frameRow"],]
  datGroupExploitTraj <- datAllFrames[datDispersion[datSubDispersion$groupID %in% groupID & datDispersion$clustID == 2,"frameRow"],]
  
  ## ind Exploration Hunt Events 
  datExplorationHuntEvents <- datHEventDispersion[datHEventDispersion$clustID == 1, ]
  ## ind Exploration Hunt Events 
  datExploitationHuntEvents <- datHEventDispersion[datHEventDispersion$clustID ==2, ]
  
  
  plotExploreExploitTrajectories(groupID,datGroupExploreTraj,datGroupExploitTraj, datExplorationHuntEvents, 
                                 datExploitationHuntEvents,datDispersion,
                                 datExpPairs[datExpPairs$groupID.E %in%  groupID | datExpPairs$groupID.S %in%  groupID, ],thin=5) ##Subset to Targeted groups
  
} ##

##
# Function Plot Individual Trajectories for a group, split between exploration and exploitation
# given based on threshold placed on the normalized dispersion of the trajectories from combined spont and evoked conditions of each larva .
##
plotLarvaNormDispersionTrajectories <- function(groupID, datAllFrames, datDispersion, datHEventDispersion,datExpPairs,TH_DISP = 0.2)
{ 
  datGroupExploreTraj <- datAllFrames[datDispersion[datDispersion$groupID %in% groupID & datDispersion$Dispersion_larval_norm >= TH_DISP,"frameRow"],]
  datGroupExploitTraj <- datAllFrames[datDispersion[datDispersion$groupID %in% groupID & datDispersion$Dispersion_larval_norm < TH_DISP,"frameRow"],]
  
  ## ind Exploration Hunt Events 
  datExplorationHuntEvents <- datHEventDispersion[datHEventDispersion$Dispersion_larval_norm >= TH_DISP, ]
  ## ind Exploration Hunt Events 
  datExploitationHuntEvents <- datHEventDispersion[datHEventDispersion$Dispersion_larval_norm < TH_DISP, ]
  
  
  plotExploreExploitTrajectories(groupID,datGroupExploreTraj,datGroupExploitTraj, datExplorationHuntEvents, 
                                 datExploitationHuntEvents,datDispersion,
                                 datExpPairs[datExpPairs$groupID.E %in%  groupID | datExpPairs$groupID.S %in%  groupID, ]) ##Subset to Targeted groups
  
} ##


## Plot function for scatter plot of colour coded larval trajectories, separated into explore and exploit vectors
## with Both Spont And Evoked plotted on same figure
###  datExpPairs - expID for Spont and Evoked for each larva
plotExploreExploitTrajectories <- function(groupID,datGroupExploreTraj,datGroupExploitTraj, datExplorationHuntEvents, datExploitationHuntEvents, datDispersion, datExpPairs, thin=3,TH_DISP = 0.2)
{
  
  #vexpID <-  unique(datGroupExploitTraj$exp) 
  #par(mfrow=c(2,NROW(vexpID))) ##MultiPlot Page
  #par(mar=c(1,1,1,1))
  #layout(matrix(seq(1,NROW(vexpID)), 2,NROW(vexpID) , byrow = TRUE))
  i <- 0
  for (j in 1:nrow(datExpPairs) )
  {
      e <- datExpPairs[j,]
      if (is.na(e$expID.E))
        next()
      x1  <- seq(0, 640 )
      y1  <- seq(0, 550 )

      #print(e)
      plot(0,0,ylim=range(y1),xlim=range(x1), type="l", col="red", main=paste(groupID[1],e$expID.E,"/",groupID[2],e$expID.S) )
      ## Evoked Exploration
      datTraj <- datGroupExploreTraj[datGroupExploreTraj$expID == as.character(e$expID.E) & !is.na(datGroupExploreTraj$posX),]
      if (NROW(datTraj))
      {
        idxplot <- seq(1,NROW(datTraj),thin)
        points(datTraj[idxplot,]$posX,datTraj[idxplot,]$posY,type="p", col=pairedTrajPalette[1], cex=0.1);
      }
      ## Add Hunt Events on Map
      # Evoked Exploration
      datSpotHunts.E.Explore <- datExplorationHuntEvents[datExplorationHuntEvents$expID == as.character(e$expID.E)  & !is.na(datExplorationHuntEvents$expID), ] 
      points(datSpotHunts.E.Explore$posX, datSpotHunts.E.Explore$posY, col=pairedTrajPalette[2], cex=1.2, pch=17) ## Triangle Explore
  
      ## Spontaneous Explore
      datTraj <- datGroupExploreTraj[datGroupExploreTraj$expID == as.character(e$expID.S) & !is.na(datGroupExploreTraj$posX),]
      if (NROW(datTraj))
      {
        idxplot <- seq(1,NROW(datTraj),thin)
        points(datTraj[idxplot,]$posX,datTraj[idxplot,]$posY,type="p", col=pairedTrajPalette[3], cex=0.1);
      }
      ## Spont Exploration
      datSpotHunts.S.Explore <- datExplorationHuntEvents[datExplorationHuntEvents$expID == as.character(e$expID.S)  & !is.na(datExplorationHuntEvents$expID), ] 
      points(datSpotHunts.S.Explore$posX, datSpotHunts.S.Explore$posY, col=pairedTrajPalette[4], cex=1.2, pch=17) ##  Triangle Explore
  
      
      ## Evoked Exploit
      datTraj <- datGroupExploitTraj[datGroupExploitTraj$expID == as.character(e$expID.E) & !is.na(datGroupExploitTraj$posX),]
      if (NROW(datTraj))
      {      
        idxplot <- seq(1,NROW(datTraj),thin)
        points(datTraj[idxplot,]$posX,datTraj[idxplot,]$posY,type="p",col=pairedTrajPalette[5], cex=0.1)
      }
      ## Evoked Exploitation
      datSpotHunts.E.Exploit <- datExploitationHuntEvents[datExploitationHuntEvents$expID == as.character(e$expID.E)  & !is.na(datExploitationHuntEvents$expID), ] 
      points(datSpotHunts.E.Exploit$posX, datSpotHunts.E.Exploit$posY,col=pairedTrajPalette[6], cex=1.2,pch=15) ## Square Evoked


      ## Spontaneous Exploit
      datTraj <- datGroupExploitTraj[datGroupExploitTraj$expID == as.character(e$expID.S) & !is.na(datGroupExploitTraj$posX),]
      if (NROW(datTraj))
      { 
        idxplot <- seq(1,NROW(datTraj),thin)
        points(datTraj[idxplot,]$posX,datTraj[idxplot,]$posY,type="p",col=pairedTrajPalette[7], cex=0.1)
      }
      ## Hunt Episodes Spont Exploitation
      datSpotHunts.S.Exploit <- datExploitationHuntEvents[datExploitationHuntEvents$expID == as.character(e$expID.S)  & !is.na(datExploitationHuntEvents$expID), ] 
      points(datSpotHunts.S.Exploit$posX, datSpotHunts.S.Exploit$posY,col=pairedTrajPalette[8], cex=1.2,pch=15) ## Square Evoked
  
      
      badd <- TRUE
      ## Add dispersion Time Line + Hunt Events + Norm threshold Threshold
      datDisp.S <- datDispersion[datDispersion$expID == as.character(e$expID.S) ,]
      datDisp.E <- datDispersion[datDispersion$expID == as.character(e$expID.E) ,]
      ## Sort by frameRo
      datDisp.S <- datDisp.S[order( as.numeric(datDisp.S$frameRow) ), ]
      datDisp.E <- datDisp.E[order( as.numeric(datDisp.E$frameRow) ), ]
            
      idxplot.S <- seq(min(1,NROW(datDisp.S)),max(1,NROW(datDisp.S)),thin)
      idxplot.E <- seq(min(1,NROW(datDisp.S)),max(1,NROW(datDisp.E)) ,thin)
      datDisp.S.frame <- as.numeric(datDisp.S[idxplot.S,]$frameRow)- min((as.numeric(datDisp.S[idxplot.S,]$frameRow) ),na.rm = TRUE ) #datAllFrames[datDisp.S[idxplot.S,]$frameRow,"frameN" ]
      datDisp.E.frame <- max(datDisp.S.frame,na.rm=TRUE) +  as.numeric(datDisp.E[idxplot.E,]$frameRow)-min(c(as.numeric(datDisp.E[idxplot.E,]$frameRow) ),na.rm = TRUE ) 
      
      ##frameN restarts to 0 for each event so best use frameRow
      plot(datDisp.S.frame/G_APPROXFPS ,datDisp.S[idxplot.S,]$Dispersion,type="l" ,ylim=c(0,10),xlim=c(0,max(c(0,datDisp.E.frame),na.rm =TRUE)/G_APPROXFPS ),xlab="(sec)",
           ylab="Dispersal (mm)", col=colourDataScheme[[ as.character(e$groupID.S)  ]] )
      lines(datDisp.E.frame/G_APPROXFPS, datDisp.E[idxplot.E,]$Dispersion,type="l", col=colourDataScheme[[ as.character(e$groupID.E)  ]] )
      
      ##All Hunt larva hunt events together
      datSpotHunts.S <- rbind(datSpotHunts.S.Exploit,datSpotHunts.S.Explore)
      datSpotHunts.E <- rbind(datSpotHunts.E.Exploit,datSpotHunts.E.Explore)  
      
      ##Add Hunt Event ##datDisp.S[datDisp.S$frameRow == datSpotHunts.S$frameRow,]$Dispersion <- fails cause Disp data may be missing at hunt event frame
      ## Use FrameRow As timepoint sequence - reset to 0 using min(frameRow) for event, and attach Evoked to the back of spontaneous
      points( (as.numeric(datSpotHunts.S$frameRow)-min(as.numeric(datDisp.S[idxplot.S,]$frameRow),na.rm=TRUE ) )/G_APPROXFPS, rep(-0.1,times=NROW(datSpotHunts.S$frameN)), cex=1, pch=17)
      points( (max(idxplot.S) +  as.numeric(datSpotHunts.E$frameRow)-min(as.numeric(datSpotHunts.E$frameRow)))/G_APPROXFPS, rep(-0.1,times=NROW(datSpotHunts.E$frameN)) ,cex=1,pch=17)
      ##Show Larval Norm Threshold - Draw line
      thres_Dispersion_mm <- min((datDisp.E[datDisp.E$Dispersion_larval_norm >= TH_DISP, ] $Dispersion),na.rm=TRUE )
      segments(0,thres_Dispersion_mm, max(datDisp.E.frame,na.rm=TRUE)/G_APPROXFPS,
               thres_Dispersion_mm,lty=3)
      
      
      #stopifnot(i < 5)
      i <- i+1
  } ## For Each Event
    
}## End of Function 


```



## Detect Exploration -Exploitation via dispersion
 
 In Marquez et al. 2019 Ext Fig 3a, the dispersion of each larva is normalized against its own range before the overall (bimodal) distribution is shown.
 The normalized dispersion distributions  of each larva are used to detect the threshold that separates the exploitation and exploration state.  
 They report (Extended Data Fig. 3a), substantially higher dispersal in the exploration state (9.6 ± 2.5 mm, mean ± s.d., n = 36 animals) than in the exploitation state (2.3 ± 1.3 mm, n = 36 animals).

 Using my tracking data I calculated the dispersion at each tracked video frame and plot the distribution to examine if they are bimodal (here using the `r tsec_timeWindow` seconds window).
However, my tracking of each larva is limited to 10 min, and includes only the centre of the arena, but in Marquez et al. 2019 each larva is recorded *for 50-80 min*, while the mean duration of each state is reported to be on average, the *exploitation state persists for 7.1 ± 3.9 min*, and *exploration state persists for 5.5 ± 6.2 min*
(mean ± s.d., n = 36 animals). The duration of each state follows an exponential distribution (λ = 0.17 min−1
for exploitation, λ = 0.22 min−1 for exploration, pooled distribution of n = 36 animals) see (raw data shown on Ext. Fig 7a).

Unfortunatelly with my 10 min recordings for each larvae, it is most likely that I will not observe their behaviour in both states, but likely only observe them in on of these states. This is added ontop the fact that I do not record around the edges of the arena, as they do to see them run around.
Therefore, normalizing and setting a threshold on a per larva basis may not be a good idea.
Perhaps it is best I combine the trajectories of spontaneous and evoked activity for each larva so as to obtain 20min of observation time. 

 Without normalizing the distribution is shown on the left, and a version normalized per max dispersion measured in each experiment is on the right :
 
```{r dispersion histograms across groups, fig.show="hold", out.width="33%", echo=FALSE, results='hide'  }
loadDispersionData()

hist(datDispersion$Dispersion,breaks=50,main="(All groups): Dispersion lengths per experiment ",xlab="Dispersion (mm)")
hist(datDispersion$Dispersion_norm,breaks=50,main="(All groups): Dispersion normalized",xlab="Dispersion (exp. norm)")
hist(datDispersion$Dispersion_larval_norm ,breaks=50,main="(All groups): Dispersion normalized per larva",xlab="Dispersion (larva norm)")


```
We look at each rearing group separatelly, while combining their evoked and spontaneous conditions

```{r dispersion histograms per group across conditions, fig.show="hold", out.width="33%", echo=FALSE, results='hide'  }
hist(datDispersion[datDispersion$groupID %in% c('LE','LL'), ]$Dispersion,breaks=50,main="LF Evoked+Spont.",xlab="Dispersion (mm)",col=colourDataScheme$LF$Evoked)
hist(datDispersion[datDispersion$groupID %in% c('NE','NL'), ]$Dispersion,breaks=50,main="NF Evoked+Spont.",xlab="Dispersion (mm)",col=colourDataScheme$NF$Evoked)
hist(datDispersion[datDispersion$groupID %in% c('DE','DL'), ]$Dispersion,breaks=50,main="DF Evoked+Spont.",xlab="Dispersion (mm)",col=colourDataScheme$DF$Evoked)

```


We then plot each experimental group individually, also examining the dispersion in evoked (in the presence of prey) and spontaneous (no prey) conditions separatellly.
Next we plot these for each experimental condition individually (non-Normalized):
```{r dispersion histograms per group per condition, fig.show="hold", out.width="33%", echo=FALSE, results='hide'  }
# 
# ## Normed over all Recorded Dispersions
 hist(datDispersion[datDispersion$groupID == 'LE', ]$Dispersion,breaks=100,main="LF Spontaneous",xlab="Dispersion (mm)",col=colourDataScheme$LF$Spont)
 hist(datDispersion[datDispersion$groupID == 'NE', ]$Dispersion,breaks=100,main="NF Spontaneous",xlab="Dispersion (mm)",col=colourDataScheme$NF$Spont)
 hist(datDispersion[datDispersion$groupID == 'DE', ]$Dispersion,breaks=100,main="DF Spontaneous",xlab="Dispersion (mm)",col=colourDataScheme$DF$Spont)

 hist(datDispersion[datDispersion$groupID == 'LL', ]$Dispersion,breaks=100,main="LF Evoked",xlab="Dispersion (mm)",col=colourDataScheme$LF$Evoked)
 hist(datDispersion[datDispersion$groupID == 'NL', ]$Dispersion,breaks=100,main="NF Evoked",xlab="Dispersion (mm)",col=colourDataScheme$NF$Evoked)
 hist(datDispersion[datDispersion$groupID == 'DL', ]$Dispersion,breaks=100,main="DF Evoked",xlab="Dispersion (mm)",col=colourDataScheme$DF$Evoked)
```
 
Smooth estimates using a gaussian kernel show a shift towards exploitation for the pooled *LF* trajectories, measured across the whole event duration (at 1sec intervals):

```{r dispersion densities WholePath per larva-Split E-S, fig.show="hold", out.width="33%", echo=FALSE, results='hide' }
loadDispersionData(TRUE, tsec_timeWindow = 0)
 ## plot est, Densities Compare Spont to Evoked
 BW=0.2
 plot(density(datDispersion[datDispersion$groupID == 'NE', ]$Dispersion, kernel="gaussian",na.rm=TRUE, bw=BW), lwd=4, ylim=c(0,0.7), col=colourDataScheme$NF$Spont,main="NF  ",xlab="Full path Dispersion (mm)",lty=1  )
 lines(density(datDispersion[datDispersion$groupID == 'NL', ]$Dispersion,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$NF$Evoked,main=NA,lty=2)
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$NF$Spont,colourDataScheme$NF$Evoked),lwd=3 ) 
 
  plot(density(datDispersion[datDispersion$groupID == 'LE', ]$Dispersion, kernel="gaussian",na.rm=TRUE,bw=BW), lwd=4, ylim=c(0,0.7),col=colourDataScheme$LF$Spont,main="LF  ",xlab="Full path dispersion (mm)",lty=1 )
 lines(density(datDispersion[datDispersion$groupID == 'LL', ]$Dispersion,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$LF$Evoked,main=NA,lty=2 )
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$LF$Spont,colourDataScheme$LF$Evoked),lwd=3 ) 

 plot(density(datDispersion[datDispersion$groupID == 'DE', ]$Dispersion, kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4, ylim=c(0,0.7),col=colourDataScheme$DF$Spont,main="DF  ",xlab="Full path dispersion (mm)",lty=1 )
 lines(density(datDispersion[datDispersion$groupID == 'DL', ]$Dispersion,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$DF$Evoked,main=NA,lty=2 )
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$DF$Spont,colourDataScheme$DF$Evoked),lwd=3 ) 

```
These look rather uniform across all groups. But if we examine the dispersion generated over a particular duration time-window, here 20 sec :


```{r dispersion densities 20sec Path per larva-Split E-S, fig.show="hold", out.width="33%", echo=FALSE, results='hide' }
loadDispersionData(TRUE, tsec_timeWindow = 20)
 ## plot est, Densities Compare Spont to Evoked
 BW=0.2
 plot(density(datDispersion[datDispersion$groupID == 'NE', ]$Dispersion, kernel="gaussian",na.rm=TRUE, bw=BW), lwd=4, ylim=c(0,0.7), col=colourDataScheme$NF$Spont,main="NF  ",xlab="20sec path dispersion (mm)",lty=1  )
 lines(density(datDispersion[datDispersion$groupID == 'NL', ]$Dispersion,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$NF$Evoked,main=NA,lty=2)
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$NF$Spont,colourDataScheme$NF$Evoked),lwd=3 ) 
 
  plot(density(datDispersion[datDispersion$groupID == 'LE', ]$Dispersion, kernel="gaussian",na.rm=TRUE,bw=BW), lwd=4, ylim=c(0,0.7),col=colourDataScheme$LF$Spont,main="LF  ",xlab="20sec path dispersion (mm)",lty=1 )
 lines(density(datDispersion[datDispersion$groupID == 'LL', ]$Dispersion,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$LF$Evoked,main=NA,lty=2 )
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$LF$Spont,colourDataScheme$LF$Evoked),lwd=3 ) 

 plot(density(datDispersion[datDispersion$groupID == 'DE', ]$Dispersion, kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4, ylim=c(0,0.7),col=colourDataScheme$DF$Spont,main="DF  ",xlab="20sec path dispersion (mm)",lty=1 )
 lines(density(datDispersion[datDispersion$groupID == 'DL', ]$Dispersion,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$DF$Evoked,main=NA,lty=2 )
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$DF$Spont,colourDataScheme$DF$Evoked),lwd=3 ) 

```
<!-- For completness, the following dispersions have been normalized to maximum trajectory dispersion found across all experiments (*global normalization*): -->
```{r plot globally normalized dispersion distributions, fig.show="hold", out.width="33%", echo=FALSE, results='hide',include=FALSE,eval=FALSE  }

# ## Normed over all Recorded Dispersions
 hist(datDispersion[datDispersion$groupID == 'LE', ]$Dispersion/AllRange[2],breaks=100,main="LF Spontaneous",xlab="Dispersion (global norm. )")
 hist(datDispersion[datDispersion$groupID == 'NE', ]$Dispersion/AllRange[2],breaks=100,main="NF Spontaneous",xlab="Dispersion (global norm. )")
 hist(datDispersion[datDispersion$groupID == 'DE', ]$Dispersion/AllRange[2],breaks=100,main="DF Spontaneous",xlab="Dispersion (global norm. )")

 hist(datDispersion[datDispersion$groupID == 'LL', ]$Dispersion/AllRange[2],breaks=100,main="LF Evoked",xlab="Dispersion (global norm. .)")
 hist(datDispersion[datDispersion$groupID == 'NL', ]$Dispersion/AllRange[2],breaks=100,main="NF Evoked",xlab="Dispersion (global norm. )")
 hist(datDispersion[datDispersion$groupID == 'DL', ]$Dispersion/AllRange[2],breaks=100,main="DF Evoked",xlab="Dispersion (global norm. )")
 
```

Here differences in LF having larger dispersion within the 20sec time-frame are evident, combined with the results of theprevious figures on dispersion over the whole path being uniform, these results imply **LF do not explore the ROI with higher dispersal, but they are quicker to disperse**.
*In the absence of prey, dispersions grow faster in LF and DF*.

### Normalized dispersion per experiment

Next, we examine the same dispesions normalized against the maximum dispersion calculated in the trajectory length of the respective experiment.
Each measured dispersion is divided by the max dispersion trajectory experiment,
(ie for each larva  this can be different in evoked or spontaneous conditions).

```{r plot normalized dispersion distributions, fig.show="hold", out.width="33%", echo=FALSE, results='hide' }
### Normed Per Larva
tsec_timeWindow <- 20
datDispersion <- loadDispersionData_norm(tsec_timeWindow)
strXLab <- paste(tsec_timeWindow,"sec Dispersion  (norm per exp.)")
hist(datDispersion[datDispersion$groupID == 'LE', ]$Dispersion_norm,breaks=50,main="LF Spontaneous",xlab=strXLab, col=colourDataScheme$LF$Spont)
hist(datDispersion[datDispersion$groupID == 'NE', ]$Dispersion_norm,breaks=50,main="NF Spontaneous",xlab=strXLab, col=colourDataScheme$NF$Spont)
hist(datDispersion[datDispersion$groupID == 'DE', ]$Dispersion_norm,breaks=50,main="DF Spontaneous",xlab=strXLab, col=colourDataScheme$DF$Spont)

hist(datDispersion[datDispersion$groupID == 'LL', ]$Dispersion_norm,breaks=50,main="LF Evoked",xlab=strXLab,col=colourDataScheme$LF$Evoked)
hist(datDispersion[datDispersion$groupID == 'NL', ]$Dispersion_norm,breaks=50,main="NF Evoked",xlab=strXLab,col=colourDataScheme$NF$Evoked)
hist(datDispersion[datDispersion$groupID == 'DL', ]$Dispersion_norm,breaks=50,main="DF Evoked",xlab=strXLab,col=colourDataScheme$DF$Evoked)

```

### Normalized dispersion per larva combined test conditions

Because each larva is recorded in two conditions, and as Marquez et al 2019 report that the foraging state switching can be seen intact both in the presence and in the absence of prey , we may then combine our spontaneous and evoked condition recordings and treat them as a single unit,  thus allowing us to  normalize each larvas trajectories to the max dispersion found across both its test conditions.  In this manner each larva's dispersion is examined across a 20min recording session.

```{r dispersion histogram normalized per larva, fig.show="hold", out.width="33%", echo=FALSE, results='hide' }
### Dispesions distributions Normalized on Per Larva basis - 
datDispersion <- loadDispersionData_norm(tsec_timeWindow)
hist(datDispersion[datDispersion$groupID %in% c('LE','LL'), ]$Dispersion_larval_norm, breaks=100,main="LF S+E ",xlab="Dispersion  (norm per larva)")
hist(datDispersion[datDispersion$groupID %in% c('NE','NL'), ]$Dispersion_larval_norm, breaks=100,main="NF S+E",xlab="Dispersion  (norm per larva)")
hist(datDispersion[datDispersion$groupID %in% c('DE','DL'), ]$Dispersion_larval_norm, breaks=100,main="DF S+E",xlab="Dispersion  (norm per larva)")

```

#### Histograms of normalized dispersion per larva, split S-E conditions 


Separating Spontaneous from Evoked Conditions we see a potential shift toward lower dispersion in the presence of prey:

```{r dispersion histogram normalized per larva-Split E-S, fig.show="hold", out.width="50%", echo=FALSE, results='hide' }
### Dispesions distributions Normalized on Per Larva basis - 

hist(datDispersion[datDispersion$groupID %in% c('LE'), ]$Dispersion_larval_norm, breaks=100,main="LF Spont ", xlab="Dispersion  (norm per larva)",col=colourDataScheme$LF$Spont)
hist(datDispersion[datDispersion$groupID %in% c('LL'), ]$Dispersion_larval_norm, breaks=100,main="LF Evoked ",xlab="Dispersion  (norm per larva)",col=colourDataScheme$LF$Evoked)

hist(datDispersion[datDispersion$groupID %in% c('NE'), ]$Dispersion_larval_norm, breaks=100,main="NF Spont ", xlab="Dispersion  (norm per larva)",col=colourDataScheme$NF$Spont)
hist(datDispersion[datDispersion$groupID %in% c('NL'), ]$Dispersion_larval_norm, breaks=100,main="NF Evoked ",xlab="Dispersion  (norm per larva)", col=colourDataScheme$NF$Evoked)

hist(datDispersion[datDispersion$groupID %in% c('DE'), ]$Dispersion_larval_norm, breaks=100,main="DF Spont ", xlab="Dispersion  (norm per larva)",col=colourDataScheme$DF$Spont)
hist(datDispersion[datDispersion$groupID %in% c('DL'), ]$Dispersion_larval_norm, breaks=100,main="DF Evoked ",xlab="Dispersion  (norm per larva)",col=colourDataScheme$DF$Evoked)
```



#### Density estimation normalized dispersion per larva - compare Evoked to Spontaneous

Next I estimated densities using a gaussian kernel, allowing direct comparison between test conditions shows LF dispersions are modified by the presence of prey.

```{r dispersion densities normalized per larva-Split E-S, fig.show="hold", out.width="33%", echo=FALSE, results='hide' }
 ## plot est, Densities Compare Spont to Evoked
 BW=0.01
 ylimUp <- 5
 plot(density(datDispersion[datDispersion$groupID == 'NE', ]$Dispersion_larval_norm, kernel="gaussian",na.rm=TRUE, bw=BW), lwd=4, ylim=c(0,ylimUp), col=colourDataScheme$NF$Spont,main="NF  ",xlab="Dispersion (norm. per larva)",lty=1  )
 lines(density(datDispersion[datDispersion$groupID == 'NL', ]$Dispersion_larval_norm,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$NF$Evoked,main=NA,lty=2)
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$NF$Spont,colourDataScheme$NF$Evoked),lwd=3 ) 
 
 plot(density(datDispersion[datDispersion$groupID == 'LE', ]$Dispersion_larval_norm, kernel="gaussian",na.rm=TRUE,bw=BW), lwd=4, ylim=c(0,ylimUp),col=colourDataScheme$LF$Spont,main="LF  ",xlab="Dispersion (norm. per larva)",lty=1 )
 lines(density(datDispersion[datDispersion$groupID == 'LL', ]$Dispersion_larval_norm,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$LF$Evoked,main=NA,lty=2 )
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$LF$Spont,colourDataScheme$LF$Evoked),lwd=3 ) 

 plot(density(datDispersion[datDispersion$groupID == 'DE', ]$Dispersion_larval_norm, kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4, ylim=c(0,ylimUp),col=colourDataScheme$DF$Spont,main="DF  ",xlab="Dispersion (norm. per larva)",lty=1 )
 lines(density(datDispersion[datDispersion$groupID == 'DL', ]$Dispersion_larval_norm,kernel="gaussian",na.rm=TRUE,bw=BW),lwd=4,col=colourDataScheme$DF$Evoked,main=NA,lty=2 )
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$DF$Spont,colourDataScheme$DF$Evoked),lwd=3 ) 
```

#### Maximum dispersion per larva
Then examining the maximum larval dispersions over the full event path, we find they look similar between groups :
I will use these max values to normalize dispersions for each larva (as in Marquez et al 2019).

#### Compare distribution of max dispersion per larva

Full Path:
```{r Max-dispersion Full-Path histogram per larva-Split E-S, fig.show="hold", out.width="50%", echo=FALSE, results='hide',fig.cap="Histograms of max dispersion per larva using  the full event trajectories - No time sliding time window " }
##### Maximum Dispersions Per Larva- 
hist_MaxDispersionPerLarva <- function(tsec_timeWindow)
{

  # plot histograms
  datMaxDispersionPerLarva.NF_hist <- hist((datMaxDispersionPerLarva.NF), breaks=nBreaks ,plot=FALSE)
  
  datMaxDispersionPerLarva.LF_hist <- hist((datMaxDispersionPerLarva.LF)
       , breaks=nBreaks, plot=FALSE)
  
  datMaxDispersionPerLarva.DF_hist <- hist((datMaxDispersionPerLarva.DF),
       breaks=nBreaks,plot=FALSE)
  
  plot(datMaxDispersionPerLarva.NF_hist$mids,datMaxDispersionPerLarva.NF_hist$counts, main="Histogram of max-dispersal per larva ",
                                       xlab="Max. dispersion  per larva (mm)", xlim=XLIM,
                                       ylab="Number of larvae",
                                      pch=pointTypeScheme$NL, lty=lineTypeL.NF,
                                      col=colourDataScheme$NF$Evoked, ylim=c(0,ylimUp),type="b")
  
  points(datMaxDispersionPerLarva.NF_hist$mids,datMaxDispersionPerLarva.LF_hist$counts, 
                                        xlim=XLIM, pch=pointTypeScheme$LL,  col=colourDataScheme$LF$Evoked,lty=lineTypeL.LF, ylim=c(0,ylimUp),type="b")
  
  points(datMaxDispersionPerLarva.DF_hist$mids,datMaxDispersionPerLarva.DF_hist$counts, lty=lineTypeL.DF,
                                       xlim=XLIM,pch=pointTypeScheme$DL,
                                      col=colourDataScheme$DF$Evoked, ylim=c(0,ylimUp),type="b")
  
  legend("topleft",c("NF","LF","DF"),pch=c(pointTypeScheme$NL,pointTypeScheme$LL,pointTypeScheme$DL) , lty=c(lineTypeL.NF,lineTypeL.LF,lineTypeL.DF),col=c(colourDataScheme$NF$Evoked,colourDataScheme$LF$Evoked,colourDataScheme$DF$Evoked),lwd=3 ) 
}

  strFileName <- paste0(strDataExportDir,"/foragingState_max_Dispersion_perLarva_",tsec_timeWindow,"sec.rds")
  message("Loaded max disp precalc :",strFileName)
  datMaxDispersionPerLarva <- readRDS(file=strFileName )
  nBreaks=seq(0,13,1)
  ylimUp <- 35
  XLIM <- c(0,15)
  # extract Evoked to Spont max disp data
  datMaxDispersionPerExp.NF.Spont <- datMaxDispersionPerLarva[datMaxDispersionPerLarva$expID %in% datExpPairs[datExpPairs$groupID.S == 'NE' ,]$expID.S, ]$max_exp_Dispersion
  datMaxDispersionPerExp.NF.Evoked <- datMaxDispersionPerLarva[datMaxDispersionPerLarva$expID %in% datExpPairs[datExpPairs$groupID.E == 'NL' ,]$expID.E, ]$max_exp_Dispersion
  datMaxDispersionPerExp.LF.Spont <- datMaxDispersionPerLarva[datMaxDispersionPerLarva$expID %in% datExpPairs[datExpPairs$groupID.S == 'LE' ,]$expID.S, ]$max_exp_Dispersion 
  datMaxDispersionPerExp.LF.Evoked <- datMaxDispersionPerLarva[datMaxDispersionPerLarva$expID %in% datExpPairs[datExpPairs$groupID.E == 'LL' ,]$expID.E, ]$max_exp_Dispersion
  datMaxDispersionPerExp.DF.Spont <- datMaxDispersionPerLarva[datMaxDispersionPerLarva$expID %in% datExpPairs[datExpPairs$groupID.S == 'DE' ,]$expID.S, ]$max_exp_Dispersion
  datMaxDispersionPerExp.DF.Evoked <- datMaxDispersionPerLarva[datMaxDispersionPerLarva$expID %in% datExpPairs[datExpPairs$groupID.E == 'DL' ,]$expID.E, ]$max_exp_Dispersion
  
  ## Max reported is across NE/NL - so checking either condition would suffice to get the max for each larva
  datMaxDispersionPerLarva.LF <- datMaxDispersionPerLarva[datMaxDispersionPerLarva$expID %in% datExpPairs[datExpPairs$groupID.S == 'LE' ,]$expID.S, ]$max_larval_Dispersion
  datMaxDispersionPerLarva.NF <- datMaxDispersionPerLarva[datMaxDispersionPerLarva$expID %in% datExpPairs[datExpPairs$groupID.S == 'NE' ,]$expID.S, ]$max_larval_Dispersion
  datMaxDispersionPerLarva.DF <- datMaxDispersionPerLarva[datMaxDispersionPerLarva$expID %in% datExpPairs[datExpPairs$groupID.S == 'DE' ,]$expID.S, ]$max_larval_Dispersion 
  

hist_MaxDispersionPerLarva(0)
```
But when confined to a sliding window of say 20 sec
```{r Max-dispersion 20sec histogram per larva-Split E-S, fig.show="hold", out.width="50%", echo=FALSE, results='hide',fig.cap="Histograms of max dispersion per larva using  the 20sec sliding window of trajectories " }
hist_MaxDispersionPerLarva(20)
```

```{r  max-dispersion densities compare groups, fig.show="hold", out.width="50%", echo=FALSE, cache=TRUE,eval=FALSE }
 ## plot est, Densities Compare Spont to Evoked
 pBW <- 0.3
 ylimUp <- 1
 plot(density(datMaxDispersionPerLarva.NF, kernel="gaussian",na.rm=TRUE, bw=pBW), lwd=4, ylim=c(0,ylimUp), col=colourDataScheme$NF$Evoked,main="Maximum Dispersion Per Larva  ",xlab="Dispersion (mm)",lty=lineTypeL.NF  )
lines(density((datMaxDispersionPerLarva.LF), kernel="gaussian",na.rm=TRUE,bw=pBW), lwd=4, ylim=c(0,ylimUp),col=colourDataScheme$LF$Evoked,main=NA,xlab=NA,lty=lineTypeL.LF )
lines(density((datMaxDispersionPerLarva.DF), kernel="gaussian",na.rm=TRUE,bw=pBW),lwd=4, ylim=c(0,ylimUp),col=colourDataScheme$DF$Evoked,main=NA,xlab=NA,lty=lineTypeL.DF )


```

##### Compare max dispersion distributions between conditions 

It appears that the max dispersions do not differ much between spontaneous and evoked conditions for the DF group, 
while there seems to be some evidence that  LF Larvae explore more in the absence of prey and perhaps,suprisingly, NF larvae explore less in the absence of prey.
Maybe these could make sense under an expected reward paradigm, given experience.


```{r max-dispersion per larva densities split conditions, fig.show="hold", out.width="33%", echo=FALSE, cache=FALSE }
 ## plot est, Densities Compare Spont to Evoked

 ylimUp <- 0.5
  pBW <- 1
 plot(density(datMaxDispersionPerExp.NF.Spont, kernel="gaussian",na.rm=TRUE, bw=pBW), lwd=4, ylim=c(0,ylimUp), col=colourDataScheme$NF$Spont,main="NF Trajectories  ",xlab="Max Dispersion (mm)",lty=1  )
 lines(density(datMaxDispersionPerExp.NF.Evoked,kernel="gaussian",na.rm=TRUE,bw=pBW),lwd=4,col=colourDataScheme$NF$Evoked,main=NA,lty=2)
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$NF$Spont,colourDataScheme$NF$Evoked),lwd=3 ) 
 
 
 plot(density(datMaxDispersionPerExp.LF.Spont, kernel="gaussian",na.rm=TRUE,bw=pBW), lwd=4, ylim=c(0,ylimUp),col=colourDataScheme$LF$Spont,main="LF  Trajectories",xlab="Max Dispersion (mm)",lty=1 )
 lines(density(datMaxDispersionPerExp.LF.Evoked,kernel="gaussian",na.rm=TRUE,bw=pBW),lwd=4,col=colourDataScheme$LF$Evoked,main=NA,lty=2 )
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$LF$Spont,colourDataScheme$LF$Evoked),lwd=3 ) 

 plot(density(datMaxDispersionPerExp.DF.Spont, kernel="gaussian",na.rm=TRUE,bw=pBW),lwd=4, ylim=c(0,ylimUp),col=colourDataScheme$DF$Spont,main="DF  Trajectories",xlab="max Dispersion (mm)",lty=1 )
 lines(density(datMaxDispersionPerExp.DF.Evoked,kernel="gaussian",na.rm=TRUE,bw=pBW),lwd=4,col=colourDataScheme$DF$Evoked,main=NA,lty=2 )
legend("topright",c("Spontaneous","Evoked"), lty=c(1,2),col=c(colourDataScheme$DF$Spont,colourDataScheme$DF$Evoked),lwd=3 ) 
```

## Path length and dispersion ratio distributions 

Within Low dispersions hides a locomotive behaviour of pause, where the larva is not actually moving. We want to explore how experience modifies their locomotion strategy and thus this is best done by examining dispersion in relation to the distance travelled. Particularly I will look into a a state of locomotion pause, when the larva stop moving. 

Thus, similar to the measure of dispersion, we plot the 5sec recent trajectory lengths over all movement and over hunt event initiations, side by side:
### Distributions of path length


```{r length histograms per group across conditions, fig.show="hold", out.width="50%", echo=FALSE, results='hide'  }
tsec_timeWindow <- 5
datDispersion <- loadDispersionData(tsec_timeWindow)
xbreaks <-seq(0,max(datDispersion$Length,na.rm=TRUE)+2,2)
datHEventDispersion <- loadHuntEventMergedWithPathStat(tsec_timeWindow)

h_Length_NE <- hist(datDispersion[datDispersion$groupID %in% c('NE'), ]$Length,breaks=xbreaks,main="NF Spont.",xlab="Length (mm)",col=colourDataScheme$NF$Spont)
h_Length_NL <- hist(datDispersion[datDispersion$groupID %in% c('NL'), ]$Length,breaks=xbreaks,main="NF Evoked.",xlab="Length (mm)",col=colourDataScheme$NF$Evoked)
h_Length_LE <- hist(datDispersion[datDispersion$groupID %in% c('LE'), ]$Length,breaks=xbreaks,main="LF Spont.",xlab="Length (mm)",col=colourDataScheme$LF$Spont)
h_Length_LL <- hist(datDispersion[datDispersion$groupID %in% c('LL'), ]$Length,breaks=xbreaks,main="LF Evoked.",xlab="Length (mm)",col=colourDataScheme$LF$Evoked)
h_Length_DE <- hist(datDispersion[datDispersion$groupID %in% c('DE'), ]$Length,breaks=xbreaks,main="DF Spont.",xlab="Length (mm)",col=colourDataScheme$DF$Spont)
h_Length_DL <- hist(datDispersion[datDispersion$groupID %in% c('DL'), ]$Length,breaks=xbreaks,main="DF Evoked.",xlab="Length (mm)",col=colourDataScheme$DF$Evoked)

hist(datHEventDispersion[datHEventDispersion$groupID=='NE', ]$Length,breaks=xbreaks,main="NF Spont Hunt-events",xlab="Length",col=colourDataScheme$NF$Spont)
hist(datHEventDispersion[datHEventDispersion$groupID=='NL', ]$Length,breaks=xbreaks,main="NF Evoked Hunt-events",xlab="Length",col=colourDataScheme$NF$Evoked)
hist(datHEventDispersion[datHEventDispersion$groupID=='LE', ]$Length,breaks=xbreaks,main="LF Spont Hunt-events",xlab="Length ",col=colourDataScheme$LF$Spont)
hist(datHEventDispersion[datHEventDispersion$groupID=='LL', ]$Length,breaks=xbreaks,main="LF Evoked Hunt-events",xlab="Length ",col=colourDataScheme$LF$Evoked)
hist(datHEventDispersion[datHEventDispersion$groupID=='DE', ]$Length,breaks=xbreaks,main="DF Spont Hunt-events",xlab="Length",col=colourDataScheme$DF$Spont)
hist(datHEventDispersion[datHEventDispersion$groupID=='DL', ]$Length,breaks=xbreaks,main="DF Evoked Hunt-events",xlab="Length",col=colourDataScheme$DF$Evoked)

```

Comparing between general and hunt-event lengths it appears:
  - path lengths can be bimodal, like dispersions, in spontaneous conditions
  - LF Show higher motility to controls in both conditions
  - LF Spont. Shows overal higher motility to controls- Low occupancy in small movement mode
  - Locomotion in Evoked conditions  shows higher motility, and motion range, than Spontaneous. 
  - Evoked Hunt events occur over the higher movement sub range than the one observed overall   

To better examine tendencies to move towards dispersing trajectories we need to account for the effect of general motion, ie the length of a trajectory.
Here I examine recent dispersion as a ratio of recent trajectory length (5 sec window). A ration of 0.5 means larva moved in a straight line, as dispersal is the *radius* not the diameter of the  circle encompassing the recent trajectory

I next plot on logarithmic scale the percentage of each Path length and try to see if a power law like regime exists in the distribution, but also if the presence of prey changes the linear - drop off regime of the distribution. This is inspired by Fig 3 from Viswanathan et al 1999

```{r length log distributions conditions, fig.show="hold", out.width="33%", echo=FALSE, results='hide' ,warning=FALSE }

#,log="xy" 
lLinModel_NE <- getLogPowerSlope(h_Length_NE,10)
lLinModel_NL <- getLogPowerSlope(h_Length_NL,10)
plot(log10(h_Length_NE$mids),log10(100*h_Length_NE$counts/sum(h_Length_NE$counts) ),main=paste("NF Log-Log percentage of lengths " ),xlab="log Length (mm)",col=colourDataScheme$NF$Spont,pch=16,xlim=c(0,2.5),ylim=c(-4,3), ylab="log N(l) %")
points(log10(h_Length_NL$mids),log10(100*h_Length_NL$counts/sum(h_Length_NL$counts) ),
       #main=paste("NF Evoked. mu:",getLogPowerSlope(h_Length_NL)), 
       xlab="Length (mm)",col=colourDataScheme$NF$Evoked,pch=16)
lines(lLinModel_NE$ptx_line,lLinModel_NE$pty_line,lwd=3,col=colourDataScheme$NF$Spont)

lines(lLinModel_NL$ptx_line,lLinModel_NL$pty_line,lwd=3,col=colourDataScheme$NF$Evoked)
legend("topright",legend=c(paste("Spont μ",format(lLinModel_NE$coeff,digits=2)),paste("Evoked μ",format(lLinModel_NL$coeff,digits=2) ) ),col=c(colourDataScheme$NF$Spont,colourDataScheme$NF$Evoked) ,pch=c(16,16) )


#,log="xy" 
lLinModel_LE <- getLogPowerSlope(h_Length_LE,14)
lLinModel_LL <- getLogPowerSlope(h_Length_LL,14)
plot(log10(h_Length_LE$mids),log10(100*h_Length_LE$counts/sum(h_Length_LE$counts) ),main=paste("LF Log-Log percentage of lengths " ),xlab="log Length (mm)",col=colourDataScheme$LF$Spont,pch=16,xlim=c(0,2.5),ylim=c(-4,3), ylab="log N(l) %")
points(log10(h_Length_LL$mids),log10(100*h_Length_LL$counts/sum(h_Length_LL$counts) ),
       #main=paste("NF Evoked. mu:",getLogPowerSlope(h_Length_NL)), 
       xlab="Length (mm)",col=colourDataScheme$LF$Evoked,pch=16)
lines(lLinModel_LE$ptx_line,lLinModel_LE$pty_line,lwd=3,col=colourDataScheme$LF$Spont)
lines(lLinModel_LL$ptx_line,lLinModel_LL$pty_line,lwd=3,col=colourDataScheme$LF$Evoked)
legend("topright",legend=c(paste("Spont μ",format(lLinModel_LE$coeff,digits=2)), paste("Evoked μ",format(lLinModel_LL$coeff,digits=2) ) ),col=c(colourDataScheme$LF$Spont,colourDataScheme$LF$Evoked) ,pch=c(16,16) )



lLinModel_DE <- getLogPowerSlope(h_Length_DE,10)
lLinModel_DL <- getLogPowerSlope(h_Length_DL,10)
plot(log10(h_Length_DE$mids),log10(100*h_Length_DE$counts/sum(h_Length_DE$counts) ),main=paste("DF Log-Log percentage of lengths " ),xlab="log Length (mm)",col=colourDataScheme$DF$Spont,pch=16,xlim=c(0,2.5),ylim=c(-4,3), ylab="log N(l) %")
points(log10(h_Length_DL$mids),log10(100*h_Length_DL$counts/sum(h_Length_DL$counts) ),
       #main=paste("NF Evoked. mu:",getLogPowerSlope(h_Length_NL)), 
       xlab="Length (mm)",col=colourDataScheme$DF$Evoked,pch=16)
lines(lLinModel_DE$ptx_line,lLinModel_DE$pty_line,lwd=3,col=colourDataScheme$DF$Spont)
lines(lLinModel_DL$ptx_line,lLinModel_DL$pty_line,lwd=3,col=colourDataScheme$DF$Evoked)

legend("topright",legend=c(paste("Spont μ",format(lLinModel_DE$coeff,digits=2)), paste("Evoked μ",format(lLinModel_DL$coeff,digits=2) ) ),col=c(colourDataScheme$DF$Spont,colourDataScheme$DF$Evoked) ,pch=c(16,16) )

```

I have fitted a standard linear model on the log-log relationship at the drop off, where power-law like relationship appears on the data. 

(Edited After being corrected for measuring full event path-length -over the fixed ROI boundary- from entering ROI to leaving, where event recording stops) 
We find that the presence of prey changes the exponent, similarly to the foraging examples reported in Viswanathan et al. 1999.
Longer paths exist in the absence of prey, as larva spend time hunting within the ROI.
**In the absence of prey the exponent appears to be near the reportedly "optimal" 2 for NF and LF, but not for DF! **
<!--No Differences between test conditions can be seen for NF, and generally the linear/ power law like exponent of drop-off is very similar between conditions, unlike the foraging examples reported in Viswanathan et al. 1999.
This is not over a fixed radius boundary however, but over all paths. I will  look at this question for specific dispersion sizes in future section, first I look at the 
ratio of dispersion to path-lenth ratio, and find evidence of structure and difference between spont. and evoked events. -->


## Path-lenth to dispersion ratios

```{r  hunt-event-length-dispersion ratios histograms , fig.show="hold", out.width="50%", echo=FALSE, cache=TRUE }
## Normalized Dispersion In Hunt Events
nBreaks <-seq(0,0.5,0.02)
xbreaks <-seq(0,0.5,0.02)

## Check NF
hist(datDispersion[datDispersion$groupID %in% c('NE'), ]$Dispersion/ datDispersion[datDispersion$groupID %in% c('NE'), ]$Length,
     breaks=xbreaks,main="NF Spont.",xlab="Dispersion/Length ",col=colourDataScheme$NF$Spont)

hist(datHEventDispersion[datHEventDispersion$groupID=='NE', ]$Dispersion/datHEventDispersion[datHEventDispersion$groupID=='NE', ]$Length,
     breaks=nBreaks,main="NF Spont Hunt-events",xlab="Length",col=colourDataScheme$NF$Spont)

hist(datDispersion[datDispersion$groupID %in% c('NL'), ]$Dispersion/ datDispersion[datDispersion$groupID %in% c('NL'), ]$Length,
     breaks=xbreaks,main="NF Evoked",xlab="Dispersion/Length ",col=colourDataScheme$NF$Evoked)

hist(datHEventDispersion[datHEventDispersion$groupID=='NL', ]$Dispersion/datHEventDispersion[datHEventDispersion$groupID=='NL', ]$Length,
     breaks=nBreaks,main="NF Evoked Hunt-events",xlab="Length",col=colourDataScheme$NF$Evoked)


## Check LF
#'Spont
hist(datDispersion[datDispersion$groupID %in% c('LE'), ]$Dispersion/ datDispersion[datDispersion$groupID %in% c('LE'), ]$Length,
     breaks=xbreaks,main="LF Spont.",xlab="Dispersion/Length ",col=colourDataScheme$LF$Spont)

hist(datHEventDispersion[datHEventDispersion$groupID=='LE', ]$Dispersion/datHEventDispersion[datHEventDispersion$groupID=='LE', ]$Length,
     breaks=nBreaks,main="LF Spont Hunt-events",xlab="Length ",col=colourDataScheme$LF$Spont)

## Evoked
hist(datDispersion[datDispersion$groupID %in% c('LL'), ]$Dispersion/ datDispersion[datDispersion$groupID %in% c('LL'), ]$Length,
     breaks=xbreaks,main="LF Evoked.",xlab="Dispersion/Length ",col=colourDataScheme$LF$Evoked)

hist(datHEventDispersion[datHEventDispersion$groupID=='LL', ]$Dispersion/datHEventDispersion[datHEventDispersion$groupID=='LL', ]$Length,
     breaks=nBreaks,main="LF Evoked Hunt-events",xlab="Length ",col=colourDataScheme$LF$Evoked)


## Check DF
hist(datDispersion[datDispersion$groupID %in% c('DE'), ]$Dispersion/ datDispersion[datDispersion$groupID %in% c('DE'), ]$Length,
     breaks=xbreaks,main="DF Spont.",xlab="Dispersion/Length ",col=colourDataScheme$DF$Spont)

hist(datHEventDispersion[datHEventDispersion$groupID=='DE', ]$Dispersion / datHEventDispersion[datHEventDispersion$groupID=='DE', ]$Length,
     breaks=nBreaks,main="DF Spont Hunt-events",xlab="Length",col=colourDataScheme$DF$Spont)

hist(datDispersion[datDispersion$groupID %in% c('DL'), ]$Dispersion/ datDispersion[datDispersion$groupID %in% c('DL'), ]$Length,
     breaks=xbreaks,main="DF Evoked",xlab="Dispersion/Length ",col=colourDataScheme$DF$Evoked)

hist(datHEventDispersion[datHEventDispersion$groupID=='DL', ]$Dispersion/datHEventDispersion[datHEventDispersion$groupID=='DL', ]$Length,breaks=nBreaks,main="DF Evoked Hunt-events",xlab="Length",col=colourDataScheme$DF$Evoked)


BW=0.1
```

These distribution are interesting as they show some well defined structure, especially in spontaneous conditions. They could underly some general well known movement/exploration strategy, which I need to look for.

Generally, lower ratios are indicative of turtuous paths of low dispersion, ie where the larva moves but is generally constrained to the same region.

  - In all trajectories the higherst ratio - indicating straight motion- has the higher occupancy
  - Across groups, evoked conditions augment the frequency of low ratios, ie low dispersion movement
  - Ratios over hunt-event initiation suggest that low-dispersal frequencies are relativelly over represented compared to general motility in evoked conditions, but not in spontaneous conditions, ie spontaneous events occur randomly across general motion, in evoked conditions low dispersion motion appears favouroble to hunt-event initiation. 


## Path length per dispersion size (Examine Invariance principle)
Take a random walk until it hits a circle of radius r times the step length. The average number of steps it performs is $r^2$.[citation needed] 
This fact is the discrete version of the fact that a Wiener process walk is a fractal of Hausdorff dimension 2.[citation needed]

Usually the mean length of the trajectories inside a domain depends both on the geometry of the system and on the characteristic of the random walk. 
However, for a diffusive random walk, one that has exponentially distributed straight paths between two successive scattering evens, it has been established *that mean lengths of the trajectories is independent of the random walk characteristics* and is given by a simple formula (#mazzolo2009invariance). 
For random walks, the mean length $<s>$ does not depend on the characteristic mean free path ℓ, but only on the ratio between the surface A and the perimeter C—that is $<s>=\pi A/C$
Thus the corresponding mean values are constrained by the sole free surface to perimeter ratio (see
[1](https://science.sciencemag.org/content/358/6364/765/tab-figures-data) [2](https://www.nature.com/articles/s41467-019-10455-y) ).
Therefore *it may be possible to use this principle to detect for diffusive walks*, instead of relying on fitting the statistics of step lenghts to power-laws or exponentials. This can then avoid having to set arbitrary threshold on what is considered straight or a turn/change of direction.
However, (#mazzolo2009invariance) prove that for any homogeneous stochastic processes the mean length of trajectories is still given by the Cauchy formula, as long as the random walker enters the domain with distributions that are simply related to that of the random walk. 

Normally the mean path-length for the entry and exit from a circle of size $r$ is measured.
Here I have path-lengths whose 2-most distal points  fall on the Dispersal circle-boundary.
I will first examine the mean total path-length contained in the dispersion domain, and then the path length between the 2 points that define the dispersion domain.

### Mean Path length scales linearly with dispersion

Plot for X sec duration paths finds that indeed a linear relationship similar to (this)[https://iopscience.iop.org/article/10.1209/epl/i2003-00208-x/meta], while the mean path length defining the limits (radius $r$) of the dispersion domain is proportional to the Area/Circumfarence ratio. 
Yet, this relationship is *not invariant*, as looking at increasing path-integration time windows $X$sec reveals increasing slope of mean-path lengths. 
Thus suggesting mean path length is not invariant to the particular variations in the timescale at which the animal disperses withing a circle $r$.

The plots below examine both, the total mean path length contained with each dispersion $r$, and the cutting path length - the path between the two points that touch the circles boundary:

```{r  path-length-2sec duration- per dispersion   , fig.show="hold", out.width="50%", echo=FALSE, cache=TRUE,fig.cap="Mean path length per dispersion size for path-durations 20sec" }

## iNvariance Principle Theoretical Mean Path Length
theoreticalMeanLength <- function(D,propFactor=1.0)
{
  A <- pi*( (D)^2)
  C <- 2*pi*(D)
  return(round(100*(propFactor* pi*A/C)) /100 )
}
## Plot mean path length for each boundary dispersion size 
# This is to examine the similarity to the random walk invariance principle by which the mean pathlength within a circle of radius r is proportional to pi*A/C
# ie legth to hit the boundary of the observation circle, is only proportional to the circle (in 2D), volume in 3D- 
plot_meanCrossingPathLengthPerDispersion <- function(datDispersion, strGroupID, addPlot=FALSE, propFactor=1.0)
{
  datGroupDispersion <- datDispersion[datDispersion$groupID %in% strGroupID,]
  dispBreaks <- seq(1,13,1)
  upLIM <- 50
  datGroupDispersion$dispRange <- cut(datGroupDispersion[datGroupDispersion$groupID %in% strGroupID ,"Dispersion" ],breaks=dispBreaks)
  ##The Path Connecting the two points that define the Dispersion Circle
  vmeanPathLengthPerDispersion <- tapply(datGroupDispersion$DispersionPathLength,datGroupDispersion$dispRange,mean,na.rm=TRUE)*DIM_MMPERPX
  
  if (!addPlot)
  {
    plot(seq(1,10.5,length.out = NROW(vmeanPathLengthPerDispersion)),
         vmeanPathLengthPerDispersion,xlab="Circle radius / Dispersion (mm)",ylab="Chord mean path length <l>",
         ylim=c(0,upLIM),xlim=c(0,11),col=colourDataScheme[[strGroupID]],pch=pointTypeScheme[[strGroupID]],cex=0.8 )
        lines(seq(1,10.5,length.out = NROW(vmeanPathLengthPerDispersion)),
         vmeanPathLengthPerDispersion,lwd=1,lty=lineTypeScheme[[strGroupID]])

  }else
  {
    points(seq(1,10.5,length.out = NROW(vmeanPathLengthPerDispersion)),
         vmeanPathLengthPerDispersion,xlab="Circle radius / Dispersion (mm)",
         col=colourDataScheme[[strGroupID]],pch=pointTypeScheme[[strGroupID]],cex=0.8 )
    
    lines(seq(1,10.5,length.out = NROW(vmeanPathLengthPerDispersion)),
         vmeanPathLengthPerDispersion,lwd=1,lty=lineTypeScheme[[strGroupID]])
  }
  
  if (!addPlot)
  {
    rpoints <- seq(0.5,10.5, length.out = NROW(vmeanPathLengthPerDispersion) )
    points(rpoints,theoreticalMeanLength(rpoints,propFactor ),pch=2,cex=0.8 ) #Low Lim
    points(seq(2,12,1),theoreticalMeanLength(seq(2,12,1),propFactor ),pch=2,cex=0.5 ) #Up Lim
    points(seq(1,11,1),theoreticalMeanLength(seq(1,11,1),propFactor ),pch=2,cex=0.5 ) #Up Lim
   # legend("topleft",pch=c(16,2),legend=c("Data","Theory"),col=c(colourDataScheme[[strGroupID]],"black") )
  }
  
  #boxplot(datGroupDispersion$Length~datGroupDispersion$dispRange,main=strTitle,col=colourDataScheme[[strGroupID]],ylim=c(0,35))
}

# The mean  Path Length Contained Within each Size of Dispersion
plot_meanPathLengthPerDispersion <- function(datDispersion, strGroupID, addPlot=FALSE, propFactor=1.0)
{
  datGroupDispersion <- datDispersion[datDispersion$groupID %in% strGroupID,]
  dispBreaks <- seq(1,13,1)
  upLIM <- 50
  datGroupDispersion$dispRange <- cut(datGroupDispersion[datGroupDispersion$groupID %in% strGroupID ,"Dispersion" ],breaks=dispBreaks)
  ##The Path Connecting the two points that define the Dispersion Circle
  vmeanPathLengthPerDispersion <- tapply(datGroupDispersion$Length,datGroupDispersion$dispRange,mean,na.rm=TRUE)
  
  if (!addPlot)
  {
    plot(seq(1,10.5,length.out = NROW(vmeanPathLengthPerDispersion)),
         vmeanPathLengthPerDispersion,xlab="Circle radius / Dispersion (mm)",ylab="Total contained mean path length <l>",
         ylim=c(0,upLIM),xlim=c(0,11),col=colourDataScheme[[strGroupID]],pch=pointTypeScheme[[strGroupID]],cex=0.8 )
        lines(seq(1,10.5,length.out = NROW(vmeanPathLengthPerDispersion)),
         vmeanPathLengthPerDispersion,lwd=1,lty=lineTypeScheme[[strGroupID]])

  }else
  {
    points(seq(1,10.5,length.out = NROW(vmeanPathLengthPerDispersion)),
         vmeanPathLengthPerDispersion,xlab="Circle radius / Dispersion (mm)",
         col=colourDataScheme[[strGroupID]],pch=pointTypeScheme[[strGroupID]],cex=0.8 )
    
    lines(seq(1,10.5,length.out = NROW(vmeanPathLengthPerDispersion)),
         vmeanPathLengthPerDispersion,lwd=1,lty=lineTypeScheme[[strGroupID]])
  }
  
  if (!addPlot)
  {
    rpoints <- seq(0.5,10.5, length.out = NROW(vmeanPathLengthPerDispersion) )
    points(rpoints,theoreticalMeanLength(rpoints,propFactor ),pch=2,cex=0.8 ) #Low Lim
    points(seq(2,12,1),theoreticalMeanLength(seq(2,12,1),propFactor ),pch=2,cex=0.5 ) #Up Lim
    points(seq(1,11,1),theoreticalMeanLength(seq(1,11,1),propFactor ),pch=2,cex=0.5 ) #Up Lim
   # legend("topleft",pch=c(16,2),legend=c("Data","Theory"),col=c(colourDataScheme[[strGroupID]],"black") )
  }
  
  #boxplot(datGroupDispersion$Length~datGroupDispersion$dispRange,main=strTitle,col=colourDataScheme[[strGroupID]],ylim=c(0,35))
}

tsec_timeWindow <- 2
datDispersion <- loadDispersionData(forceReload=T ,tsec_timeWindow)
strTitle <- paste(tsec_timeWindow,"sec duration paths ")

## Take Group 
propFactor <- 1.0
plot_meanPathLengthPerDispersion(datDispersion,'NE',addPlot = FALSE, propFactor)
plot_meanPathLengthPerDispersion(datDispersion,'NL',addPlot = TRUE,propFactor)
plot_meanPathLengthPerDispersion(datDispersion,'LE',addPlot = TRUE,propFactor)
plot_meanPathLengthPerDispersion(datDispersion,'LL',addPlot = TRUE,propFactor)
plot_meanPathLengthPerDispersion(datDispersion,'DE',addPlot = TRUE,propFactor)
plot_meanPathLengthPerDispersion(datDispersion,'DL',addPlot = TRUE,propFactor)
title(strTitle)

## Take Group 
propFactor <- 1.0
plot_meanCrossingPathLengthPerDispersion(datDispersion,'NE',addPlot = FALSE, propFactor)
plot_meanCrossingPathLengthPerDispersion(datDispersion,'NL',addPlot = TRUE,propFactor)
plot_meanCrossingPathLengthPerDispersion(datDispersion,'LE',addPlot = TRUE,propFactor)
plot_meanCrossingPathLengthPerDispersion(datDispersion,'LL',addPlot = TRUE,propFactor)
plot_meanCrossingPathLengthPerDispersion(datDispersion,'DE',addPlot = TRUE,propFactor)
plot_meanCrossingPathLengthPerDispersion(datDispersion,'DL',addPlot = TRUE,propFactor)
title(paste(strTitle," crossing chord " ) ) 



tsec_timeWindow <- 10
datDispersion <- loadDispersionData(forceReload = T,tsec_timeWindow)
strTitle <- paste(tsec_timeWindow,"sec duration paths ")

## Take Group 
propFactor <- 1.0
plot_meanPathLengthPerDispersion(datDispersion,'NE',addPlot = FALSE, propFactor)
plot_meanPathLengthPerDispersion(datDispersion,'NL',addPlot = TRUE,propFactor)
plot_meanPathLengthPerDispersion(datDispersion,'LE',addPlot = TRUE,propFactor)
plot_meanPathLengthPerDispersion(datDispersion,'LL',addPlot = TRUE,propFactor)
plot_meanPathLengthPerDispersion(datDispersion,'DE',addPlot = TRUE,propFactor)
plot_meanPathLengthPerDispersion(datDispersion,'DL',addPlot = TRUE,propFactor)
title(strTitle)
## Take Group 
propFactor <- 1.0
plot_meanCrossingPathLengthPerDispersion(datDispersion,'NE',addPlot = FALSE, propFactor)
plot_meanCrossingPathLengthPerDispersion(datDispersion,'NL',addPlot = TRUE,propFactor)
plot_meanCrossingPathLengthPerDispersion(datDispersion,'LE',addPlot = TRUE,propFactor)
plot_meanCrossingPathLengthPerDispersion(datDispersion,'LL',addPlot = TRUE,propFactor)
plot_meanCrossingPathLengthPerDispersion(datDispersion,'DE',addPlot = TRUE,propFactor)
plot_meanCrossingPathLengthPerDispersion(datDispersion,'DL',addPlot = TRUE,propFactor)
title(paste(strTitle," crossing chord " ) ) 


# 
# tsec_timeWindow <- 50
# datDispersion <- loadDispersionData(forceReload = T,tsec_timeWindow)
# strTitle <- paste(tsec_timeWindow,"sec duration paths ")
# 
# ## Take Group 
# propFactor <- 1.0
# plot_meanPathLengthPerDispersion(datDispersion,'NE',addPlot = FALSE, propFactor)
# plot_meanPathLengthPerDispersion(datDispersion,'NL',addPlot = TRUE,propFactor)
# plot_meanPathLengthPerDispersion(datDispersion,'LE',addPlot = TRUE,propFactor)
# plot_meanPathLengthPerDispersion(datDispersion,'LL',addPlot = TRUE,propFactor)
# plot_meanPathLengthPerDispersion(datDispersion,'DE',addPlot = TRUE,propFactor)
# plot_meanPathLengthPerDispersion(datDispersion,'DL',addPlot = TRUE,propFactor)
# title(strTitle)
# 
# ## Take Group 
# propFactor <- 1.0
# plot_meanCrossingPathLengthPerDispersion(datDispersion,'NE',addPlot = FALSE, propFactor)
# plot_meanCrossingPathLengthPerDispersion(datDispersion,'NL',addPlot = TRUE,propFactor)
# plot_meanCrossingPathLengthPerDispersion(datDispersion,'LE',addPlot = TRUE,propFactor)
# plot_meanCrossingPathLengthPerDispersion(datDispersion,'LL',addPlot = TRUE,propFactor)
# plot_meanCrossingPathLengthPerDispersion(datDispersion,'DE',addPlot = TRUE,propFactor)
# plot_meanCrossingPathLengthPerDispersion(datDispersion,'DL',addPlot = TRUE,propFactor)
# title(paste(strTitle," crossing chord " ) ) 


#smoothScatter(datDispersion[datDispersion$groupID == "LE",]$DispersionPathLength,datDispersion[datDispersion$groupID == "LE",]$Dispersion)

```

When looking at short path-durations (2sec) indeed our data shows some agreement with the theoretical mean-path lengths by a factor of 1.5, while the linear relationship holds all groups in the same way.
The length of every path contained in a dispersion circle with radius $r$ increases linearly with $r$, specifically the relationship appears to be :
\[
<s> = \frac{3\pi}{2}  \frac{\pi r^2}{2 \pi r}
\]

When these same dispersion ranges are examined over 50sec path durations we find that a linear relationship still holds, but this slope deviates further from theoretical with increasing mean path lengths. This can be explained as the development of the same dispersions now is much slower, this is apparently partly explained by increasingly tortuous paths from entry to exit of the same $r$ Dispersion circle domains.
*Thus the linear relationship is not invariant to the path time-scale*

but why? some invariance seems to hold when it comes to the chords defining the dispersion domain, (similar to  #blanco2003invariance), at least clearly so in the absence of prey.

When looking at the overall contained path-length, I find that in the presence of prey increases path-lengths (for > 10sec durations) - most likely as a result of hunting events and prey tracking. 
But note, that this way of looking at such path-data is new.
Usually mean free paths are measured, as the path between two changes in direction, or the time of entry and exit from a circle bound area.
 
it is known that the number of steps scales as the $<s> \approx  r^2$, and here we find that path-length scales with $r$, which here is the dispersion radius containing the path.
The Chord-cutting path-length, which defines the dispersion size,  follow the invariance linear rule more strictly, and that is clear over longer path durations.

Nevertheless we find that the addition of prey *LF increase the path-lengths even among paths with the same Dispersion*, as their response to prey/ prey detection makes paths more turtuous (check 10sec paths). Over 50sec paths this increase in path length in evoked conditions is evident across groups.

I next look at the Log-Log distribution of path-lengths for a specified dispersion boundary. 

```{r  path-length-All duration- per dispersion   , fig.show="hold", out.width="50%", echo=FALSE, cache=TRUE,fig.cap="Mean path length per dispersion size for full event path-lengths " }
rm(datDispersion)
tsec_timeWindow <- 0
datDispersion <- loadDispersionData_norm(tsec_timeWindow)
strTitle <- paste("Whole path ")

## Take Group 
plot_meanPathLengthPerDispersion(datDispersion,'NE')
plot_meanPathLengthPerDispersion(datDispersion,'NL',addPlot = TRUE)
plot_meanPathLengthPerDispersion(datDispersion,'LE',addPlot = TRUE)
plot_meanPathLengthPerDispersion(datDispersion,'LL',addPlot = TRUE)
plot_meanPathLengthPerDispersion(datDispersion,'DE',addPlot = TRUE)
plot_meanPathLengthPerDispersion(datDispersion,'DL',addPlot = TRUE)
title(strTitle)

```

##  Path-length Log-Log distribution per *specific dispersion*

```{r  path-length for dispersion log-log distribution , fig.show="hold", out.width="33%", echo=FALSE, cache=TRUE }
#,log="xy" 

plotLogLogPathLengthForFixedDispersion  <- function(datDispersion,strGroupID,dispRange = 10)
{
    datGroupDispersion <- datDispersion[datDispersion$groupID %in% strGroupID,]
    dispBreaks <- seq(1,11,0.3)
    datGroupDispersion$dispRange <- cut(datGroupDispersion[datGroupDispersion$groupID %in% strGroupID ,"Dispersion" ],breaks=dispBreaks)
    strTitle <- paste("Path length per dispersion", strGroupID,"#",NROW(datGroupDispersion$dispRange))

    xbreaks <-seq(0,max(datDispersion$Length,na.rm=TRUE)+1,2)
    strDispRange <-levels(datGroupDispersion$dispRange)[dispRange]
    #print(strDispRange) 
    h_Length_GE <- hist(datGroupDispersion[datGroupDispersion$groupID == strGroupID[1] & datGroupDispersion$dispRange %in% levels(datGroupDispersion$dispRange)[dispRange] , ]$Length,breaks=xbreaks,plot=FALSE)
    h_Length_GL <- hist(datGroupDispersion[datGroupDispersion$groupID == strGroupID[2] & 
                                               datGroupDispersion$dispRange %in% levels(datGroupDispersion$dispRange)[dispRange] , ]$Length,breaks=xbreaks,plot=FALSE)

    lLinModel_GE <- getLogPowerSlope(h_Length_GE,10)
    lLinModel_GL <- getLogPowerSlope(h_Length_GL,10)
    
    plot(log10(h_Length_GE$mids),log10(100*h_Length_GE$counts/sum(h_Length_GE$counts) ),
         main=paste(" Log-Log percentage of lengths for disp:",strDispRange ),
         xlab="log Length (mm)", col=colourDataScheme[strGroupID[1]][[1]], pch=16,xlim=c(0,2.0),ylim=c(-4,3), ylab="log N(l) %")
    
    points(log10(h_Length_GL$mids),log10(100*h_Length_GL$counts/sum(h_Length_GL$counts) ),
           xlab="Length (mm)",col=colourDataScheme[strGroupID[2]][[1]], pch=16)
    lines(lLinModel_GE$ptx_line,lLinModel_GE$pty_line,lwd=3,col=colourDataScheme[strGroupID[1]][[1]])
    
    lines(lLinModel_GL$ptx_line,lLinModel_GL$pty_line,lwd=3,col=colourDataScheme[strGroupID[2]][[1]])
    legend("topright", 
           legend=c(paste("Spont μ",format(lLinModel_GE$coeff,digits=2)),paste("Evoked μ",format(lLinModel_GL$coeff,digits=2) ) ),col=c(colourDataScheme[strGroupID[2]][[1]] ,colourDataScheme[strGroupID[2]][[1]]) ,pch=c(16,16) )

}
##Low Dispersal - Larval Size - 4.3mm
plotLogLogPathLengthForFixedDispersion(datDispersion,c("NE","NL"),dispRange = 12)
plotLogLogPathLengthForFixedDispersion(datDispersion,c("LE","LL"),dispRange = 12)
plotLogLogPathLengthForFixedDispersion(datDispersion,c("DE","DL"),dispRange = 12)
## 5.2mm
plotLogLogPathLengthForFixedDispersion(datDispersion,c("NE","NL"),dispRange = 15)
plotLogLogPathLengthForFixedDispersion(datDispersion,c("LE","LL"),dispRange = 15)
plotLogLogPathLengthForFixedDispersion(datDispersion,c("DE","DL"),dispRange = 15)
##High Range 7.3
plotLogLogPathLengthForFixedDispersion(datDispersion,c("NE","NL"),dispRange = 22)
plotLogLogPathLengthForFixedDispersion(datDispersion,c("LE","LL"),dispRange = 22)
plotLogLogPathLengthForFixedDispersion(datDispersion,c("DE","DL"),dispRange = 22)



```

When looking at small dispersion circles $(3.7,4]$ we find here is that the path-lengths increase between spontaneous and evoked conditions, across groups. 
For larger dispersions cicles $(5.2,5.5]$ we find an effect specific to LF, whereby the food and non food (evoked, spontaneous) conditions differ in a manner shown as in (Viswanathan et al. 2009)!

The way the data is looked at here is different, and exponent $\mu$, shown as the linear power law within the log-log, would not match the investigations from (Viswanathan et al. 2009)

##  Path-length to dispersion ratios fixed dispersion range

```{r  path-length to dispersion ratio distribution , fig.show="hold", out.width="33%", echo=FALSE, cache=TRUE }

hist_pathLengthPerDispersion <- function(datDispersion,strGroupID)
{
  datGroupDispersion <- datDispersion[datDispersion$groupID %in% strGroupID,]
  ##get Dispersion Levels, as discrete circles with thing 1mm boundary
  dispLevel <- cut(datGroupDispersion[,"Dispersion" ],breaks=seq(1,11,1))
  y <- datGroupDispersion[!is.na(dispLevel) & dispLevel == '(3,4]',"Length"]
  strTitle <- paste( strGroupID,"#",NROW(y),"D=3-4mm l",theoreticalMeanLength(3),"-", theoreticalMeanLength(4), "<s>=",mean(y,na.rm=TRUE) )

  #x <- datDispersion[!is.na(dispLevel) & dispLevel == '(3,4]',"Dispersion"]
  hist(y,breaks=seq(0,46,2),
  main=strTitle,
  col=colourDataScheme[[strGroupID]]  )
  
  ##get Dispersion Levels, as discrete circles with thing 1mm boundary
  y <- datGroupDispersion[!is.na(dispLevel) & dispLevel == '(4,5]',"Length"]
  strTitle <- paste( strGroupID,"#",NROW(y),"D=4-5mm l~",theoreticalMeanLength(4),"-", theoreticalMeanLength(5), "<s>=",mean(y,na.rm=TRUE) )
  #x <- datDispersion[!is.na(dispLevel) & dispLevel == '(3,4]',"Dispersion"]
  hist(y,breaks=seq(0,46,2),main=strTitle,
       col=colourDataScheme[[strGroupID]]  )
  
  y <- datGroupDispersion[!is.na(dispLevel) & dispLevel == '(5,6]',"Length"]
  strTitle <- paste( strGroupID,"#",NROW(y),"D=5-6mm l~",theoreticalMeanLength(5),"-", theoreticalMeanLength(6), "<s>=",mean(y,na.rm=TRUE) )
  #x <- datDispersion[!is.na(dispLevel) & dispLevel == '(3,4]',"Dispersion"]
  hist(y,breaks=seq(0,46,2),
       main=strTitle , col=colourDataScheme[[strGroupID]]  )
}

## Take Group 
hist_pathLengthPerDispersion(datDispersion,'NE')
hist_pathLengthPerDispersion(datDispersion,'NL')

hist_pathLengthPerDispersion(datDispersion,'LE')
hist_pathLengthPerDispersion(datDispersion,'LL')

hist_pathLengthPerDispersion(datDispersion,'DE')
hist_pathLengthPerDispersion(datDispersion,'DL')




```

In summary, over fixed path durations, the*mean path length depends on size of the observation area $\pi A/C$*.
It is not clear to me if this is evidence towards the larval trajectories appearing  as a stochastic diffussive process, because random straigh line chords would also scale linearly with the spatial domain they cross.
In general the above data suggest that the characteristics  **dynamics governing foraging motion  may  modified by experience **


# Invariance-revisited - Path lengths crossing bounded areas

I need to investigate the invariance principle further, and whether it amounts to paths being diffusion/random walks or Levy processes.
As up to now I was not looking something that is equivalent entry and exit times, or time to hit boundary as in the Levy type investigations, because here all paths chosen have produced a specific dispersal - ie these paths are defined by having the longest distance within the circular domain (which could explain the icreased slope upwards).  and thus are not equivalent to looking at a isotropic entry, as for example  looking at the escape from random starting point within the cycle, or the mean escape time upon entering an area nor the mean time to hit two target sites (food items) as in FIG 3 (Viswanathan et al. 2009).

```{r mean-squared-displacement calculations , fig.show="hold", out.width="50%", echo=FALSE, cache=TRUE }
library (plyr) #Split list, apply function #Thanks to https://stackoverflow.com/questions/4227223/convert-a-list-to-a-data-frame

#datDispersion<-loadDispersionData(10)
loaddatAllFrames()
  
  
  vgroupID <- vGroups[2]
  
calcPathLengthsInDomain <- function(datAllFrames,vgroupID,DomainRadius)
  {
    CONSECUTIVE_FRAME_THRES <- 2
    datGroupTraj <- datAllFrames[datAllFrames$groupID == vgroupID & datAllFrames$posX > 0,]
    ## Calc Dist from Center of domain
    pDomainCentre <- c(mean(datGroupTraj$posX),mean(datGroupTraj$posY))
    rDomainRadius <- DomainRadius/DIM_MMPERPX
    
    datGroupTraj$distToDomainCentre   <- sqrt((datGroupTraj$posX-pDomainCentre[1])^2 + (datGroupTraj$posY-pDomainCentre[2])^2)*DIM_MMPERPX
    
    datDomainTrajectories <- datGroupTraj[datGroupTraj$distToDomainCentre <= rDomainRadius*DIM_MMPERPX,]
    datDomainTrajectories$distToDomainBoundary <- rDomainRadius*DIM_MMPERPX - datDomainTrajectories$distToDomainCentre
      #hist(datGroupTraj$distToDomainCentre,main=vgroupID)
    #hist(datDomainTrajectories$distToDomainCentre,main=vgroupID)
      #smoothScatter(datGroupTraj$posX,datGroupTraj$posY,xlim=c(0,640),ylim=c(0,480))
    #smoothScatter(datDomainTrajectories$posX,datDomainTrajectories$posY,xlim=c(0,640),ylim=c(0,480))
    
    Dframe <- diff(datDomainTrajectories$frameN)
    Dexp <- diff(as.integer(datDomainTrajectories$expID) )
    DeventID <- diff(as.integer(datDomainTrajectories$eventID) )
    datDomainTrajectories$DnextFrame <- NA
    datDomainTrajectories$DeventID <- NA
    datDomainTrajectories$Dexp <- NA
    ## Just so I can make sure no tracklets Between Different Events Are accidentaly joined - as a coincindence of frame numbers
    datDomainTrajectories[1:NROW(Dframe),]$DnextFrame <- Dframe
    datDomainTrajectories[1:NROW(Dexp),]$Dexp <- Dexp
    datDomainTrajectories[1:NROW(DeventID),]$DeventID <- DeventID
    datDomainTrajectories$TrackletUID <- NA
    
    
    # Assign a UID to each contigious tracklet (This is to avoid any track re-entry after exit being counted as the same path)
    # Label Consecutive Groups when their frame are less than CONSECUTIVE_FRAME_THRES (15) apart - Change of Event And Experiment added 
    continuousTrackletsFrames <- split(datDomainTrajectories$frameN, 
                                       ##Sum Increments When the following Indicators Of Changing Class Become TRUE (I added Track Splitters when Exp or Event Change)
                                 cumsum(c(1, abs(datDomainTrajectories$DnextFrame > CONSECUTIVE_FRAME_THRES)  | datDomainTrajectories$DeventID != 0 | datDomainTrajectories$Dexp != 0 ) ) # 
                                  ) 

    dfcontinuousTrackletsFrames <- ldply (continuousTrackletsFrames, data.frame)
    datDomainTrajectories$TrackletUID <- (unlist(dfcontinuousTrackletsFrames[1]))
    
    ##Debug - Export Tracklets
    # pal <- colorRamp(c("red", "blue"))
    # colT <- pal(seq(0, 1, len = NROW(continuousTrackletsFrames) ))
    #plot(datGroupTraj[datGroupTraj$expID == "320" & datGroupTraj$eventID == "18",]$posX,datGroupTraj[datGroupTraj$expID == "320" & datGroupTraj$eventID == "18",]$posY,cex=0.3,pch=20,xlim=c(0,580),ylim=c(0,480))
    # for (Tuid in names(continuousTrackletsFrames))
    # {
    #   pdf(file= paste(strPlotExportPath,"/foraging/AAATracklet",Tuid,".pdf",sep=""))
    #   datTracklet <- datDomainTrajectories[datDomainTrajectories$TrackletUID == Tuid, ]
    #   plot(datTracklet$posX,datTracklet$posY,col="black", type="b",cex=0.3,pch=20,xlim=c(0,580),ylim=c(0,480)) #colT[as.integer(unlist(datTracklet$TrackletUID) )]
    #   dev.off()    
    # }

    ## Select The frames that Are on the Domain Boundary and Have no Interruption to the next frame - Ie Part of Consecutive Path
    datBoundaryDomainTrajectories <- datDomainTrajectories[abs(datDomainTrajectories$DnextFrame) <= CONSECUTIVE_FRAME_THRES & datDomainTrajectories$distToDomainBoundary < 0.3,]

    ##Find Mean Path Duration From Entry to Exit Of the domain - Group By Exp, Event and Tracklet UID (not the tracker Assigned TrackID)
    entryFramePerLarvaEvent <- tapply(datBoundaryDomainTrajectories$frameN,
                                      paste(datBoundaryDomainTrajectories$expID,datBoundaryDomainTrajectories$eventID,datBoundaryDomainTrajectories$TrackletUID,sep="-" ),min )
    exitFramePerLarvaEvent <- tapply(datBoundaryDomainTrajectories$frameN,
                                     paste(datBoundaryDomainTrajectories$expID,datBoundaryDomainTrajectories$eventID,datBoundaryDomainTrajectories$TrackletUID,sep="-"),max )
    
    pathDurations <- (exitFramePerLarvaEvent - entryFramePerLarvaEvent)
    pathDurations <- pathDurations[!is.na(pathDurations)]
    
    
    lTrackletInfo <- list()
    
    ##Calc Path Length for Each Tracklet Identified
    for (strTrackID in names(pathDurations) )
    {
          
          vTrackID <- strsplit(strTrackID,"-")
          
          TrackletInfo <- list(expID = vTrackID[[1]][1],EventID=vTrackID[[1]][2],TrackletUID=vTrackID[[1]][3],sectionID=vTrackID[[1]][4], DomainRadius = rDomainRadius*DIM_MMPERPX)
          TrackletInfo$startFrame <- entryFramePerLarvaEvent[[strTrackID]]
          TrackletInfo$endFrame  <-  exitFramePerLarvaEvent[[strTrackID]]
  
          
          if (pathDurations[[strTrackID]]  < 1)
          { message("Duration is zero :",strTrackID)
            next()
          }
            
          datBoundedTracklet <- datDomainTrajectories[datDomainTrajectories$expID == TrackletInfo$expID &
                                                              datDomainTrajectories$eventID == TrackletInfo$EventID &
                                                              datDomainTrajectories$TrackletUID == TrackletInfo$TrackletUID &
                                                              datDomainTrajectories$frameN >= TrackletInfo$startFrame &
                                                              datDomainTrajectories$frameN <= TrackletInfo$endFrame,
                                                              ]
               
          
          
          
          
          ## Measure Path Length - Can Skip Some Frames To Speed Up Calculation
          fps <- unique(datBoundedTracklet$fps)
          TrackletInfo$duration <- pathDurations[[strTrackID]]/fps
          nSpace <- round(as.integer(fps) / 3)
          if (pathDurations[[strTrackID]] < nSpace  )
            nSpace <- max(1,round(pathDurations[[strTrackID]] / 10) )
            
          vIdx <- seq(from=min(pathDurations[[strTrackID]],1),by=nSpace,to=pathDurations[[strTrackID]]) ##Last nfrm
          
          vX <- datBoundedTracklet[vIdx,"posX"]
          vY <- datBoundedTracklet[vIdx,"posY"]
          mat_posDX <- outer(vX,vX,'-')
          mat_posDY <- outer(vY,vY,'-') #and Y 
          
          # Combine to Find Distances DX DY between all point of trajectory
          mat_ptDist <- sqrt(mat_posDX^2 + mat_posDY^2)
          TrackletInfo$pathLength <- sum(mat_ptDist[row(mat_ptDist) == (col(mat_ptDist) - 1)],na.rm = T)*DIM_MMPERPX
          
          lTrackletInfo[[strTrackID]] <- TrackletInfo
          
          message("Path length for:",strTrackID," = ",format(TrackletInfo$pathLength,digits = 3),"mm in T:",format(TrackletInfo$duration,digits=3), "sec"  )
    } ##For Each Tracklet
    
  return(data.frame(do.call(rbind,lTrackletInfo) ) )
  }##END oF FUNCTION
  
  lBoundedTrackInfo <- list()
  DomainRadius <- 5 #mm
  for(g in vGroups)
  {
    message("Group:",g)
    lBoundedTrackInfo[[g]] <- calcPathLengthsInDomain(datAllFrames, g, DomainRadius)
  }
  saveRDS(lBoundedTrackInfo,file=paste0(strDataExportDir,"/stat_boundedPaths_R",DomainRadius,"mm.rds") )

  
  
  lBoundedTrackInfo <- list()
  DomainRadius <- 3 #mm
  for(g in vGroups)
  {
    message("Group:",g)
    lBoundedTrackInfo[[g]] <- calcPathLengthsInDomain(datAllFrames, g, DomainRadius)
  }
  saveRDS(lBoundedTrackInfo,file=paste0(strDataExportDir,"/stat_boundedPaths_R",DomainRadius,"mm.rds") )

  lBoundedTrackInfo <- list()
  DomainRadius <- 4 #mm
  for(g in vGroups)
  {
    message("Group:",g)
    lBoundedTrackInfo[[g]] <- calcPathLengthsInDomain(datAllFrames, g, DomainRadius)
  }
  saveRDS(lBoundedTrackInfo,file=paste0(strDataExportDir,"/stat_boundedPaths_R",DomainRadius,"mm.rds") )


  lBoundedTrackInfo <- list()
  DomainRadius <- 6 #mm
  for(g in vGroups)
  {
    message("Group:",g)
    lBoundedTrackInfo[[g]] <- calcPathLengthsInDomain(datAllFrames, g, DomainRadius)
  }
  saveRDS(lBoundedTrackInfo,file=paste0(strDataExportDir,"/stat_boundedPaths_R",DomainRadius,"mm.rds") )

    
#plot(datBoundaryDomainTrajectories$posX,datBoundaryDomainTrajectories$posY)
 #max(unlist(lBoundedTrackInfo[["LL"]]$pathLength) )
hist(unlist(lBoundedTrackInfo[["NL"]]$pathLength),breaks=seq(0,60,1),ylim=c(0,50),main=paste("NL",mean(unlist(lBoundedTrackInfo[["NL"]]$pathLength))  ) )
hist(unlist(lBoundedTrackInfo[["NE"]]$pathLength),breaks=seq(0,60,1),ylim=c(0,50),main=paste("NL",mean(unlist(lBoundedTrackInfo[["NE"]]$pathLength))  ) )


hist(unlist(lBoundedTrackInfo[["LL"]]$pathLength),breaks=seq(0,60,1),ylim=c(0,50),main=paste("LL",mean(unlist(lBoundedTrackInfo[["LL"]]$pathLength)) ) )
hist(unlist(lBoundedTrackInfo[["LE"]]$pathLength),breaks=seq(0,60,1),ylim=c(0,50),main=paste("LE",mean(unlist(lBoundedTrackInfo[["LE"]]$pathLength))  ) )

hist(unlist(lBoundedTrackInfo[["DL"]]$pathLength),breaks=seq(0,60,1),ylim=c(0,50),main=paste("DL",mean(unlist(lBoundedTrackInfo[["DL"]]$pathLength)) ) )
hist(unlist(lBoundedTrackInfo[["DE"]]$pathLength),breaks=seq(0,60,1),ylim=c(0,50),main=paste("DE",mean(unlist(lBoundedTrackInfo[["DE"]]$pathLength))  ) )


plot(lBoundedTrackInfo[["LL"]]$pathLength,lBoundedTrackInfo[["LL"]]$duration)
#plot(datDomainTrajectories$posX,datDomainTrajectories$posY,xlim=c(0,640),ylim=c(0,480),type="l")
```






# Mean-Squared-Displacement over-time is different between groups

A prediction of the theory of *Fickian diffusion is that the mean squared displacement of a ‘random walker’ increases linearly with time*, not *super linearly (for example, quadratically) or sublinearly (for example, as the square root).
Any process that is inconsistent with Fick’s laws  is known as anomalous diffusion: super diffusion leads to superlinear
 growth of the mean squared displacement,  whereas subdiffusion leads to sublinear growth (#viswanathan2010fish).

The MSD at time t {\displaystyle t} t is defined as an ensemble average (statistical mechanics): 
\[
MSD(t) = \<|\vec{x(t)} - \vec{x_0}|^2 = \frac{1}{N}\sum^{N}_{i=1}|x^{(i)}(t) - x^{(i)}(0)  |^2 \>
\]
where N is the number of particles (here trajectories) to be averaged, vector $\vec{x_0}$ is the reference position of the i-th particle and vector $\vec{x(t)}$ is the position fo the i-th particle at time $t$.

```{r mean-squared-displacement calculations , fig.show="hold", out.width="50%", echo=FALSE, cache=TRUE }

#strG <- 'DE'
#hist(ldatDispersion[["40"]][ldatDispersion[["40"]]$groupID == strG,"DisplacementSq"],main=paste(strG,mean(ldatDispersion[["40"]][ldatDispersion[["40"]]$groupID == strG,"DisplacementSq"],na.rm=TRUE) ),xlim=c(0,210))
#hist(ldatDispersion[["20"]][ldatDispersion[["20"]]$groupID == strG,"DisplacementSq"],main=paste(strG,mean(ldatDispersion[["20"]][ldatDispersion[["20"]]$groupID == strG,"DisplacementSq"],na.rm=TRUE) ),xlim=c(0,210))
calcBasicPathStatisticsPerDuration <-function(datDispersion,strG,addPlot=FALSE,powerLawRange = 100)
{
       datGroupDispersion <- datDispersion[datDispersion$groupID %in% strG &
                                          !is.na(datDispersion$DisplacementSq),]
    #dispBreaks <- seq(1,max(datDispersion$DisplacementSq,na.rm=TRUE)+1,15)
    #datGroupDispersion$dispRange <- cut(datGroupDispersion[,"Dispersion" ],breaks=dispBreaks)
    strTitle <- paste("MSD length ", strG,"#",NROW(datGroupDispersion))

    #max(datDispersion$DisplacementSq,na.rm=TRUE)+15
    xbreaks_MSD        <- seq(0,530,15)
    xbreaks_Dispersion <- seq(0,13,0.5)
    xbreaks_Length     <- seq(0,390,10)
    
    #strDispRange <-levels(datGroupDispersion$dispRange)[dispRange]
    #print(strDispRange) 
    if (NROW(datGroupDispersion[ ,"DisplacementSq"]) == 0)
    {
      warning(paste("No rows for MSD ", strG) )
      
      lret<-list(meanPooledMSD=NA,groupID=strG,coeff=NA,ptx_line=NA,pty_line=NA)
      return(lret )
    }
    
    h_MSD_GE <- hist(datGroupDispersion[ ,"DisplacementSq"], breaks=xbreaks_MSD,plot=FALSE)
    h_Dispersion_GE <- hist(datGroupDispersion[ ,"Dispersion"], breaks=xbreaks_Dispersion,plot=FALSE)
    h_Length_GE <- hist(datGroupDispersion[ ,"Length"], breaks=xbreaks_Length,plot=FALSE)
    
    xtick_MSD<-log10(h_MSD_GE$mids)
    xtick_Dispersion<-log10(h_Dispersion_GE$mids)
    xtick_Length<-log10(h_Length_GE$mids)
    
    ##MSD Stat
    lLinModel_GE <- getLogPowerSlope(h_MSD_GE,powerLawRange)
    ## Use Returned list object to add more Data 
    lLinModel_GE$groupID <- strG
    lLinModel_GE$xtickMSD <-xtick_MSD
    lLinModel_GE$logPMFMSD <-log10(100*h_MSD_GE$counts/sum(h_MSD_GE$counts) )
    ## Get MSD per Larva
    lLinModel_GE$meanMSDPerLarva <- tapply(datGroupDispersion[ ,"DisplacementSq"],datGroupDispersion[ ,"expID"],mean)
    lLinModel_GE$sdMSDPerLarva <- tapply(datGroupDispersion[ ,"DisplacementSq"],datGroupDispersion[ ,"expID"],sd)
    lLinModel_GE$countMSDPerLarva <- tapply(datGroupDispersion[ ,"DisplacementSq"],datGroupDispersion[ ,"expID"],NROW)
    # Average over means per larva
    lLinModel_GE$meanGroupMSD <- mean(lLinModel_GE$meanMSDPerLarva,na.rm=T)
    
    lLinModel_GE$meanPooledMSD <- mean(datGroupDispersion[ ,"DisplacementSq"],na.rm=TRUE) ##Add Mean MSD for timeWindow
    lLinModel_GE$sdPooledMSD <- sd(datGroupDispersion[ ,"DisplacementSq"],na.rm=TRUE) ##Add Mean MSD for timeWindow
    lLinModel_GE$countPooledMSD <- NROW(datGroupDispersion[!is.na(datGroupDispersion$DisplacementSq),]) ##Add Mean MSD for timeWindow
    
    ## Path Length
    ##Dispersion Stat - For Each Larva, And As Group
    lLinModel_GE$xtickPathLength <-xtick_Length
    lLinModel_GE$logPMFPathLength <-log10(100*h_Length_GE$counts/sum(h_Length_GE$counts) )
    lLinModel_GE$meanPathLengthPerLarva <- tapply(datGroupDispersion[ ,"Length"],datGroupDispersion[ ,"expID"],mean)
    lLinModel_GE$sdPathLengthPerLarva <- tapply(datGroupDispersion[ ,"Length"],datGroupDispersion[ ,"expID"],sd)
    lLinModel_GE$countPathLengthPerLarva <- tapply(datGroupDispersion[ ,"Length"],datGroupDispersion[ ,"expID"],NROW)

    lLinModel_GE$meanPooledPathLength <- mean(datGroupDispersion[ ,"Length"],na.rm=TRUE) ##Add Mean MSD for timeWindow
    lLinModel_GE$sdPooledPathLength <- sd(datGroupDispersion[ ,"Length"],na.rm=TRUE) ##Add Mean MSD for timeWindow
    lLinModel_GE$countPooledPathLength <- NROW(datGroupDispersion[!is.na(datGroupDispersion$Length),]) ##Add Mean MSD for timeWindow
    
    ##Dispersion Stat - For Each Larva, And As Group
    lLinModel_GE$xtickDispersion <- xtick_Dispersion
    lLinModel_GE$logPMFDispersion <- log10(100*h_Dispersion_GE$counts/sum(h_Dispersion_GE$counts) )
    lLinModel_GE$meanDispersionPerLarva <- tapply(datGroupDispersion[ ,"Dispersion"],datGroupDispersion[ ,"expID"],mean)
    lLinModel_GE$sdDispersionPerLarva <- tapply(datGroupDispersion[ ,"Dispersion"],datGroupDispersion[ ,"expID"],sd)
    lLinModel_GE$countDispersionPerLarva <- tapply(datGroupDispersion[ ,"Dispersion"],datGroupDispersion[ ,"expID"],NROW)

    lLinModel_GE$meanPooledDispersion <- mean(datGroupDispersion[ ,"Dispersion"],na.rm=TRUE) ##Add Mean MSD for timeWindow
    lLinModel_GE$sdPooledDispersion   <- sd(datGroupDispersion[ ,"Dispersion"],na.rm=TRUE) ##Add Mean MSD for timeWindow
    lLinModel_GE$countPooledDispersion <- NROW(datGroupDispersion[!is.na(datGroupDispersion$Dispersion),]) ##Add Mean MSD for timeWindow
    
    return(lLinModel_GE)
}

## A Histogram in Log Scale Of MSD scale
plotLogLogDistribution_MSD <- function(lLinModel_GE,tInter,addPlot=FALSE)
{
    strG <-lLinModel_GE$groupID
    if (!addPlot) 
    {
      plot(lLinModel_GE$xtickMSD,lLinModel_GE$logPMFMSD,
         main=paste(" Log-Log distribution of MSD "),
         xlab="log_10 Mean Squared Displacent (mm)", col=colourDataScheme[strG][[1]], pch=16,
         xlim=c(min(lLinModel_GE$xtickMSD),max(lLinModel_GE$xtickMSD)*1.01),
         ylim=c(-4,3),
         ylab="log N(l) %",xaxt="n" )
        axis(side=1, at=lLinModel_GE$xtickMSD, labels =  as.character(10^lLinModel_GE$xtickMSD))
       #text(x=lLinModel_GE$xtick[seq(0,length(lLinModel_GE$xtick),3)],  par("usr")[3], labels = (10^xtick[seq(0,9,3)]), srt = 45, pos = 1, xpd = TRUE)
    }else
    {
        points(lLinModel_GE$xtickMSD,lLinModel_GE$logPMFMSD,
         main=paste(" Log-Log percentage of MSD " ),
         col=colourDataScheme[strG][[1]], pch=16, ylab="log N(l) %")
    }
    ##Plot Linear Model
    lines(lLinModel_GE$ptx_line,lLinModel_GE$pty_line,lwd=3,col=colourDataScheme[strG][[1]])
  
    ##Distinctivelly show the Distribution Over All Full duration Paths
    if (tInter=="0")
      lines(lLinModel_GE$xtickMSD,lLinModel_GE$logPMFMSD,lwd=3,col="black",lty=2)
      
    return(lLinModel_GE)
}

##Calc the mean pooled MSD from each integration Window and show mean diffusion
plotMSDPerTime <- function(lModelwithMSD,addPlot=FALSE,bUsePooledMean=TRUE)
{
  vMSD <- vector()
  vTimeWindow <- vector()
  for (i in 1:NROW(lModelwithMSD))
  {
    if (!is.null(lModelwithMSD[[i]]$meanPooledMSD)) ##If MSD values exist at this point
    {
      if (bUsePooledMean)
        vMSD[i] <- lModelwithMSD[[i]]$meanPooledMSD
      else ##Use Group Mean
        vMSD[i] <- mean(lModelwithMSD[[i]]$meanMSDPerLarva,na.rm=T) ##Same As groupMean
      
      vTimeWindow[i] <- as.numeric( names(lModelwithMSD[i]) )
    }
   # return(0)
  }
  idxOrder <- order(vTimeWindow)
  #xLim <- c(0,max(vTimeWindow ) *1.10 )
  xLim <- c(2,180 *1.10 ) ##Zero covers -The overall Path Duration
  if (!addPlot)
  {
    plot(vTimeWindow[idxOrder],vMSD[idxOrder],xlim=xLim,ylim=c(0,200),
         col=colourDataScheme[[lModelwithMSD[[1]]$groupID]],
         pch=pointTypeScheme[[lModelwithMSD[[1]]$groupID]],
         xlab="Path duration (sec)", ylab="Mean squared displacement (mm)")
  }else
    points(vTimeWindow[idxOrder],vMSD[idxOrder],
           col=colourDataScheme[[lModelwithMSD[[1]]$groupID]],
           pch=pointTypeScheme[[lModelwithMSD[[1]]$groupID]])
  
  lines(vTimeWindow[idxOrder],vMSD[idxOrder], col=colourDataScheme[[lModelwithMSD[[1]]$groupID]],
        pch=pointTypeScheme[[lModelwithMSD[[1]]$groupID]])
}

##Scan Though all Time Integrations in Data and plot histogram and get MSD mean valus
processMSDPerIntegrationTime <- function(ldatDispersion,strG,lMSDSummaryData,bAddPlot = FALSE)
{

  for (tt in names(ldatDispersion))
  {
    message("Processing MSD for ",strG," T:",tt)
    lMSDSummaryData[[strG]][[as.character(tt)]] <- calcBasicPathStatisticsPerDuration(ldatDispersion[[tt]],strG,bAddPlot)
    bAddPlot <- TRUE
  }
  
  return(lMSDSummaryData)
}

makeMSDPathDurationSummary <- function(vtimeWindows,bParallel=FALSE)
{
  lMSDSummaryData <- list()
  # Process Each Time Interval Sequentially
  for (t in vtimeWindows)
  {
    ldatDispersion <- list()
    #<- readRDS(file=paste0(strDataStore,"/foragingState_Dispersion",t,"sec.rds") ) ##loadDispersionData(forceReload = TRUE,t)
    
    ldatDispersion[[as.character(t)]] <- loadDispersionData(forceReload =  TRUE, t)
    #lMSDSummaryData <- processMSDPathDurationSummary_Parallel(ldatDispersion,strG,lMSDSummaryData)
    ##Make Sub List For Each group - Add the different Time Intervals as sub-lists
    if  (!bParallel)
    {
      for (strG  in vGroups)
      {
          if (is.null(lMSDSummaryData[[strG]] ) ) ##list per twindow integration for this group
            lMSDSummaryData[[strG]] <- list()
          
        lMSDSummaryData <- processMSDPerIntegrationTime(ldatDispersion,strG,lMSDSummaryData)
      }
    }
    ##Clear Memory
    rm(ldatDispersion)
  }
  message("Path stat summary over duration time windows done.")
  message(paste0(strDataExportDir,"statPerPathDurationSummaryResults-",head(vtimeWindows,1),"-",tail(vtimeWindows,1),"sec.rds"))
  saveRDS(lMSDSummaryData,paste0(strDataExportDir,"statPerPathDurationSummaryResults-",head(vtimeWindows,1),"-",tail(vtimeWindows,1),"sec.rds"))
  
  return(lMSDSummaryData)
}
# Main Load/Make MSD Distributios and Mean MSD versus time (Path Duration)

### TODO : NOT COMPLETED - Function needs to be defined within foreach
processMSDPathDurationSummary_Parallel <- function(ldatDispersion,strG,lMSDSummaryData)
{
  library(foreach)
  library(doParallel)

  #setup parallel backend to use many processors
  cores=detectCores()
  cl <- makeCluster(cores[1]-1) #not to overload your computer
  registerDoParallel(cl)

  #.combine=rbind
  lMSDSummaryData <- foreach(strG=vGroups  ) %dopar% {
                        lMSDSummaryData[[strG]] <- list()
                        lMSDSummaryData <- processMSDPerIntegrationTime(ldatDispersion,strG,lMSDSummaryData)
   #do other things if you want
   #lMSDSummaryData #Equivalent to finalMatrix = cbind(finalMatrix, tempMatrix)
                    }

  #stop cluster
  stopCluster(cl)
return(lMSDSummaryData)
}

rm(ldatDispersion)
ldatDispersion <- list()
lLinModel <- list() ##Start new list Containing The mean Vals per group per time

vtimeWindows <- getAvailablePathTimewindows()
rm(lMSDSummaryData)
try(
  lMSDSummaryData <<- readRDS(paste0(strDataExportDir,"statPerPathDurationSummaryResults-",min(vtimeWindows),"-",max(vtimeWindows),"sec.rds"))
)
if (!exists("lMSDSummaryData"))
{
  lMSDSummaryData <<- makeMSDPathDurationSummary(vtimeWindows)
  #lMSDSummaryData <- makeMSDPathDurationSummary_Parallel
}

```










```{r dispersion among larvae across time, fig.show="hold",fig.cap="Mean dispersions over path lengths of increasing durations ", out.width="50%", echo=FALSE, cache=FALSE}

plotDispersionVsTimePerLarva <- function(lModelwithMSD,addPlot=FALSE)
{
  
  lMSD <- list()
  vTimeWindow <- vector()
  for (i in 1:NROW(lModelwithMSD))
  {
    if (!is.null(lModelwithMSD[[i]]$meanDispersionPerLarva))
    {
        lMSD[[i]] <- lModelwithMSD[[i]]$meanDispersionPerLarva
        vTimeWindow[i] <-as.numeric( names(lModelwithMSD[i]) )
    }
  }
  ##Now plot MSD evolution of each larva
  datMeanMSDVsTimePerLarva <- data.frame(do.call(rbind,lMSD))
  if (!addPlot)
    plot(vTimeWindow,datMeanMSDVsTimePerLarva[,1],type="p",col=colourDataScheme[lModelwithMSD[[1]]$groupID][[1]],ylim=c(0,13),ylab="Dispersion (mm)",xlab="Time (sec)")
  for (i in 1:ncol(datMeanMSDVsTimePerLarva))
    lines(vTimeWindow,datMeanMSDVsTimePerLarva[,i],type="p",col=colourDataScheme[lModelwithMSD[[1]]$groupID][[1]])
  
} 

plotDispersionVsTimePerLarva(lMSDSummaryData[["NE"]],FALSE)
plotDispersionVsTimePerLarva(lMSDSummaryData[["NL"]],FALSE)
title(main="NL Dispersion ")
plotDispersionVsTimePerLarva(lMSDSummaryData[["LE"]],FALSE)
plotDispersionVsTimePerLarva(lMSDSummaryData[["LL"]],FALSE)
title(main="LL Dispersion ")
plotDispersionVsTimePerLarva(lMSDSummaryData[["DE"]],FALSE)
plotDispersionVsTimePerLarva(lMSDSummaryData[["DL"]],FALSE)
title(main="DL Dispersion ")  
```



## Dispersion over time - Clearly Distinct for LE

In the initial sections I took Marquez et al 2019 regime to estimate dispersions given a 5sec window. But how dispersions change over time is uknown. Lets have a look:



```{r  dispersion over log-log distribution , fig.show="hold", out.width="50%", echo=FALSE, cache=TRUE }

## A Histogram in Log Scale Of MSD scale
plotLogLogDistribution_Dispersion <- function(lLinModel_GE,addPlot=FALSE)
{
    strG <-lLinModel_GE$groupID
    if (!addPlot) 
    {
      plot(lLinModel_GE$xtickDispersion,lLinModel_GE$logPMFDispersion,
         main=paste(" Log-Log distribution of Dispersion "),
         xlab="log_10 Dispersion (mm)", col=colourDataScheme[strG][[1]], pch=16,
         xlim=c(min(lLinModel_GE$xtickDispersion,na.rm=TRUE),max(lLinModel_GE$xtickDispersion,na.rm=TRUE)*1.01),
         ylim=c(-4,3),
         ylab="log N(l) %",xaxt="n" ,type="b")
        axis(side=1, at=lLinModel_GE$xtickDispersion, labels =  as.character(10^lLinModel_GE$xtickDispersion))
       #text(x=lLinModel_GE$xtick[seq(0,length(lLinModel_GE$xtick),3)],  par("usr")[3], labels = (10^xtick[seq(0,9,3)]), srt = 45, pos = 1, xpd = TRUE)
    }else
    {
        points(lLinModel_GE$xtickDispersion,lLinModel_GE$logPMFDispersion,
         main=paste(" Log-Log percentage of Dispersion " ),type="b",
         xlab="log_10 Dispersion (mm)", col=colourDataScheme[strG][[1]], pch=16, ylab="log N(l) %")
    }
    ##Plot Linear Model
    lines(lLinModel_GE$ptx_line,lLinModel_GE$pty_line,lwd=3,col=colourDataScheme[strG][[1]])
  
    return(lLinModel_GE)
}

##Collect the mean MSD from each Dispersion Calcl integration Window and show mean diffusion
plotDispersionPerTime <- function(lModelwithDispersion,addPlot=FALSE)
{
  vDispersion <- vector()
  vTimeWindow <- vector()
  for (i in 1:NROW(lModelwithDispersion))
  {
    if (!is.null(lModelwithDispersion[[i]]$meanDispersion))
    {
      vDispersion[i] <- lModelwithDispersion[[i]]$meanDispersion
      vTimeWindow[i] <-as.numeric( names(lModelwithDispersion[i]) )
    }
   # return(0)
  }
  idxOrder <- order(vTimeWindow)
  xLim <- c(0,max(vTimeWindow ) *1.10 )
  if (!addPlot)
  {
    plot(vTimeWindow[idxOrder],vDispersion[idxOrder],xlim=xLim,ylim=c(0,13),
         col=colourDataScheme[[lModelwithDispersion[[1]]$groupID]],
         pch=pointTypeScheme[[lModelwithDispersion[[1]]$groupID]],
         xlab="Path duration (sec)", ylab="Dispersion (mm)")
  }else
    points(vTimeWindow[idxOrder],vDispersion[idxOrder],
           col=colourDataScheme[[lModelwithDispersion[[1]]$groupID]],
           pch=pointTypeScheme[[lModelwithDispersion[[1]]$groupID]])
  
  lines(vTimeWindow[idxOrder],vDispersion[idxOrder], col=colourDataScheme[[lModelwithDispersion[[1]]$groupID]],
        pch=pointTypeScheme[[lModelwithDispersion[[1]]$groupID]])
}

# Main Load/Make MSD Distributios and Mean MSD versus time (Path Duration)

vGroups <- c("LL","LE","NL","NE","DL","DE")
vsmallTimeWindows <- c(1,2,4,5,6,7,8,10,15,20,30,40,50,60)
vLargeScaletimeWindows <- c(0,2,10,40,80,120,180,200,260) #360 No Data
#vtimeWindows <- c(vsmallTimeWindows,70,80,90,95,98,100,120,180)# c(1,2,4) # vsmallTimeWindows##c(4,10,20,80,200,260,360)
##Process *  Serially * So we do not run out of memory
# Results are plotted and Aggregated In lLinModel

try(
  {
  rm(lMSDSummaryData);
lMSDSummaryData <<- readRDS(paste0(strDataExportDir,"statPerPathDurationSummaryResults-",min(vtimeWindows),"-",max(vtimeWindows),"sec.rds"))
}
)
if (!exists("lMSDSummaryData"))
{ ##Same As Above - Repeated Here IN case we want to run this independently
  lMSDSummaryData <<- makeMSDPathDurationSummary(vtimeWindows)
}
  
##Now Plot All processed Results results
for (strG  in vGroups)
{
  bAddPlot <- FALSE
 for (tt in names( lMSDSummaryData[[strG]]) )
  {
    plotLogLogDistribution_Dispersion(lMSDSummaryData[[strG]][[as.character(tt)]],bAddPlot )
   bAddPlot <- TRUE
  }
}


```



```{r Dispersion over time , fig.cap="Dispersion for LF spontaneous grows distinctively fast, in agreement with MSD", fig.show="hold", out.width="100%", echo=FALSE, cache=FALSE}

##Get Distribution of MSD and Mean MSD for each time integration window 
##load Precalc Results
  plotDispersionPerTime(lMSDSummaryData[["NE"]])
  plotDispersionPerTime(lMSDSummaryData[["NL"]],TRUE)
  plotDispersionPerTime(lMSDSummaryData[["LE"]],TRUE)
  plotDispersionPerTime(lMSDSummaryData[["LL"]],TRUE)
  plotDispersionPerTime(lMSDSummaryData[["DE"]],TRUE)
  plotDispersionPerTime(lMSDSummaryData[["DL"]],TRUE)
  
  legend("topright", legend=names(colourDataScheme)[4:9],
         col=unlist(colourDataScheme[names(colourDataScheme)[4:9]]),
         pch=unlist(pointTypeScheme[names(colourDataScheme)[4:9]]) )

# legend("topright", 
#            legend=c(paste("Spont μ",format(lLinModel_DE[[1]]$coeff,digits=2)),
#                     paste("Evoked μ",format(lLinModel_DL[[1]]$coeff,digits=2) ) ),
#        col=c(colourDataScheme$DE ,colourDataScheme$DL) ,pch=c(16,16) )

```

:::
{#figDispersionPerTime}

As with the development of MSD over time, I also find that Dispersion is distinct for LE, and thus with experience larvae learn when to initiate exploration, (at sooner than  controls) .


## Comparing Mean Path Lengths

```{r path-length larval-mean across time, fig.show="hold",fig.cap="Mean group (mean per larva) path-length with increasing duration ", out.width="50%", echo=FALSE, cache=FALSE}

# Collect the mean PathLength from each Dispersion Calcl integration Window and show mean diffusion
# Path Length Mean
plotMeanPathLengthVsTime <- function(lModelwithMSD,addPlot=FALSE, bUsePooledMean=TRUE)
{
  vPathLength <- vector()
  vTimeWindow <- vector()
  for (i in 1:NROW(lModelwithMSD))
  {
    if (!is.null(lModelwithMSD[[i]]$meanPooledPathLength))
    {
      if (bUsePooledMean)
        vPathLength[i] <- lModelwithMSD[[i]]$meanPooledPathLength
      else ##Use Group Mean
        vPathLength[i] <- mean(lModelwithMSD[[i]]$meanPathLength,na.rm=TRUE)
      
      vTimeWindow[i] <-as.numeric( names(lModelwithMSD[i]) )
    }
   # return(0)
  }
  idxOrder <- order(vTimeWindow)
  xLim <- c(0,max(vTimeWindow ) *1.10 )
  if (!addPlot)
  {
    plot(vTimeWindow[idxOrder],vPathLength[idxOrder],xlim=xLim,ylim=c(0,200),
         col=colourDataScheme[[lModelwithMSD[[1]]$groupID]],
         pch=pointTypeScheme[[lModelwithMSD[[1]]$groupID]],
         xlab="Path duration (sec)", ylab="mean path length (mm)")
  }else
    points(vTimeWindow[idxOrder],vPathLength[idxOrder],
           col=colourDataScheme[[lModelwithMSD[[1]]$groupID]],
           pch=pointTypeScheme[[lModelwithMSD[[1]]$groupID]])
  
  lines(vTimeWindow[idxOrder],vPathLength[idxOrder], col=colourDataScheme[[lModelwithMSD[[1]]$groupID]],
        pch=pointTypeScheme[[lModelwithMSD[[1]]$groupID]])
}


plotMeanPathLengthVsTime(lMSDSummaryData[["NE"]],FALSE,FALSE)
plotMeanPathLengthVsTime(lMSDSummaryData[["NL"]],TRUE,FALSE)
plotMeanPathLengthVsTime(lMSDSummaryData[["LE"]],TRUE,FALSE)
plotMeanPathLengthVsTime(lMSDSummaryData[["LL"]],TRUE,FALSE)
title(main="Mean group path length ")
plotMeanPathLengthVsTime(lMSDSummaryData[["DE"]],TRUE,FALSE)
plotMeanPathLengthVsTime(lMSDSummaryData[["DL"]],TRUE,FALSE)

plotMeanPathLengthVsTime(lMSDSummaryData[["NE"]],FALSE,TRUE)
plotMeanPathLengthVsTime(lMSDSummaryData[["NL"]],TRUE,TRUE)
plotMeanPathLengthVsTime(lMSDSummaryData[["LE"]],TRUE,TRUE)
plotMeanPathLengthVsTime(lMSDSummaryData[["LL"]],TRUE,TRUE)
title(main="Pooled Mean path length ")
plotMeanPathLengthVsTime(lMSDSummaryData[["DE"]],TRUE,TRUE)
plotMeanPathLengthVsTime(lMSDSummaryData[["DL"]],TRUE,TRUE)


```

Interestignly, the above plot is representative of the speed of movement over time. The mean distance travelled over long periods of time depends on experience. 
  - NF show constant speed across time, regardless of how long the duration of path is, They travel more in the presence of prey 
  - LF change speed over time, Without prey, the speed up after a minute, and with prey they slow down.
        -*(Show whether this is adaptive behaviour or simply a heteregenous population)*
  - DF, similar to LF  but slower

### Path Length Distributions

```{r path-length among larvae across time, fig.show="hold",fig.cap="Distribution of larval mean path-lengths with increasing duration ", out.width="50%", echo=FALSE, cache=FALSE}

## This plots The mean points Per Larvae- Revealing the Distribution
plotPathVsTimePerLarva <- function(lModelwithMSD, addPlot=FALSE)
{
  
  lMSD <- list()
  vTimeWindow <- vector()
  for (i in 1:NROW(lModelwithMSD))
  {
    if (!is.null(lModelwithMSD[[i]]$meanPathLengthPerLarva))
    {
        lMSD[[i]] <- lModelwithMSD[[i]]$meanPathLengthPerLarva
        vTimeWindow[i] <-as.numeric( names(lModelwithMSD[i]) )
    }
  }
  ##Now plot MSD evolution of each larva
  datMeanMSDVsTimePerLarva <- data.frame(do.call(rbind,lMSD))
  if (!addPlot)
    plot(vTimeWindow,datMeanMSDVsTimePerLarva[,1],type="p",col=colourDataScheme[lModelwithMSD[[1]]$groupID][[1]],
         ylim=c(0,200),xlim=c(0,250),ylab="mean larval path length (mm)",xlab="Time (sec)")
  for (i in 1:ncol(datMeanMSDVsTimePerLarva))
    lines(vTimeWindow,datMeanMSDVsTimePerLarva[,i],type="p",col=colourDataScheme[lModelwithMSD[[1]]$groupID][[1]])
  
} 

plotPathVsTimePerLarva(lMSDSummaryData[["NE"]],FALSE)
plotPathVsTimePerLarva(lMSDSummaryData[["NL"]],FALSE)
title(main="NL Mean path length per larva")
plotPathVsTimePerLarva(lMSDSummaryData[["LE"]],FALSE)
plotPathVsTimePerLarva(lMSDSummaryData[["LL"]],FALSE)
title(main="LL Mean path length per larva")
plotPathVsTimePerLarva(lMSDSummaryData[["DE"]],FALSE)
plotPathVsTimePerLarva(lMSDSummaryData[["DL"]],FALSE)
title(main="DL Mean path length per larva")  

```


Looking at the mean path length against time of each larva:

  -Experienced larvae move faster, ie travelling larger distance over the equal amounts of path duration to controls.
  - The LE paths are the shortest in duration, and the fastest, supporting that the LE larvae move out of the ROI quicker.
 - NF seem to accellerate movement in the presence of prey and so does DF
 - NF shows suprising linear rise in path-length with time - constant speed (homogeneous population perhaps) in both conditions (E/S)
 

*I need to fit linear functions to get distributions of estimated travel-speed per larvae.*
 


```{r prob-of-path-length, fig.cap="Probability of path duration reveals differences in the amount of time larva dwell within an area. LF spontaneous move out faster than controls, with an exponent that appears near the optimal 2"}

plot_PathLengthDistribution <- function(lMSDGroupSummaryData,addPlot=FALSE,linRegion=12)
{
  vLarvaFraction <- vector()

    ## 0 Index Contains PAth lengths Unconstrained of duration
    vLarvaFraction <- lMSDGroupSummaryData[["0"]]$logPMFPathLength
    vPathLengths  <- lMSDGroupSummaryData[["0"]]$xtickPathLength
    
    proportion <- (unlist(vLarvaFraction[(10^vPathLengths) > linRegion]))
    length <- vPathLengths[(10^vPathLengths) > linRegion]
    linFit <- lm(proportion[proportion >0 ] ~ length[proportion >0 ] )
    #linFit <- lm(proportion~length,data=datHist[!is.infinite(datHist$proportion),] )
  
    y_linModel <- (linFit$coefficients[1] + (linFit$coefficients[2]* (linFit$model$length ) ) )
    x_linModel <- linFit$model$length
  
  if (!addPlot)
  {
    plot((vPathLengths),(unlist(vLarvaFraction)),type="b",
         col=colourDataScheme[lMSDGroupSummaryData[[1]]$groupID][[1]],pch=pointTypeScheme[lMSDGroupSummaryData[[1]]$groupID][[1]],
         ylim=c(-1,2),xlim=c(0,2.5),ylab="log % of larvae ",xlab="log path length (mm)",xaxt="n" )
    
    axXTick <- axisTicks(c(0,max(length)) ,log=TRUE)
    axis(side=1, at=log10(axXTick), labels =  as.character(axXTick) ) 
    
  }
  #for (i in 1:NROW(lMSDGroupSummaryData))
    lines((vPathLengths),(unlist(vLarvaFraction)),type="b",
          col=colourDataScheme[lMSDGroupSummaryData[[1]]$groupID][[1]],pch=pointTypeScheme[lMSDGroupSummaryData[[1]]$groupID][[1]])
  
  ##Add Linear Model On PowerLaw Drop
    lines(x_linModel,y_linModel,lwd=2,lty=2,col=colourDataScheme[lMSDGroupSummaryData[[1]]$groupID][[1]])
    return(linFit)
} 

#lMSDSummaryData <- 
linMod <- list()
linMod[["NE"]] <- plot_PathLengthDistribution(lMSDSummaryData[["NE"]])
linMod[["NL"]] <- plot_PathLengthDistribution(lMSDSummaryData[["NL"]],TRUE)

linMod[["LE"]] <- plot_PathLengthDistribution(lMSDSummaryData[["LE"]],TRUE)
linMod[["LL"]] <- plot_PathLengthDistribution(lMSDSummaryData[["LL"]],TRUE)

linMod[["DE"]] <- plot_PathLengthDistribution(lMSDSummaryData[["DE"]],TRUE)
linMod[["DL"]] <- plot_PathLengthDistribution(lMSDSummaryData[["DL"]],TRUE)
title(main=" Distribution of path lengths ")

vLegend<-vector()
for (i in 4:9)
  vLegend[i-3] <- paste(names(colourDataScheme)[i],"μ=", format(linMod[[ names(colourDataScheme)[i] ]]$coeff[2],digits=2) )

legend("topright", legend=vLegend,
         col=unlist(colourDataScheme[names(colourDataScheme)[4:9]]),
         pch=unlist(pointTypeScheme[names(colourDataScheme)[4:9]]) )

#plot(lMSDSummaryData$LL$`0`$logPMFPathLength)


```
 
## Probability of staying within bounded recording area shows LF move out quickest

The above Dispersion and MSD plots analysed at the level of each larva against time raise gave me the idea that it may be useful to describe differences in the motion between groups in terms of the probability of staying within a bounded area $A$ with increasing time $P(within A | t)$ , or $P_A(t)$.
This can be calculated through the fraction of points larvae that remain observable with increasing path duration $T$, because larvae are more likely to leave the arena with increasing path-duration, and thus the probaility of observing a path-length longer than $T>X$, can be indicative of difference in how the disperse, or explore space.

```{r prob-of-path-duration, fig.cap="Probability of path duration reveals differences in the amount of time larva dwell within an area. LF spontaneous move out faster than controls, with an exponent that appears near the optimal 2"}


plot_ProbOfPathDuration <- function(lMSDGroupSummaryData,addPlot=FALSE,linRegion=12)
{
 lLarvaFraction <- list()
  vTimeWindow <- vector()
  for (i in 1:NROW(lMSDGroupSummaryData))
  {
    if (!is.null(lMSDGroupSummaryData[[i]]$countMSDPerLarva))
    { ##Divide as a fraction of larval population count with the smalles path duration
        lLarvaFraction[[i]] <- nrow(lMSDGroupSummaryData[[i]]$countMSDPerLarva)/nrow(lMSDGroupSummaryData[[1]]$countMSDPerLarva)
        vTimeWindow[i] <-as.numeric( names(lMSDGroupSummaryData[i]) )
    }
  }
    proportion <- log10(unlist(lLarvaFraction[vTimeWindow > linRegion]))
    duration <- log10(vTimeWindow[vTimeWindow > linRegion]) 
    linFit <- lm(proportion ~ duration )
    #linFit <- lm(proportion~length,data=datHist[!is.infinite(datHist$proportion),] )
  
  y_linModel <- (linFit$coefficients[1] + (linFit$coefficients[2]* (linFit$model$duration ) ) )
  x_linModel <- linFit$model$duration
  
  
  if (!addPlot)
  {
    plot(log10(vTimeWindow),log10(unlist(lLarvaFraction)),type="b",
         col=colourDataScheme[lMSDGroupSummaryData[[1]]$groupID][[1]],pch=pointTypeScheme[lMSDGroupSummaryData[[1]]$groupID][[1]],
         ylim=c(-2,1),xlim=c(0,2.5),ylab="log fraction of larvae ",xlab="log time to escape circular ROI (sec)",xaxt="n" )
    axis(side=1, at=log10(vTimeWindow), labels =  as.character(vTimeWindow) ) 
  }
  #for (i in 1:NROW(lMSDGroupSummaryData))
    lines(log10(vTimeWindow),log10(unlist(lLarvaFraction)),type="b",
          col=colourDataScheme[lMSDGroupSummaryData[[1]]$groupID][[1]],pch=pointTypeScheme[lMSDGroupSummaryData[[1]]$groupID][[1]])
  
  ##Add Linear Model On PowerLaw Drop
    lines(x_linModel,y_linModel,lwd=2,lty=2,col=colourDataScheme[lMSDGroupSummaryData[[1]]$groupID][[1]])
    
    #message(lMSDGroupSummaryData[[1]]$groupID[[1]], linFit$coefficients )
    
    
    
    return(linFit)
} 
#lMSDSummaryData <- 
linMod <- list()
linMod[["NE"]] <- plot_ProbOfPathDuration(lMSDSummaryData[["NE"]])
linMod[["NL"]] <- plot_ProbOfPathDuration(lMSDSummaryData[["NL"]],TRUE)

linMod[["LE"]] <- plot_ProbOfPathDuration(lMSDSummaryData[["LE"]],TRUE)
linMod[["LL"]] <- plot_ProbOfPathDuration(lMSDSummaryData[["LL"]],TRUE)

linMod[["DE"]] <- plot_ProbOfPathDuration(lMSDSummaryData[["DE"]],TRUE)
linMod[["DL"]] <- plot_ProbOfPathDuration(lMSDSummaryData[["DL"]],TRUE)
title(main=" Distribution of path durations ")

vLegend<-vector()
for (i in 4:9)
  vLegend[i-3] <- paste(names(colourDataScheme)[i],"μ=", format(linMod[[ names(colourDataScheme)[i] ]]$coeff[2],digits=2) )

legend("topright", legend=vLegend,
         col=unlist(colourDataScheme[names(colourDataScheme)[4:9]]),
         pch=unlist(pointTypeScheme[names(colourDataScheme)[4:9]]) )


```

The above mean path lengths are equivalent to the mean path length between entering and exiting a circlular region, as the depict the length of path from the time the larva enters the tracking ROI until its exit.

The probability of path duration plot gives some clarity on what is actually happening. We estimate this probability by counting the fraction of larvae that show paths with duration of $T$ (perhaps I could/should be counting the number of paths per larvae maybe?)
In any case paths above a particular duration, are not generated because the larva has moved out of view by time T, and thus is out of bounds. This is equivalent to measuring Exit times from the ~22mm tracking ROI. Clearly LF are behaving distinctively, with shorter exit times in both Spontaneous and Evoked conditions. The Evoked LF are similar to the spontaneous DF,NF, while **LF larva in absence of prey move out of the region quicker than controls**

Linear fitting to the log-log curves can approximate the power law exponent. 




## Mean Squared Displacement - Examining diffusion type

### MSD distributions over full paths

```{r mean-squared-displacement Log-Log distributions , fig.show="hold", out.width="50%", echo=FALSE, cache=TRUE }

##Now Plot All processed Results results
for (strG  in vGroups)
{
  bAddPlot <- FALSE
 for (tt in names( lMSDSummaryData[[strG]]) )
  {
   
    plotLogLogDistribution_MSD(lMSDSummaryData[[strG]][[as.character(tt)]],tt,bAddPlot )
    bAddPlot <- TRUE
 }
  legend("bottomleft",lty=c(2,NA),pch=c(NA,16),legend=c("Full path",paste("Fixed duration",names( lMSDSummaryData[[strG]])[1],"-",tt )) )
}

```

MSD over full event path duration looks the same across groups.

### MSD over time 

The duration-contrained MSDs however do not look  similar between conditions and groups:
  - *LF evoked contains larger MSDs than spontaneous - Same in NF but prob not in DF*

```{r mean-squared-distance over time on pooled data, fig.show="hold",fig.cap="Pooled Mean squared distance over time for LF spontaneous shows distinctive quick growth", out.width="100%", echo=FALSE, cache=FALSE}



##Get Distribution of MSD and Mean MSD for each time integration window 
##load Precalc Results
  plotMSDPerTime(lMSDSummaryData[["NE"]],FALSE,TRUE)
  plotMSDPerTime(lMSDSummaryData[["NL"]],TRUE,TRUE)
  plotMSDPerTime(lMSDSummaryData[["LE"]],TRUE,TRUE)
  plotMSDPerTime(lMSDSummaryData[["LL"]],TRUE,TRUE)
  plotMSDPerTime(lMSDSummaryData[["DE"]],TRUE,TRUE)
  plotMSDPerTime(lMSDSummaryData[["DL"]],TRUE,TRUE)
  title(main="Pooled Mean")
  legend("topright", legend=names(colourDataScheme)[4:9],
         col=unlist(colourDataScheme[names(colourDataScheme)[4:9]]),
         pch=unlist(pointTypeScheme[names(colourDataScheme)[4:9]]) )

  
  plotMSDPerTime(lMSDSummaryData[["NE"]],FALSE,FALSE)
  plotMSDPerTime(lMSDSummaryData[["NL"]],TRUE,FALSE)
  plotMSDPerTime(lMSDSummaryData[["LE"]],TRUE,FALSE)
  plotMSDPerTime(lMSDSummaryData[["LL"]],TRUE,FALSE)
  plotMSDPerTime(lMSDSummaryData[["DE"]],TRUE,FALSE)
  plotMSDPerTime(lMSDSummaryData[["DL"]],TRUE,FALSE)
  title(main="Group Mean")
  legend("topright", legend=names(colourDataScheme)[4:9],
         col=unlist(colourDataScheme[names(colourDataScheme)[4:9]]),
         pch=unlist(pointTypeScheme[names(colourDataScheme)[4:9]]) )
# legend("topright", 
#            legend=c(paste("Spont μ",format(lLinModel_DE[[1]]$coeff,digits=2)),
#                     paste("Evoked μ",format(lLinModel_DL[[1]]$coeff,digits=2) ) ),
#        col=c(colourDataScheme$DE ,colourDataScheme$DL) ,pch=c(16,16) )

```

What is clear is that MSD becomes truncated around 10 seconds in, and that the LE grows the fastest. 
By that time the radius of displacement covered on average for LE is `r sqrt(lMSDSummaryData[["LE"]][["10"]]$meanGroupMSD)`mm, while for NE  `r sqrt(lMSDSummaryData[["NE"]][["10"]]$meanGroupMSD)`, for DE `r sqrt(lMSDSummaryData[["NE"]][["10"]]$meanGroupMSD)`

```{r mean-squared-distance over time distribution over larva , fig.show="hold",fig.cap=" Mean squared distance for paths of increasing duration.", out.width="50%", echo=FALSE, cache=FALSE}

##Get Distribution of MSD and Mean MSD for each time integration window 
##load Precalc Results
xbreaks = seq(0,210,10)
t <- as.character(vtimeWindows[9])
plotMSDVsTimePerLarva <- function(lModelwithMSD,addPlot=FALSE)
{
  
  lMSD <- list()
  vTimeWindow <- vector()
  for (i in 1:NROW(lModelwithMSD))
  {
    if (!is.null(lModelwithMSD[[i]]$meanMSDPerLarva))
    {
        lMSD[[i]] <- lModelwithMSD[[i]]$meanMSDPerLarva
        vTimeWindow[i] <-as.numeric( names(lModelwithMSD[i]) )
    }
  }
  ##Now plot MSD evolution of each larva
  datMeanMSDVsTimePerLarva <- data.frame(do.call(rbind,lMSD))
  if (!addPlot)
    plot(vTimeWindow,datMeanMSDVsTimePerLarva[,1],type="p",
         col=colourDataScheme[lModelwithMSD[[1]]$groupID][[1]],ylim=c(0,250),xlab="Time (sec)",ylab="MSD (mm)",xlim=c(0,180))
  for (i in 1:ncol(datMeanMSDVsTimePerLarva))
    lines(vTimeWindow,datMeanMSDVsTimePerLarva[,i],type="p",col=colourDataScheme[lModelwithMSD[[1]]$groupID][[1]])
  
} 

plotMSDVsTimePerLarva(lMSDSummaryData[["NE"]],FALSE)
plotMSDVsTimePerLarva(lMSDSummaryData[["NL"]],FALSE)
title(main="NL MSD ")
plotMSDVsTimePerLarva(lMSDSummaryData[["LE"]],FALSE)
plotMSDVsTimePerLarva(lMSDSummaryData[["LL"]],FALSE)
title(main="LL MSD ")
plotMSDVsTimePerLarva(lMSDSummaryData[["DE"]],FALSE)
plotMSDVsTimePerLarva(lMSDSummaryData[["DL"]],FALSE)
title(main="DL MSD ")  
  #legend("topright", legend=names(colourDataScheme)[4:9],
  #       col=unlist(colourDataScheme[names(colourDataScheme)[4:9]]),
  #       pch=unlist(pointTypeScheme[names(colourDataScheme)[4:9]]) )

```

The mean of the mean squared displacement confirms the finding:  **Movement in absence and presence of prey differs between groups in manner that depends on experience **
Looking at group mean and pooled means essentially shows the same differences, only *group mean shows waves of LE leaving the recording area*.
I then examine the distribution of mean MSD among larvae and find that LE clearly advance to higher MSDs in spontaneous conditions.

### MSD to path-length for evidence of super-Diffusion - (Integrate time out)

Lets now look at how Mean squared distance increases with path length. 
The distance is measured over an arbitrary starting point chosen to be at some X sec in the past. 
We investigate this over a range of integration periods, from 2 to 10 .. T seconds
If the animals moved at constant velocity then path length could be a serrogate for time. Instead here we have regular bout movent, with pauses likely possible, and so the different integration times allow us to combine similar path-lengths, which took different times to develop, but nevertheless examine their diffusive properties through MSD, regardless of time.


<!--resulting plots show **evidence of superdiffusion **-->

```{r  mean-squared-distance over path-length , fig.show="hold", out.width="100%", echo=FALSE, cache=TRUE}
## iNvariance Principle Theoretical Mean Path Length
theoreticalMeanLength <- function(D,propFactor=1.5)
{
  A <- pi*( (D)^2)
  C <- 2*pi*(D)
  return(round(100*(propFactor* pi*A/C)) /100 )
}
##Integrate time out, and plot MSD per path-length
# ie legth to hit the boundary of the observation circle, is only proportional to the circle (in 2D), volume in 3D- 
process_MSDVsPathLengthData <- function(ldatDispersion,strGroupID,addPlot=FALSE)
{
  YLIM <- 200
  dispBreaks <- seq(1,40,2)
  vmeanPooledMSDPerPathOft  <- list()
  vsdPooledMSDPerPathOft    <- list()
  vcountPooledMSDPerPathOft <- list()
  message("Extracting ", strGroupID )

  datGroupDispersion <- ldatDispersion[ldatDispersion$groupID %in% strGroupID & 
                                                !is.na(ldatDispersion$Length) ,]
  if (NROW(datGroupDispersion) == 0)
  {
    warning("No path length data for ", strGroupID)
    return(list(muMSDPerT=NA,sdPooledMSDPerT=NA,N=NA,breaks=NA))
  }

  datGroupDispersion$dispRange <- cut(datGroupDispersion[datGroupDispersion$groupID %in% strGroupID ,"Length" ],breaks=dispBreaks)
  
  vmeanPooledMSDPerPathOft  <- tapply(datGroupDispersion$DisplacementSq,datGroupDispersion$dispRange, mean,na.rm=TRUE)
  vcountPooledMSDPerPathOft <- tapply(datGroupDispersion$DisplacementSq,datGroupDispersion$dispRange, NROW)
  vsdPooledMSDPerPathOft    <- tapply(datGroupDispersion$DisplacementSq,datGroupDispersion$dispRange, sd,na.rm=TRUE)
  names(dispBreaks)=names(vmeanPooledMSDPerPathOft)
  #boxplot(datGroupDispersion$Length~datGroupDispersion$dispRange,main=strTitle,col=colourDataScheme[[strGroupID]],ylim=c(0,35))
  return(list(muMSDPerT=vmeanPooledMSDPerPathOft,sdPooledMSDPerT=vsdPooledMSDPerPathOft,N=vcountPooledMSDPerPathOft,breaks=dispBreaks[1:length(vmeanPooledMSDPerPathOft)]  ) )
}

plot_MSDPerPathLengthSummary <- function(lMSDPathLStat)
{
  
    strTitle <- paste("mean MSD per path length", strGroupID,"#")

  if (!addPlot)
  {
    plot(seq(1,max(dispBreaks),length.out = NROW(vmeanPooledMSDPerPathOverAllt)),
         vmeanPooledMSDPerPathOverAllt,pch=pointTypeScheme[[strGroupID]],main=strTitle,xlab="Path Length (mm)",
         ylim=c(0,YLIM),xlim=c(0,max(dispBreaks)),col=colourDataScheme[[strGroupID]],cex=0.7 )
  }else
  {
    points(seq(1,max(dispBreaks),length.out = NROW(vmeanPooledMSDPerPathOverAllt)),
         vmeanPooledMSDPerPathOverAllt,pch=16,main=strTitle,xlab="Path Length (mm)",
         col=colourDataScheme[[strGroupID]],cex=0.7 )
    lines(seq(1,max(dispBreaks),length.out = NROW(vmeanPooledMSDPerPathOverAllt)),
         vmeanPooledMSDPerPathOverAllt,lwd=1,lty=lineTypeScheme[[strGroupID]])
  }
  
  if (!addPlot)
  {
    propFactor <- 1.0
    rpoints <- seq(0.5,max(dispBreaks), length.out = NROW(vmeanPooledMSDPerPathOverAllt) )
    points(rpoints,theoreticalMeanLength(rpoints,propFactor ),pch=2,cex=0.8 ) #Low Lim
    points(seq(2,max(dispBreaks),1),theoreticalMeanLength(seq(2,max(dispBreaks),1),propFactor ),pch=2,cex=0.5 ) #Up Lim
    points(seq(1,max(dispBreaks),1),theoreticalMeanLength(seq(1,max(dispBreaks),1),propFactor ),pch=2,cex=0.5 ) #Up Lim
    legend("topleft",pch=c(16,2),legend=c("Data","Theory"),col=c(colourDataScheme[[strGroupID]],"black") )
  }
  
}

#pdf(file= paste(strPlotExportPath,"/foraging/plot_meanPathLengthPerMSD.pdf",sep=""),width=7,height=7)
## bottom, left,top, right
#par(mar = c(4.3,4.3,2,1))
makeMSDPathLengthSummary <- function ()
{
  #vtimeWindows <- vsmallTimeWindows #c(1,2,10) #
  ##Load All
  baddPlot <- FALSE
  lMSDStat <- list()
  datmeanPooledMSDPerPathOft <- data.frame()
  ## Loop to sequantially load and process Dispersion data across time scales - freeing memory before re-allocating
  for (strG in vGroups)
  {
    lMSDStat[[strG]] <- list()  
    
    for (t in vtimeWindows)
    { 
      
      rm(ldatDispersion)   #Clear Mem
      ldatDispersion<- list()
      print (t)
      ##Load MSD /Dispersion/ Path Data
      ldatDispersion[[as.character(t)]]<- loadDispersionData(TRUE,t) #readRDS(file=paste0(strDataExportDir,"/foragingState_Dispersion",t,"sec.rds") ) 
      
      lMSDStat[[strG]][[as.character(t)]] <- process_MSDVsPathLengthData(ldatDispersion[[as.character(t)]],strG)
      
      #plotMSDPerIntegrationTime(ldatDispersion,"NE",lLinModel)
    
      datNewTable <- data.frame(do.call(cbind, lMSDStat[[strG]][[as.character(t)]] ))
      datNewTable$T <- as.character(t)
      datNewTable$groupID <- strG
      datmeanPooledMSDPerPathOft <- rbind(datmeanPooledMSDPerPathOft, datNewTable ) 
      #vmeanPooledMSDPerPathOverAllt <- colMeans(datmeanPooledMSDPerPathOft,na.rm=TRUE)
      #vmeanPooledMSDPerPathOverAllt <- as.matrix(vmeanPooledMSDPerPathOverAllt[names(vmeanPooledMSDPerPathOverAllt)]) #Convert to Vector 
      #vmeansdPooledMSDPerPathOverAllt <- as.matrix(colMeans(do.call(rbind,vsdPooledMSDPerPathOft),na.rm=TRUE))
      #vcountPooledMSDPerPathOverAllt <- as.matrix(colSums(do.call(rbind,vcountPooledMSDPerPathOft),na.rm=TRUE))
    }
  }
  
  saveRDS(lMSDStat,paste0(strDataExportDir,"lMSDPerPathLength2mmSummaryResults",min(vtimeWindows),"-",max(vtimeWindows),"sec.rds"))
  saveRDS(datmeanPooledMSDPerPathOft,paste0(strDataExportDir,"datMSDPerPathLength2mmSummaryResults",min(vtimeWindows),"-",max(vtimeWindows),"sec.rds"))
  return(datmeanPooledMSDPerPathOft)
}


##Try To load Precalc Results
try(
{
  rm(lMSDStat);
  datMSDVsPathlengthSummaryData <<- readRDS(paste0(strDataExportDir,"datMSDPerPathLength2mmSummaryResults",min(vtimeWindows),"-",max(vtimeWindows),"sec.rds"));
 lMSDStat <<- readRDS(paste0(strDataExportDir,"lMSDPerPathLength2mmSummaryResults",min(vtimeWindows),"-",max(vtimeWindows),"sec.rds"))
}
)
if (!exists("lMSDStat"))
{
  datMSDVsPathlengthSummaryData <<- makeMSDPathLengthSummary()
}

lMSDStat <<- readRDS(paste0(strDataExportDir,"lMSDPerPathLength2mmSummaryResults",min(vtimeWindows),"-",max(vtimeWindows),"sec.rds"))
  
# PLOT Summary per Path Range - Mean MSD Per Path Length over all T
baddPlot <- FALSE
datmeanPooledMSDPerPathOft <- list()
for (strG in vGroups)
{
  datmeanPooledMSDPerPathOft[[strG]] <-tapply(datMSDVsPathlengthSummaryData[datMSDVsPathlengthSummaryData$groupID == strG,"muMSDPerT"] , datMSDVsPathlengthSummaryData[datMSDVsPathlengthSummaryData$groupID == strG,"breaks"],mean,na.rm=TRUE)
  xtick <- unique(datMSDVsPathlengthSummaryData[datMSDVsPathlengthSummaryData$groupID == strG,"breaks"]) 
  xtick <- xtick[!is.na(xtick)]
  if (!baddPlot)
  {
    plot(xtick, (datmeanPooledMSDPerPathOft[[strG]]),col=colourDataScheme[[strG]],pch=pointTypeScheme[[strG]],lty=lineTypeScheme[[strG]],type="b",
         xlab="Path length (mm)",ylab=" Mean Squared Displacement (mm)",xaxt="n" ,ylim=c(0.2,250))
  
    axis(side=1, at=xtick, labels = names(lMSDStat[[strG]]$`2`$breaks))
    #axis(side=2, at=(axisTicks(c(0.3,2),log=TRUE,nint=5)), labels = axisTicks(c(0.3,2),log=TRUE,nint=5) )  
  }
  else
    points(xtick,(datmeanPooledMSDPerPathOft[[strG]]),col=colourDataScheme[[strG]],pch=pointTypeScheme[[strG]],lty=lineTypeScheme[[strG]],type="b" )
  
  baddPlot <- TRUE
}
  ##Add Theoretical MSD growth vs Time
  propFactor <- 1.0
  lines(xtick ,(theoreticalMeanLength(xtick+2.0,propFactor )),pch=18,cex=0.5,type="b" ) #Up Lim

  legend("topleft", legend=c(names(colourDataScheme)[4:9],"Theory"),
         col=c(unlist(colourDataScheme[names(colourDataScheme)[4:9]]),"black" ),
         pch=c( unlist(pointTypeScheme[names(colourDataScheme)[4:9]]),18 ) )



```

Findings:
  1. Spontaneous MSD grows faster than Evoked
  2. Evoked MSDs look very similar between groups
  2. Over small path lengths there is signs of a Non-linear MSD regime, which suggests super-diffusion

Compared to the linear Dispersion to mean-path length relationship (#path-length per dispersion), the MSD to path-length appears to be non-linear.

## Dispersion Vs MSD
I obtained similar results when looking at MSD and Dispersion over time. These have obvious links, but is their relationship linear?
There is a linear relationship of Dispersion against path-length, but this is supralinear for MSD vs path-length, so perhaps they are not linearly related. 


```{r  mean-squared-distance over Dispersion , fig.show="hold",fig.cap="Non-Linear relationship between dispersal and MSD, is likely evidence of superdiffussion (Disp. is linear to <Path-length>", out.width="100%", echo=FALSE, cache=TRUE}
## iNvariance Principle Theoretical Mean Path Length
theoreticalMeanLength <- function(D,propFactor=1.5)
{
  A <- pi*( (D)^2)
  C <- 2*pi*(D)
  return(round(100*(propFactor* pi*A/C)) /100 )
}
##Integrate time out, and plot MSD per Dispersion size
# ie legth to hit the boundary of the observation circle, is only proportional to the circle (in 2D), volume in 3D- 
process_MSDVsDispersion <- function(ldatDispersion,strGroupID,addPlot=FALSE)
{
  YLIM <- 200
  dispBreaks <- seq(1,13,0.5)
  vmeanPooledMSDPerPathOft  <- list()
  vsdPooledMSDPerPathOft    <- list()
  vcountPooledMSDPerPathOft <- list()
  message("Extracting ", strGroupID )

  datGroupDispersion <- ldatDispersion[ldatDispersion$groupID %in% strGroupID & 
                                                !is.na(ldatDispersion$Dispersion) ,]
  if (NROW(datGroupDispersion) == 0)
  {
    warning("No Dispersion path data for ", strGroupID)
    return(list(muMSDPerT=NA,sdPooledMSDPerT=NA,N=NA,breaks=NA))
  }

  datGroupDispersion$dispRange <- cut(datGroupDispersion[datGroupDispersion$groupID %in% strGroupID ,"Dispersion" ],breaks=dispBreaks)
  
  vmeanPooledMSDPerPathOft  <- tapply(datGroupDispersion$DisplacementSq,datGroupDispersion$dispRange, mean,na.rm=TRUE)
  vcountPooledMSDPerPathOft <- tapply(datGroupDispersion$DisplacementSq,datGroupDispersion$dispRange, NROW)
  vsdPooledMSDPerPathOft    <- tapply(datGroupDispersion$DisplacementSq,datGroupDispersion$dispRange, sd,na.rm=TRUE)
  names(dispBreaks)=names(vmeanPooledMSDPerPathOft)
  #boxplot(datGroupDispersion$Length~datGroupDispersion$dispRange,main=strTitle,col=colourDataScheme[[strGroupID]],ylim=c(0,35))
  return(list(muMSDPerT=vmeanPooledMSDPerPathOft,sdPooledMSDPerT=vsdPooledMSDPerPathOft,N=vcountPooledMSDPerPathOft,breaks=dispBreaks[1:length(vmeanPooledMSDPerPathOft)]  ) )
}

plot_MSDPerDispersionSummary <- function(lMSDPathLStat)
{
  
    strTitle <- paste("mean MSD per Dispersion size", strGroupID,"#")

  if (!addPlot)
  {
    plot(seq(1,max(dispBreaks),length.out = NROW(vmeanPooledMSDPerPathOverAllt)),
         vmeanPooledMSDPerPathOverAllt,pch=pointTypeScheme[[strGroupID]],main=strTitle,xlab="Dispersion size (mm)",
         ylim=c(0,YLIM),xlim=c(0,max(dispBreaks)),col=colourDataScheme[[strGroupID]],cex=0.7 )
  }else
  {
    points(seq(1,max(dispBreaks),length.out = NROW(vmeanPooledMSDPerPathOverAllt)),
         vmeanPooledMSDPerPathOverAllt,pch=16,main=strTitle,xlab="Dispersion size (mm)",
         col=colourDataScheme[[strGroupID]],cex=0.7 )
    lines(seq(1,max(dispBreaks),length.out = NROW(vmeanPooledMSDPerPathOverAllt)),
         vmeanPooledMSDPerPathOverAllt,lwd=1,lty=lineTypeScheme[[strGroupID]])
  }
  
  if (!addPlot)
  {
    propFactor <- 1.0
    rpoints <- seq(0.5,max(dispBreaks), length.out = NROW(vmeanPooledMSDPerPathOverAllt) )
    points(rpoints,theoreticalMeanLength(rpoints,propFactor ),pch=2,cex=0.8 ) #Low Lim
    points(seq(2,max(dispBreaks),1),theoreticalMeanLength(seq(2,max(dispBreaks),1),propFactor ),pch=2,cex=0.5 ) #Up Lim
    points(seq(1,max(dispBreaks),1),theoreticalMeanLength(seq(1,max(dispBreaks),1),propFactor ),pch=2,cex=0.5 ) #Up Lim
    legend("topleft",pch=c(16,2),legend=c("Data","Linear"),col=c(colourDataScheme[[strGroupID]],"black") )
  }
  
}

#pdf(file= paste(strPlotExportPath,"/foraging/plot_meanPathLengthPerMSD.pdf",sep=""),width=7,height=7)
## bottom, left,top, right
#par(mar = c(4.3,4.3,2,1))
makeMSDDispersionSummary <- function ()
{
    ##Load All
  baddPlot <- FALSE
  lMSDStat <- list()
  datmeanPooledMSDPerPathOft <- data.frame()
  ## Loop to sequantially load and process Dispersion data across time scales - freeing memory before re-allocating
  for (strG in vGroups)
  {
    lMSDStat[[strG]] <- list()  
    
    for (t in vtimeWindows)
    { 
      
      rm(ldatDispersion)   #Clear Mem
      ldatDispersion<- list()
      print (t)
      ##Load MSD /Dispersion/ Path Data
      ldatDispersion[[as.character(t)]]<- loadDispersionData(T,t) #readRDS(file=paste0(str,"/foragingState_Dispersion",t,"sec.rds") ) 
      
      lMSDStat[[strG]][[as.character(t)]] <- process_MSDVsDispersion(ldatDispersion[[as.character(t)]],strG)
      
      #plotMSDPerIntegrationTime(ldatDispersion,"NE",lLinModel)
    
      datNewTable <- data.frame(do.call(cbind, lMSDStat[[strG]][[as.character(t)]] ))
      datNewTable$T <- as.character(t)
      datNewTable$groupID <- strG
      datmeanPooledMSDPerPathOft <- rbind(datmeanPooledMSDPerPathOft, datNewTable ) 
      #vmeanPooledMSDPerPathOverAllt <- colMeans(datmeanPooledMSDPerPathOft,na.rm=TRUE)
      #vmeanPooledMSDPerPathOverAllt <- as.matrix(vmeanPooledMSDPerPathOverAllt[names(vmeanPooledMSDPerPathOverAllt)]) #Convert to Vector 
      #vmeansdPooledMSDPerPathOverAllt <- as.matrix(colMeans(do.call(rbind,vsdPooledMSDPerPathOft),na.rm=TRUE))
      #vcountPooledMSDPerPathOverAllt <- as.matrix(colSums(do.call(rbind,vcountPooledMSDPerPathOft),na.rm=TRUE))
    }
  }
  
  saveRDS(lMSDStat,paste0(strDataExportDir,"lMSDPerDispersion05mmSummaryResults",min(vtimeWindows),"-",max(vtimeWindows),"sec.rds"))
  saveRDS(datmeanPooledMSDPerPathOft,paste0(strDataExportDir,"datMSDPerDispersion05mmSummaryResults",min(vtimeWindows),"-",max(vtimeWindows),"sec.rds"))
  return(datmeanPooledMSDPerPathOft)
}


##Try To load Precalc Results
try(
  {
    rm(lMSDDispersionStat)
    datMSDVsDispersionSummaryData <<- readRDS(paste0(strDataExportDir,"datMSDPerDispersion05mmSummaryResults",min(vtimeWindows),"-",max(vtimeWindows),"sec.rds"));
    lMSDDispersionStat <<- readRDS(paste0(strDataExportDir,"lMSDPerDispersion05mmSummaryResults",min(vtimeWindows),"-",max(vtimeWindows),"sec.rds"))
  }
)
if (!exists("lMSDDispersionStat"))
{
  datMSDVsDispersionSummaryData <<- makeMSDDispersionSummary()
}

lMSDDispersionStat <<- readRDS(paste0(strDataExportDir,"lMSDPerDispersion05mmSummaryResults",min(vtimeWindows),"-",max(vtimeWindows),"sec.rds"))
  
# PLOT Summary per Path Range - Mean MSD Per Path Length over all T
baddPlot <- FALSE
datmeanPooledMSDPerDispersionOft <- list()
for (strG in vGroups)
{
  datmeanPooledMSDPerDispersionOft[[strG]] <- tapply(datMSDVsDispersionSummaryData[datMSDVsDispersionSummaryData$groupID == strG,"muMSDPerT"] , datMSDVsDispersionSummaryData[datMSDVsDispersionSummaryData$groupID == strG,"breaks"],mean,na.rm=TRUE)
  
  xtick <- unique(datMSDVsDispersionSummaryData[datMSDVsDispersionSummaryData$groupID == strG,"breaks"]) 
  xtick <- xtick[!is.na(xtick)]
  if (!baddPlot)
  {
    plot(xtick, (datmeanPooledMSDPerDispersionOft[[strG]]),col=colourDataScheme[[strG]],pch=pointTypeScheme[[strG]],lty=lineTypeScheme[[strG]],type="b",
         xlab="Dispersion size (mm)",ylab=" Mean Squared Displacement (mm)",xaxt="n" ,ylim=c(0.2,320))
  
    axis(side=1, at=xtick, labels = names(lMSDDispersionStat[[strG]]$`2`$breaks))
    #axis(side=2, at=(axisTicks(c(0.3,2),log=TRUE,nint=5)), labels = axisTicks(c(0.3,2),log=TRUE,nint=5) )  
  }
  else
    points(xtick,(datmeanPooledMSDPerDispersionOft[[strG]]),col=colourDataScheme[[strG]],pch=pointTypeScheme[[strG]],lty=lineTypeScheme[[strG]],type="b" )
  
  baddPlot <- TRUE
}
  ##Add Theoretical MSD growth vs Time
  propFactor <- 1.0
  lines(xtick ,(theoreticalMeanLength(xtick+2.0,propFactor )),pch=18,cex=0.5,type="b" ) #Up Lim

  legend("topleft", legend=c(names(colourDataScheme)[4:9],"Linear"),
         col=c(unlist(colourDataScheme[names(colourDataScheme)[4:9]]),"black" ),
         pch=c( unlist(pointTypeScheme[names(colourDataScheme)[4:9]]),18 ) )



```

I find that a *supralinear* relationship holds between dispersion and MSD that appears consistent across all groups
Since Dispersion and Path length are linear, then it follows that MSD and path-length are also supralinear (as shown earlier in)

# Statistical comparison of motion-trajectories 

```{r child = 'ForagingStateAnalysis_ModelFitting.Rmd',eval=FALSE}
##Clustering Code Separated into a sub RMarkdown
```
  


# Identifying states of foraging behaviour

```{r child = 'ForagingStateAnalysis_Clustering.Rmd',eval=TRUE}
##Clustering Code Separated into a sub RMarkdown
```


# Hunt initiation and foraging state

```{r child = 'ForagingStateAnalysis_HuntEvents.Rmd',eval=TRUE}
## Hunt events with foraging state Clustering results Separated into a sub RMarkdown
```


<!--

### Model implementantion in Stan

To implement the normal mixture model outlined in the previous section in Stan, the discrete parameters can be summed out of the model.
If Y is a mixture of K normal distributions with locations μk and scales σk with mixing proportions λ in the unit K-simplex, then 
\[p_Y\left(y \mid \lambda, \mu, \sigma \right) = \sum_{k=1}^K \lambda_k \, \textsf{normal}\left(y \mid \mu_k, \sigma_k\right).\]
I will defer using Stan for this and go for my familiar Jags model implementation.
-->


# Full figure List of trajectories per experiment

The following figures show the tracked trajectories per experiment of each group.
Trajectory segments are colour coded according to whether these can be classified as exploration or exploitation based on ta theshold on the normalized dispersion. This threshold is set here to `r thres_dispersion_class ` .
Red signiifies segments of exploitation, blue is for exploration. 
The column on the right shows the dispersion measurement along recording time. Note the x-axis is not real time, it is the total time of  concatenated recording events. The horizontal line represents where the exploit/explore dispersal threshold sits for each larva, given its normalized disperal measurements.
The triangles at the bottom denote hunt-event initiations in relation to dispersal.

  - Observing dispersals and trajectories it becomes clear that during a 10 min recording a larva could be in exploitation phase all the way, and thus the range of dispersals that this larva can produce is most likely not observed. see : 
   - NL 309/NE 302


## Trajectories clustered on Global NB Mix Model  

Note that dispersion is normalized based on the trajectories from Spontaneous and Evoked conditions *combined* for each larva.
Here it should be noted that in Marquez et al 2019 "To facilitate comparison across animals, the dispersal distance was normalized to the range of each animal."
That means this is not a division by the maximum dispersal of each animal, but it also makes use of the minimum.

#### LF - Evoked /Spontaneous Trajectories
```{r  NBMixClustered-trajectories-LL, fig.show="hold", out.width="50%", echo=FALSE, results='hide' , cache=TRUE, autodep=TRUE,eval=FALSE,warning=FALSE}

loaddatAllFrames()
loadDispersionData()

  plotNBMixGClusteredDispersionTrajectories(c('LL','LE'),datAllFrames, datDispersion ,datHEventDispersion,datExpPairs,  thres_dispersion_class )

```

#### NF - Evoked/Spontaneous Trajectories 
```{r larva_norm-trajectories-NL, fig.show="hold", out.width="50%", echo=FALSE, results='hide',cache=TRUE, autodep=TRUE,eval=FALSE,warning=FALSE}
plotLarvaNormDispersionTrajectories(c('NL','NE'),datAllFrames, datDispersion ,datHEventDispersion,datExpPairs, thres_dispersion_class )

```
  
#### DF - Evoked/Spontaneous Trajectories 
```{r larva_norm-trajectories-DL, fig.show="hold", out.width="50%", echo=FALSE, results='hide', cache=TRUE, autodep=TRUE,eval=FALSE,warning=FALSE}

plotLarvaNormDispersionTrajectories(c('DL','DE'),datAllFrames, datDispersion , datHEventDispersion, datExpPairs, thres_dispersion_class)


```

## Classifying exploitation/exploration phases based on **global threshold**
The dispersion of each experiment is normalized globally and thus classification threhsold for exploitation identifies trajectory segments of spatially restricted motion relative to all larvae across groups

### Evoked conditions
Trajectories of 10min recordings in the presence of prey. Note, in contrast to Marquez et al. 2019, our recodings exclude motion at the boundary of petridish.

#### LF - Evoked+Sponτaneous larval trajectories
Eploitation state is shown in *red* and *orange* in evoked and spontaneous test conditions respectivelly, with hunt events shown as squares.
Exploration state is *blue* and *green* in evoked and spontaneous test conditions respectivelly, , with hunt events shown as triangles.

```{r  global_norm-trajectories-LL, fig.show="hold", out.width="50%", echo=FALSE, results='hide', cache=TRUE, autodep=TRUE,eval=FALSE }
loaddatAllFrames()
loadDispersionData()
plotGlobalNormDispersionTrajectories(c('LL','LE'), datAllFrames, datDispersion, datHEventDispersion, datExpPairs,   thres_dispersion_class )

```

#### NF - Evoked+Spont Trajectories 
```{r global_norm-trajectories-NL, fig.show="hold", out.width="50%", echo=FALSE, results='hide', cache=TRUE, autodep=TRUE,eval=FALSE}

plotGlobalNormDispersionTrajectories(c('NL','NE'),datAllFrames,datDispersion,datHEventDispersion,datExpPairs, thres_dispersion_class )

```

#### DF - Evoked Trajectories 
```{r global_norm-trajectories-DL, fig.show="hold", out.width="50%", echo=FALSE, results='hide', cache=TRUE, autodep=TRUE,eval=FALSE}

plotGlobalNormDispersionTrajectories(c('DL','DE'),datAllFrames,datDispersion,datHEventDispersion,datExpPairs, thres_dispersion_class)

```

## Classify based on normalizated experiment trajectory dispersion

Note that Spontaneous and Evoked conditions of each larva are considered individually

#### LF - Evoked /Spontaneous Trajectories
```{r  exp_norm-trajectories-LL, fig.show="hold", out.width="50%", echo=FALSE, results='hide' , cache=TRUE, autodep=TRUE,eval=FALSE}
loaddatAllFrames()
loadDispersionData()
plotExpNormDispersionTrajectories(c('LL','LE'),datAllFrames,datDispersion ,datHEventDispersion,datExpPairs,  thres_dispersion_class )

```

#### NF - Evoked/Spontaneous Trajectories 
```{r exp_norm-trajectories-NL, fig.show="hold", out.width="50%", echo=FALSE, results='hide',cache=TRUE, autodep=TRUE,eval=FALSE}

plotExpNormDispersionTrajectories(c('NL','NE'),datAllFrames,datDispersion ,datHEventDispersion,datExpPairs, thres_dispersion_class )

```

#### DF - Evoked/Spontaneous Trajectories 
```{r exp_norm-trajectories-DL, fig.show="hold", out.width="50%", echo=FALSE, results='hide', cache=TRUE, autodep=TRUE,eval=FALSE}


plotExpNormDispersionTrajectories(c('DL','DE'),datAllFrames,datDispersion ,datHEventDispersion,datExpPairs, thres_dispersion_class)

```



```{r child = 'ForagingStateAnalysis_Modelling.Rmd'}
##Clustering Code Separated into a sub RMarkdown
```


# END

```{r spare-code-notes,eval=FALSE, include=FALSE}
## Retrieve Dispersion of each Hunt Event
start.time <- Sys.time()
i <- 0
for (i in 1:NROW(datHuntLabelledEventsSBMerged_fixed) )
{

   datHEvent_disp <- datDispersion[datDispersion$expID == datHuntLabelledEventsSBMerged_fixed[i,]$expID &
                              datDispersion$eventID == datHuntLabelledEventsSBMerged_fixed[i,]$eventID &
                              datDispersion$frameN == datHuntLabelledEventsSBMerged_fixed[i,]$startFrame ,] #
   #message(datHEvent_disp$expID)

   if (NROW(datHEvent_disp) == 0 )
   {
     warning("Tracking dispersion data not found for huntevent ",i, "at startframe ",datHuntLabelledEventsSBMerged_fixed[i,]$startFrame )
     ##Try Again without the start frame - Slower
     datHEvent_disp <- datDispersion[datDispersion$expID == datHuntLabelledEventsSBMerged_fixed[i,]$expID &
                              datDispersion$eventID == datHuntLabelledEventsSBMerged_fixed[i,]$eventID  ,] #
   }

   if (NROW(datHEvent_disp) == 0 )
     warning("Attaching dispersion data for huntevent ",i, " Failed")

   # Check if Rec Exists
   if (NROW(datHEvent_disp) == 1 )
   {

     vHuntEventDispersion[i] <- datHEvent_disp$Dispersion
     vHuntEventDispersion_norm[i] <-  datHEvent_disp$Dispersion_norm
     message(i," Disp:",vHuntEventDispersion[i])

   }else {

     ## Multiple rows returned
     ## FInd Tracking (Dispersion dat) frame that is closest to hunt-event initiation (start frame)
     idx <- NA
     with(datHuntLabelledEventsSBMerged_fixed[i,],
          {
                idx <- which(abs(datHEvent_disp$frameN - startFrame) == min(abs(datHEvent_disp$frameN - startFrame) ) )

                vHuntEventDispersion_norm[i] <- datHEvent_disp[idx,"Dispersion_norm"]
                vHuntEventDispersion[i] <- datHEvent_disp[idx,"Dispersion"]
               ##This Maybe NA since there are no Dispersion Data In some Occassions
               ##stopifnot(!is.na(vHuntEventDispersion[i]))
               message("Found idx ",idx, " Disp ",vHuntEventDispersion[i])
          })

   }

    #Find Dispersion At start Frame of Hunt Event
    #
    print(i)


    #stopifnot(i <11)
}

   end.time <- Sys.time()
   time.taken <- end.time - start.time
   print(time.taken)

 
```
